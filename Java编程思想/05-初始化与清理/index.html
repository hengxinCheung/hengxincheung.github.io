<!-- build time:Fri Jul 03 2020 21:34:29 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>05-初始化与清理 | hengxincheung&#39;s Blog</title><meta name="description" content="随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。初始化（initialize）和清理（cleanup）正是涉及安全的两个问题。许多C程序的错误都源于程序员忘记初始化变量。清理也是一个特殊问题，当使用完一个元素时，容易把它忘掉，以至于这个元素占用的资源一直得不到释放，结果是计算机资源（特别是内存）用尽。C++引入了构造器（constructor）的概念，这是一个在创建对象"><meta property="og:type" content="article"><meta property="og:title" content="05-初始化与清理"><meta property="og:url" content="https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/05-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"><meta property="og:site_name" content="hengxincheung&#39;s blog"><meta property="og:description" content="随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。初始化（initialize）和清理（cleanup）正是涉及安全的两个问题。许多C程序的错误都源于程序员忘记初始化变量。清理也是一个特殊问题，当使用完一个元素时，容易把它忘掉，以至于这个元素占用的资源一直得不到释放，结果是计算机资源（特别是内存）用尽。C++引入了构造器（constructor）的概念，这是一个在创建对象"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-05-25T15:13:29.000Z"><meta property="article:modified_time" content="2020-05-27T07:24:10.247Z"><meta property="article:author" content="hengxincheung"><meta property="article:tag" content="Java"><meta property="article:tag" content="编程思想"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/05-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/index.html"><link rel="alternate" href="/atom.xml" title="hengxincheung&#39;s blog" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link href="//cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css" rel="stylesheet"><link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.1"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/hengxincheung" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">hengxincheung</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">码农</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Guangzhou, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/hengxincheung" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/null" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/null" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/null" target="_blank" title="Behance" data-toggle="tooltip" data-placement="top"><i class="icon icon-behance"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎您，瓜子和茶都没有。</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">linux快速入门</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/numpy%E6%95%99%E7%A8%8B/">numpy教程</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">统计机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/Java/" style="font-size:14px">Java</a> <a href="/tags/RESTful/" style="font-size:13px">RESTful</a> <a href="/tags/git/" style="font-size:13px">git</a> <a href="/tags/linux/" style="font-size:13.5px">linux</a> <a href="/tags/numpy/" style="font-size:13.75px">numpy</a> <a href="/tags/python/" style="font-size:13.75px">python</a> <a href="/tags/web/" style="font-size:13.25px">web</a> <a href="/tags/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/" style="font-size:13px">权限系统</a> <a href="/tags/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/" style="font-size:13px">用户系统</a> <a href="/tags/%E7%99%BB%E5%BD%95/" style="font-size:13px">登录</a> <a href="/tags/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size:13px">统计机器学习</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/" style="font-size:14px">编程思想</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size:13px">设计模式</a> <a href="/tags/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/" style="font-size:13px">随机森林</a></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></p><p class="item-title"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/21-%E5%B9%B6%E5%8F%91/" class="title">21-并发</a></p><p class="item-date"><time datetime="2020-07-03T13:31:04.000Z" itemprop="datePublished">2020-07-03</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></p><p class="item-title"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/20-%E6%B3%A8%E8%A7%A3/" class="title">20-注解</a></p><p class="item-date"><time datetime="2020-07-03T13:30:32.000Z" itemprop="datePublished">2020-07-03</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></p><p class="item-title"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/19-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/" class="title">19-枚举类型</a></p><p class="item-date"><time datetime="2020-07-03T13:29:52.000Z" itemprop="datePublished">2020-07-03</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></p><p class="item-title"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/18-IO%E7%B3%BB%E7%BB%9F/" class="title">18-IO系统</a></p><p class="item-date"><time datetime="2020-07-03T13:29:07.000Z" itemprop="datePublished">2020-07-03</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></p><p class="item-title"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/17-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/" class="title">17-容器深入研究</a></p><p class="item-date"><time datetime="2020-06-21T15:20:01.000Z" itemprop="datePublished">2020-06-21</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#用构造器确保初始化"><span class="toc-number">1.</span> <span class="toc-text">用构造器确保初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法重载"><span class="toc-number">2.</span> <span class="toc-text">方法重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#区分重载方法"><span class="toc-number">2.1.</span> <span class="toc-text">区分重载方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#涉及基本类型的重载"><span class="toc-number">2.2.</span> <span class="toc-text">涉及基本类型的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以返回值区分重载方法"><span class="toc-number">2.3.</span> <span class="toc-text">以返回值区分重载方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#默认构造器"><span class="toc-number">3.</span> <span class="toc-text">默认构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this关键字"><span class="toc-number">4.</span> <span class="toc-text">this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在构造器中调用构造器"><span class="toc-number">4.1.</span> <span class="toc-text">在构造器中调用构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static的含义"><span class="toc-number">4.2.</span> <span class="toc-text">static的含义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#清理：终结处理和垃圾回收"><span class="toc-number">5.</span> <span class="toc-text">清理：终结处理和垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize-用途何在"><span class="toc-number">5.1.</span> <span class="toc-text">finalize()用途何在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你必须实施清理"><span class="toc-number">5.2.</span> <span class="toc-text">你必须实施清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#终结条件"><span class="toc-number">5.3.</span> <span class="toc-text">终结条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器如何工作"><span class="toc-number">5.4.</span> <span class="toc-text">垃圾回收器如何工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何寻找垃圾"><span class="toc-number">5.5.</span> <span class="toc-text">如何寻找垃圾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何处理垃圾"><span class="toc-number">5.6.</span> <span class="toc-text">如何处理垃圾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自适应技术"><span class="toc-number">5.7.</span> <span class="toc-text">自适应技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#即时编译技术"><span class="toc-number">5.8.</span> <span class="toc-text">即时编译技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#成员初始化"><span class="toc-number">6.</span> <span class="toc-text">成员初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造器初始化"><span class="toc-number">7.</span> <span class="toc-text">构造器初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化顺序"><span class="toc-number">7.1.</span> <span class="toc-text">初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态数据的初始化"><span class="toc-number">7.2.</span> <span class="toc-text">静态数据的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#显式的静态初始化"><span class="toc-number">7.3.</span> <span class="toc-text">显式的静态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非静态实例初始化"><span class="toc-number">7.4.</span> <span class="toc-text">非静态实例初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组初始化"><span class="toc-number">8.</span> <span class="toc-text">数组初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可变参数列表"><span class="toc-number">8.1.</span> <span class="toc-text">可变参数列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举类型"><span class="toc-number">9.</span> <span class="toc-text">枚举类型</span></a></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-Java编程思想/05-初始化与清理" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">05-初始化与清理</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/05-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/" class="article-date"><time datetime="2020-05-25T15:13:29.000Z" itemprop="datePublished">2020-05-25</time></a></span> <span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></span> <span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link" href="/tags/Java/" rel="tag">Java</a>, <a class="article-tag-link" href="/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/" rel="tag">编程思想</a></span> <span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></span> <span class="post-comment"><i class="icon icon-comment"></i> <a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/05-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 6.8k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 24(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p>随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。</p><p><strong>初始化（initialize）和清理（cleanup）</strong>正是涉及安全的两个问题。许多C程序的错误都源于程序员忘记初始化变量。清理也是一个特殊问题，当使用完一个元素时，容易把它忘掉，以至于这个元素占用的资源一直得不到释放，结果是计算机资源（特别是内存）用尽。</p><p>C++引入了<strong>构造器（constructor）</strong>的概念，<strong>这是一个在创建对象时被自动调用的特殊方法</strong>。Java也采用了构造器，并额外提供了<strong>“垃圾回收器”</strong>。对于不再使用的内存资源，垃圾回收器能自动将其释放。</p><h2 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h2><p>在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果类具有构造器，<strong>Java就会在用户有能力操作对象之前自动调用相应的构造器</strong>，从而保证了初始化的进行。</p><p>考虑到编译器会在初始化期间自动调用构造器，<strong>构造器采用与类相同的名称</strong>。假设我们拥有以下这样一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock</span></span>&#123;</span><br><span class="line">    Rock()&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm Rock!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，在创建对象时<code>new Rock()</code>，将会为对象分配存储空间，并调用相应的构造器。这就确保了在你能操作对象之前，它已经被恰当地初始化了。<em>注意：构造器也是一个方法，但是这个方法与其他方法不一样的地方在于，不需要为其声明任何返回类型。</em></p><p>不接受任何参数的构造器叫做<strong>默认构造器</strong>，Java文档中通常使用术语<strong>无参构造器</strong>。和其他方法一样，<strong>构造器也能带有形式参数</strong>，以便指定如何创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Speaker</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这是无参构造器</span></span><br><span class="line">    Speaker()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sorry, I don't know who you are!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是有参构造器</span></span><br><span class="line">    Speaker(String name)&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span> + name + <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从概念上讲，“初始化”与“创建”是彼此独立的。但在Java中，“初始化”与“创建”捆绑在一起，两者不能分离。</p><p><strong>构造器是一种特殊类型的方法，因为它没有返回值（不是指<code>void</code>，带有<code>void</code>的方法实际上返回的是一个<code>void</code>类型的变量）。</strong>需要注意的是，<code>new</code>表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值。正如上述所说，其实这里是两步：创建对象与调用该对象的构造器方法（初始化），只是Java在我们<code>new</code>一个对象时，会自动帮我们调用其构造器方法。</p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>任何程序设计语言都具备的一项重要特性就是<strong>名字的运用</strong>。当创建一个对象时，也就给此对象分配到的存储空间取了一个名字。所谓方法则是给某个动作取的名字。通过使用名字，你可以引用所有的对象和方法。</p><p>在Java和C++里，构造器是强制<strong>重载方法名</strong>的一个重要原因。因为构造器必须与类同名，但我们又想为用户提供多种初始化的方式。为了让方法名相同而形式参数不同的构造器同时存在，必须用到<strong>方法重载</strong>，同时其亦可用于其他方法且用法相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Speaker</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这是无参构造器</span></span><br><span class="line">    Speaker()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sorry, I don't know who you are!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载：这是有参构造器</span></span><br><span class="line">    Speaker(String name)&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span> + name + <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法sayHello()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载方法sayHello(),向具体的人</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span> + name + <span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区分重载方法"><a href="#区分重载方法" class="headerlink" title="区分重载方法"></a>区分重载方法</h3><p><strong>每个重载的方法都必须有一个有一个独一无二的参数类型列表。</strong></p><p>在Java中，编译器是通过<strong>方法名+参数列表作为唯一的方法签名</strong>去识别具体调用哪个方法。</p><h3 id="涉及基本类型的重载"><a href="#涉及基本类型的重载" class="headerlink" title="涉及基本类型的重载"></a>涉及基本类型的重载</h3><p>基本类型能从一个“较小”的类型自动提升至一个“较大”的类型，此类型一旦牵涉到重载，可能会造成一些混淆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimitiveOverloading</span></span>&#123;</span><br><span class="line">    <span class="comment">// void f1(char x)&#123;System.out.println("char");&#125;</span></span><br><span class="line">    <span class="comment">// void f1(byte x)&#123;System.out.println("byte");&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;System.out.println(<span class="string">"int"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123;System.out.println(<span class="string">"float"</span>);&#125;</span><br><span class="line">    <span class="comment">// void f1(double x)&#123;System.out.println("double");&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面的输出是:int</span></span><br><span class="line"><span class="keyword">new</span> PrimitiveOverloading().f1(<span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 下面会编译器报错</span></span><br><span class="line"><span class="keyword">new</span> PrimitiveOverloading().f1(<span class="number">5.0</span>D);</span><br></pre></td></tr></table></figure><p>从上面的代码可以得出结论：</p><ul><li><strong>如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际参数类型会被提升；</strong></li><li><strong>如果传入的实际参数较大，就得手动通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。</strong></li></ul><h3 id="以返回值区分重载方法"><a href="#以返回值区分重载方法" class="headerlink" title="以返回值区分重载方法"></a>以返回值区分重载方法</h3><p>在Java中，根据方法的返回值来区分重载方法是行不通的。</p><p>因为Java是通过<strong>方法签名（方法名+参数列表）</strong>来标识和区分不同的方法的。</p><h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><p>默认构造器（又名“无参”构造器）是没有形式参数的—它的作用是创建一个“默认对象”。<strong>如果你的类中没有构造器，则编译器会自动帮你创建一个默认构造器。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面的类中并未明确定义构造器，但你创建其对象时仍会触发默认构造器的方法，因为编译器会为你自动添加一个默认构造器。<strong>但是，如果你已经定义了一个构造器（无论有无参数），编译器就不会帮你自动创建默认构造器。</strong>因为编译器会认为你只允许用户由该“入口”创建并初始化该对象。</p><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>为了能用简便、面向对象的语法来编写代码—即“发送消息给对象”。<strong>在你调用对象方法时候，编译器会做一些幕后的工作，它暗自把“所操作对象的引用”作为第一个参数传递给方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 你调用sayHello()方法</span></span><br><span class="line">person.sayHello();</span><br><span class="line"><span class="comment">// 实际在内部的表达形式如下</span></span><br><span class="line">Person.sayHello(person);</span><br></pre></td></tr></table></figure><p>假设你希望在方法的内部<strong>获得对当前对象的引用</strong>，可以使用关键字<code>this</code>。因为这个引用是由编译器“偷偷”传入的，所以没有标识符可用。</p><p><strong><code>this</code>关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。</strong>一般来说，只有当需要明确指出对当前对象的引用时，才需要使用<code>this</code>关键字。</p><p>例如，当需要返回对当前对象的引用时，就常常在<code>return</code>语句里这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">increament</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h3><p>可能为一个类写了多个构造器，有时可能想在一个构造器中调用另一个构造器，以避免重复代码。可以用<code>this</code>关键字做到这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果传入参数与对象内部参数同名，需要使用this关键字加以区分</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String email)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 调用其他的构造器方法</span></span><br><span class="line">        <span class="keyword">this</span>(name)；</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：构造器中调用构造器通过<code>this(...)</code>的方法，但该条语句必须是构造器的第一行代码。</em></p><h3 id="static的含义"><a href="#static的含义" class="headerlink" title="static的含义"></a>static的含义</h3><p><strong><code>static</code>（静态）方法是没有<code>this</code>的方法，在<code>static</code>方法内部不能调用非静态方法。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用<code>static</code>方法。</strong>这实际正是<code>static</code>方法的主要用途。Java禁止全局方法，但你可以在类中置入<code>static</code>方法就可以访问其他<code>static</code>方法和<code>static</code>域（这句话我觉得有点问题）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.sayHello();</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们为<code>Person</code>类声明了一个<code>sayHello()</code>的静态方法。在外部，我们可以通过类名直接调用该方法，而不需要初始化该对象。</p><h2 id="清理：终结处理和垃圾回收"><a href="#清理：终结处理和垃圾回收" class="headerlink" title="清理：终结处理和垃圾回收"></a>清理：终结处理和垃圾回收</h2><p>程序员常常忘记十分重要的清理工作。在使用程序时，把一个对象用完就“弃之不理”的做法是不安全的。当然，<strong>Java有垃圾回收器负责回收无用对象占据的内存资源</strong>。</p><p>但也有特殊情况：假定你的对象（并非使用<code>new</code>创建）获得了一块“特殊”的内存区域，由于<strong>垃圾回收器只知道释放那些经由<code>new</code>分配的内存</strong>。为了应对这种情况，Java允许在类中定义一个名为<code>finalize()</code>的方法。</p><p><code>finalize()</code>的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其<code>finalize()</code>方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。</p><p>换言之，只有当“垃圾回收”发生时（不能保证一定会发生），<code>finalize()</code>才会得到调用。</p><h3 id="finalize-用途何在"><a href="#finalize-用途何在" class="headerlink" title="finalize()用途何在"></a>finalize()用途何在</h3><p><strong>不应该将finalize()作为通用的清理方法</strong>。</p><p>请先记住下面这一点：</p><ul><li><strong>垃圾回收只与内存有关</strong>：也就是说，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是<code>finalize()</code>方法），它们也必须同内存及其回收有关。之所以要有<code>finalize()</code>是由于<strong>分配内存时候可能采用了类似C语言的做法</strong>，而非Java中的通常做法。这种情况主要发生在使用<strong>“本地方法”</strong>的情况下，本地方法是一种在Java中调用非Java代码的方式。本地方法目前只支持C和C++，但它们可以调用其他语言的代码，所以实际上可以调用任何代码。</li></ul><h3 id="你必须实施清理"><a href="#你必须实施清理" class="headerlink" title="你必须实施清理"></a>你必须实施清理</h3><p>要清理一个对象，用户必须在需要清理的时刻调用执行清理动作的方法。</p><p>Java不允许创建局部对象，必须使用<code>new</code>创建对象。在Java中，也没有用于释放对象的<code>delete</code>，因为垃圾回收器会帮助你释放存储空间。但你现在需要知道<strong>垃圾回收器的存在并不能完全替代析折函数（而且绝对不能直接调用finalize（），这不是一种解决方案）</strong>。</p><p>记住，<strong>无论是“垃圾回收”还是“终结”，都不一定保证会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存</strong>。</p><h3 id="终结条件"><a href="#终结条件" class="headerlink" title="终结条件"></a>终结条件</h3><p>通常不能指望<code>finalize()</code>，必须创建其他的”清理”方法，并且明确调用它们。不过，<code>finalize()</code>还有一个有趣的用法，它并不依赖于每次都要对<code>finalize()</code>进行调用，这就是对象<strong>终结条件</strong>的验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> checkedOut = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        checkedOut = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(checkedOut)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Error!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Book novel = <span class="keyword">new</span> Book();</span><br><span class="line">        novel.checkIn();</span><br><span class="line">        <span class="comment">// 忘记清理</span></span><br><span class="line">        <span class="keyword">new</span> Book();</span><br><span class="line">        <span class="comment">// 强制发生垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的<code>Book</code>对象在被当作垃圾回收器前都应该被签入(check in)，在上面代码中的第二个<code>Book</code>对象未被签入，在发生垃圾回收时会导致异常错误。</p><p>注意：<code>System.gc()</code>用于强制进行终止动作。</p><h3 id="垃圾回收器如何工作"><a href="#垃圾回收器如何工作" class="headerlink" title="垃圾回收器如何工作"></a>垃圾回收器如何工作</h3><p>在以前的程序语言中，在堆上分配对象的代价十分高昂。然而，垃圾回收器对于提高对象的创建速度，却具有明显的效果。这意味着，Java从堆分配空间的速度，可以和其他语言从堆栈上分配空间的速度相媲美。</p><p>C++里面的堆可以想象成一个院子，里面每个对象都负责管理自己的地盘。一段时间以后，对象可能会被销毁，但地盘必须加以重用。在某些Java虚拟机中，堆的实现截然不同：它更像一个传送带，每分配一个对象，它就往前移动一格。这就意味着对象存储空间的分配速度非常快。<strong>Java的“堆指针”只是简单地移动到尚未分配的区域，其效率比得上C++在堆栈上分配空间的效率。</strong></p><p>但更重要的原因在于垃圾回收器的介入。当它工作时，<strong>将一面回收空间，一面使堆中的对象紧凑排列</strong>，这样“堆指针”就可以很容易移动到更靠近传送带的开始处，也就尽量避免了页面错误。<strong>通过垃圾回收器对对象重新排列，实现了一种高速的、有无限空间可供分配的堆模型。</strong></p><h3 id="如何寻找垃圾"><a href="#如何寻找垃圾" class="headerlink" title="如何寻找垃圾"></a>如何寻找垃圾</h3><p><strong>引用计数</strong>是一种简单但速度很慢的垃圾回收技术。每个对象都含有一个引用计数器，当有引用连接到对象时，引用计数加1。当引用离开作用域或者置为<code>null</code>时，引用计数减1。</p><p>垃圾回收器会在含有全部对象的列表上遍历，当发现某个对象的引用计数为0时，就释放其占有的空间。</p><p>这种方法有个缺陷，如果对象之间存在循环引用，可能会出现“对象应被回收，但引用计数却不为零”的情况。如下面的代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span>&#123;</span><br><span class="line">    Student student;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    Teacher teacher;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个对象循环引用</span></span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        teacher.student = student;</span><br><span class="line">        student.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些更快的模式，垃圾回收器使用可达路径，依据的思想是：<strong>对任何“活”对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。</strong></p><p>这条引用链条可能会穿过数个对象层次。由此，如果从堆栈和静态存储区开始，遍历所有的引用，就能找到所有“或的对象”。对于发现的每个引用，必须追踪到它所引用的对象，然后是此对象包含的所有引用，如此反复进行，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。</p><p>在这种方式下，Java虚拟机将采用一种<strong>自适应</strong>的垃圾回收技术。</p><h3 id="如何处理垃圾"><a href="#如何处理垃圾" class="headerlink" title="如何处理垃圾"></a>如何处理垃圾</h3><p>如何处理找到的存活的对象，取决于不同的Java虚拟机的实现。有一种做法叫做<strong>停止-复制（stop-and-copy）</strong>。</p><p>显然这意味着，<strong>先暂停程序的运行（所以这不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有复制的全部都是垃圾</strong>。当对象复制到新堆时，它们是一个挨着一个的，所以新堆保持紧凑排列。</p><p>当把对象从一处搬到一处时，所有指向它的那些引用都必须修正。位于堆或静态存储区的引用可以直接修正，但可能还有其他指向这些对象的引用，它们在遍历过程中才能被找到（可以想象有个表格，将旧地址映射到新地址）。</p><p>对于这种“复制式回收器”而言，效率会降低。这有两个原因：</p><ul><li>首先，得有两个堆，然后得在这两个分离的堆上来回折腾，从而维护比实际需要多一倍的空间。某些Java虚拟机对此处理的方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块的内存之间。</li><li>第二个问题在于复制。程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。此时复制回收器仍将会将所有内存自一处复制到另一处，这很浪费。</li></ul><p>为了避免上述情形，一些Java虚拟机会进行检查：要是没有新垃圾产生，就会<strong>自适应</strong>转换到另一种工作模式：<strong>标记-清扫（mark-and-sweep）</strong>（Sun公司早期版本的Java虚拟机使用该技术）。</p><p>标记-清扫所依据的思路是：<strong>从堆栈和静态存储区出发，遍历所用引用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象设一个标记，这个过程不会发生任何回收对象。</strong>只有当所有标记工作完成的时候，清理动作才会开始。在清理过程中，<strong>没有标记的对象将会被释放，不会发生复制动作</strong>。所以剩下的堆空间是<strong>不连续的</strong>。</p><p>垃圾回收器如果希望得到连续空间的话，就得重新整理剩下的对象。</p><h3 id="自适应技术"><a href="#自适应技术" class="headerlink" title="自适应技术"></a>自适应技术</h3><p>如前文所述，在这里所讨论的Java虚拟机中，内存分配以较大的<strong>“块”</strong>为单位。如果对象较大，它会占用单独的块。</p><p>严格来说，“停止-复制”要求在释放旧有对象之前，必须先把所有存活对象从旧堆复制到新堆。</p><p>有了块之后，垃圾回收器在回收的时候就可以往废弃的块里拷贝对象。每个块有相应的<strong>代数（generation count）</strong>来记录它是否还存活。通常，如果块在某处被引用，其代数会增加；垃圾回收器会定期进行完整的清理动作—大型对象仍然不会被复制（只是其代数会增加），内含小对象的那些快则被复制斌整理。</p><p><strong>自适应技术</strong>：Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低，就会切换到“标记-清扫”方式。同样，Java虚拟机会跟踪“标记-清扫”的效果，如果堆里面出现很多碎片，就会切换为“停止-复制”方式。可以给一个罗嗦的称呼：“自适应的、分代的、停止-复制、标记-清扫”式垃圾回收器。</p><h3 id="即时编译技术"><a href="#即时编译技术" class="headerlink" title="即时编译技术"></a>即时编译技术</h3><p>Java虚拟机有许多附加技术用以提升速度。尤其是与加载器操作有关的，被称为<strong>即时编译器技术（Just-In-Time，JIT）</strong>。</p><p>这种技术可以<strong>把程序全部或部分翻译成本地机器码（这本来是Java虚拟机的工作）</strong>，程序运行速度因此得到提升。</p><p>当需要装载某个类（通常是在为该类创建第一个对象时），编译器为找到其<code>.class</code>文件，然后将该类的字节码装入内存。此时有两种方案可供选择：</p><ul><li>一是让即时编译器编译所有代码。但存在以下两种缺陷：<ul><li>加载动作散落在整个程序生命周期内，累加起来花更多时间；</li><li>增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），将导致页面调度，从而降低程序速度</li></ul></li><li>二是<strong>惰性评估（lazy evaluation）</strong>，意思是即时编译器只在必要的时候才编译代码。这样从不会被执行的代码也许就压根不会被JIT所编译。新版JDK中的<code>Java HotSpot</code>技术采用了类似方法，<strong>代码每次被执行都会做一些优化，所以执行次数越多速度就越快</strong>。</li></ul><h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2><p>所有变量在使用前都应得到恰当的初始化。对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。唯一有点例外的是，<strong>类的每个基本类型数据成员保证都会得到一个初始值</strong>。</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>初始值</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>false</code></td></tr><tr><td><code>char</code></td><td>0</td></tr><tr><td><code>byte</code></td><td>0</td></tr><tr><td><code>short</code></td><td>0</td></tr><tr><td><code>int</code></td><td>0</td></tr><tr><td><code>long</code></td><td>0</td></tr><tr><td><code>float</code></td><td>0.0</td></tr><tr><td><code>double</code></td><td>0.0</td></tr><tr><td><code>reference</code></td><td><code>null</code></td></tr></tbody></table></div><h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><p>可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初值，这让编程变得更灵活。但需要注意：<strong>无法阻止自动初始化的进行，它将在构造器被调用前发生</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    test()&#123;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解读：变量<code>i</code>会先被初始化为0，再赋值为1。</p><h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>在类的内部，<strong>变量定义的先后顺序决定了初始化的顺序</strong>。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。</p><h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3><p><strong>无论创建多少个对象，静态数据都只占用一份存储区域</strong>。<code>static</code>关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准值；如果它是一个对象引用，那么它的默认初始值就是<code>null</code>。</p><p><strong>静态初始化只有在必要时刻才会进行，只有在第一个类对象被创建（或第一次访问静态数据）时候，它们才会被初始化</strong>。此后，静态对象不会再次被初始化，每次引用的都是同一个对象。</p><p>初始化的顺序是先静态对象，而后是“非静态”对象。</p><h3 id="显式的静态初始化"><a href="#显式的静态初始化" class="headerlink" title="显式的静态初始化"></a>显式的静态初始化</h3><p>Java允许将多个静态初始化动作组织成一个特殊的“静态子块”（也可称为“静态代码块”）。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Student student;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        student = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h3><p>Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mugs</span></span>&#123;</span><br><span class="line">    Mug mug1;</span><br><span class="line">    Mug mug2;</span><br><span class="line">    &#123;</span><br><span class="line">        mug1 = <span class="keyword">new</span> Mug();</span><br><span class="line">        mug2 = <span class="keyword">new</span> Mug();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种语法对于支持<strong>“匿名内部类”</strong>的初始化时必须的，但是它也使得你可以保证无论调用哪个显式构造器，某些操作都会发生。这个代码块也是会在调用构造器执行。</p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p><strong>数组是相同类型、用一个标识符名称封装到一起的一个对象序列或基本数据类型序列。</strong>数组是通过方括号下标操作符<code>[]</code>来定义和使用的。要定义一个数组，只需在类型名后加上一对空括号即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1;</span><br><span class="line"><span class="comment">// 实际上也可以将方括号放在变量名后</span></span><br><span class="line"><span class="keyword">int</span> a2[];</span><br><span class="line"><span class="comment">// 但是后面这种方式不利于识别是一个数组</span></span><br></pre></td></tr></table></figure><p>对于数组，你不能直接在引用上指定大小。为了给数组创建相应的存储空间，必须写初始化表达式。对于数组，初始化动作可以出现在代码的任何地方，但也可以用一种特殊的初始化表达式，它必须在创建数组的地方出现。这种特殊的初始化是由一对花括号<code>{}</code>括起来的值组成。在这种情况下，存储空间的分配（等价于使用<code>new</code>）将由编译器负责。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接给数组赋</span></span><br><span class="line"><span class="keyword">int</span>[] a1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 开辟一个大小为5的int数组</span></span><br><span class="line"><span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>所有数组（无论它们的元素是对象还是基本类型）都有一个固定成员—<code>length</code>，可以通过它获知数组内包含了多少元素，但不能对其修改。与C和C++类似，Java数组计数也是从第0个元素开始，所以能使用的最大下标数是<code>length-1</code>。一旦你访问下标越界，就会出现运行时错误（异常，<code>indexOfBoundException</code>）。</p><h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><p>JAVA SE5提供了一种方便的语法来创建对象并调用方法，以获得与C的<strong>可变参数列表（varages）</strong>一样的效果。这可以应用于参数个数或类型未知的场合。由于所有的类都直接或间接继承于<code>Object</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object... objects)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object object:objects)&#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    printArray(<span class="keyword">new</span> Integer(<span class="number">47</span>), <span class="keyword">new</span> Float(<span class="number">3.4</span>), <span class="keyword">new</span> Double(<span class="number">11.11</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印一个类只会出现类的名称以及后面紧接着一个@符号以及多个十六进制数字，因为默认行为（没有定义<code>toString()</code>方法）就是打印类的名字和对象的地址。</p><p>有了可变参数，就不用再显式地编写数组方法了，当你指定参数的时候，编译器实际上会为你去填充数组。获取的仍旧是一个数组。如果该参数列表中没有任何元素，那么转变成的数据的尺寸为0。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>在Java SE5中添加了一个看似很小的特性，即<code>enum</code>关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便的处理。在此之前，你需要创建一个静态常量集，但是这些枚举值并不会必然地将其自身的取值限制在这个常量集的范围之内，因此显得更有风险，且难使用。枚举的出现正是为了解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Spiciness&#123;</span><br><span class="line">    NOT,MILD,MEDIUM,HOT,FLAMING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码创建了一个名为<code>Spiciness</code>的枚举类型，它具有5个<strong>具名值</strong>。由于枚举类型的实例是常量，因此按照命名惯例都用大写字母表示。</p><p>当你创建<code>enum</code>时，编译器会自动添加一些有用的特性。例如，它会创建<code>toString()</code>方法，以便你可以很方便地显示某个<code>enum</code>实例的名字。编译器还会创建<code>ordinal()</code>方法，用来表示某个特定的<code>enum</code>常量的声明顺序；以及<code>static values()</code>方法，用来按照<code>enum</code>常量声明顺序，产生由这些常量值构成的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Spiciness s:Spiciness.values())&#123;</span><br><span class="line">            System.out.println(s + <span class="string">"："</span> + s.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* output:</span></span><br><span class="line"><span class="comment">* NOT:0</span></span><br><span class="line"><span class="comment">* MILD:1</span></span><br><span class="line"><span class="comment">* MEDIUM:2</span></span><br><span class="line"><span class="comment">* HOT:3</span></span><br><span class="line"><span class="comment">* FLAMING:4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>尽管<code>enum</code>看起来像是一种新的数据类型，但是这个关键字只是为<code>enum</code>生成对应类时，产生了某些编译器行为，因为你可以将<code>enum</code>当作一般的类来处理，只是具有某些特别的方法。</p></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/05-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/" title="05-初始化与清理" target="_blank" rel="external">https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/05-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/hengxincheung" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/hengxincheung" target="_blank"><span class="text-dark">hengxincheung</span><small class="ml-1x">码农</small></a></h3><div>Encode my life, Decode the future</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/06-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/" title="06-访问权限控制"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/04-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" title="04-控制执行流程"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>感谢您的支持，我会继续努力的!</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipay.jpg" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p></div><div role="tabpanel" class="tab-pane fade" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpay.jpg" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a></li><li role="presentation"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/hengxincheung" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/null" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/null" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/null" target="_blank" title="Behance" data-toggle="tooltip" data-placement="top"><i class="icon icon-behance"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright"><div class="publishby"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>!function(T){var N={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"};T.INSIGHT_CONFIG=N}(window)</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta="nick,mail,link";meta=meta.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"",appKey:"",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script><script>$(document).ready(function(){$("article img").not("[hidden]").not(".panel-body img").each(function(){var a=$(this),t=a.attr("alt"),n=a.parent("a");if(n.length<1){var e=this.getAttribute("src"),r=e.lastIndexOf("?");-1!=r&&(e=e.substring(0,r)),n=a.wrap('<a href="'+e+'"></a>').parent("a")}n.attr("data-fancybox","images"),t&&n.attr("data-caption",t)}),$().fancybox({selector:'[data-fancybox="images"]',hash:!1,loop:!1})})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html><!-- rebuild by neat -->