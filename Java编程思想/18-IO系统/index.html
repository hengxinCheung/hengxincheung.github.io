<!-- build time:Sun Jul 05 2020 22:21:17 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>18-IO系统 | hengxincheung&#39;s Blog</title><meta name="description" content="对程序语言的设计者来说，创建一个好的输入&#x2F;输出（I&#x2F;O）系统是一项艰难的任务。挑战来自于要涵盖所有的可能性。不仅存在各种IO源和想要与之通信的接收端（文件、控制台、网络链接等），而且还需要以多种的方式与它们进行通信（顺序、随机存取、缓冲、二进制、按字符、按行、按字等）。Java类库的设计者通过创建大量的类来解决这个问题（讽刺的是，Java IO设计初衷是为了避免过多的类）。自从Java 1.0版本"><meta property="og:type" content="article"><meta property="og:title" content="18-IO系统"><meta property="og:url" content="https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/18-IO%E7%B3%BB%E7%BB%9F/"><meta property="og:site_name" content="hengxincheung&#39;s blog"><meta property="og:description" content="对程序语言的设计者来说，创建一个好的输入&#x2F;输出（I&#x2F;O）系统是一项艰难的任务。挑战来自于要涵盖所有的可能性。不仅存在各种IO源和想要与之通信的接收端（文件、控制台、网络链接等），而且还需要以多种的方式与它们进行通信（顺序、随机存取、缓冲、二进制、按字符、按行、按字等）。Java类库的设计者通过创建大量的类来解决这个问题（讽刺的是，Java IO设计初衷是为了避免过多的类）。自从Java 1.0版本"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/hengxinCheung/ImageBed/master/images/20200627160117.png"><meta property="og:image" content="https://raw.githubusercontent.com/hengxinCheung/ImageBed/master/images/20200621161903.png"><meta property="article:published_time" content="2020-07-03T13:29:07.000Z"><meta property="article:modified_time" content="2020-07-03T13:31:24.106Z"><meta property="article:author" content="hengxincheung"><meta property="article:tag" content="Java"><meta property="article:tag" content="编程思想"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://raw.githubusercontent.com/hengxinCheung/ImageBed/master/images/20200627160117.png"><link rel="canonical" href="https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/18-IO%E7%B3%BB%E7%BB%9F/index.html"><link rel="alternate" href="/atom.xml" title="hengxincheung&#39;s blog" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link href="//cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css" rel="stylesheet"><link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.1"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/hengxincheung" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">hengxincheung</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">码农</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Guangzhou, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/hengxincheung" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/null" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/null" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/null" target="_blank" title="Behance" data-toggle="tooltip" data-placement="top"><i class="icon icon-behance"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎您，瓜子和茶都没有。</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">linux快速入门</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/numpy%E6%95%99%E7%A8%8B/">numpy教程</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">统计机器学习</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/Java/" style="font-size:14px">Java</a> <a href="/tags/RESTful/" style="font-size:13px">RESTful</a> <a href="/tags/git/" style="font-size:13px">git</a> <a href="/tags/linux/" style="font-size:13.5px">linux</a> <a href="/tags/numpy/" style="font-size:13.75px">numpy</a> <a href="/tags/python/" style="font-size:13.75px">python</a> <a href="/tags/web/" style="font-size:13.25px">web</a> <a href="/tags/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/" style="font-size:13px">权限系统</a> <a href="/tags/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/" style="font-size:13px">用户系统</a> <a href="/tags/%E7%99%BB%E5%BD%95/" style="font-size:13px">登录</a> <a href="/tags/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size:13px">统计机器学习</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/" style="font-size:14px">编程思想</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size:13px">设计模式</a> <a href="/tags/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/" style="font-size:13px">随机森林</a></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">统计机器学习</a></p><p class="item-title"><a href="/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/" class="title">01-统计学习方法概论</a></p><p class="item-date"><time datetime="2020-07-05T14:20:01.000Z" itemprop="datePublished">2020-07-05</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></p><p class="item-title"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/21-%E5%B9%B6%E5%8F%91/" class="title">21-并发</a></p><p class="item-date"><time datetime="2020-07-03T13:31:04.000Z" itemprop="datePublished">2020-07-03</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></p><p class="item-title"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/20-%E6%B3%A8%E8%A7%A3/" class="title">20-注解</a></p><p class="item-date"><time datetime="2020-07-03T13:30:32.000Z" itemprop="datePublished">2020-07-03</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></p><p class="item-title"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/19-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/" class="title">19-枚举类型</a></p><p class="item-date"><time datetime="2020-07-03T13:29:52.000Z" itemprop="datePublished">2020-07-03</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></p><p class="item-title"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/18-IO%E7%B3%BB%E7%BB%9F/" class="title">18-IO系统</a></p><p class="item-date"><time datetime="2020-07-03T13:29:07.000Z" itemprop="datePublished">2020-07-03</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#file-类"><span class="toc-number">1.</span> <span class="toc-text">File 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#目录列表器"><span class="toc-number">1.1.</span> <span class="toc-text">目录列表器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录实用工具"><span class="toc-number">1.2.</span> <span class="toc-text">目录实用工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录的检查及创建"><span class="toc-number">1.3.</span> <span class="toc-text">目录的检查及创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输入和输出"><span class="toc-number">2.</span> <span class="toc-text">输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inputstream-类型"><span class="toc-number">2.1.</span> <span class="toc-text">InputStream 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outputstream-类型"><span class="toc-number">2.2.</span> <span class="toc-text">OutputStream 类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加属性和有用的接口"><span class="toc-number">3.</span> <span class="toc-text">添加属性和有用的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过-filterinputstream-从-inputstream-中读取数据"><span class="toc-number">3.1.</span> <span class="toc-text">通过 FilterInputStream 从 InputStream 中读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过-filteroutputstream-向-outputstream-写入"><span class="toc-number">3.2.</span> <span class="toc-text">通过 FilterOutputStream 向 OutputStream 写入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reader-和-writer"><span class="toc-number">4.</span> <span class="toc-text">Reader 和 Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据的来源与去处"><span class="toc-number">4.1.</span> <span class="toc-text">数据的来源与去处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更改流的行为"><span class="toc-number">4.2.</span> <span class="toc-text">更改流的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#未发生变化的类"><span class="toc-number">4.3.</span> <span class="toc-text">未发生变化的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自我独立的类randomaccessfile"><span class="toc-number">5.</span> <span class="toc-text">自我独立的类：RandomAccessFile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io流的典型使用方式"><span class="toc-number">6.</span> <span class="toc-text">IO流的典型使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲输入文件"><span class="toc-number">6.1.</span> <span class="toc-text">缓冲输入文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从内存输入"><span class="toc-number">6.2.</span> <span class="toc-text">从内存输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#格式化的内存输入"><span class="toc-number">6.3.</span> <span class="toc-text">格式化的内存输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本的文件输出"><span class="toc-number">6.4.</span> <span class="toc-text">基本的文件输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储和恢复数据"><span class="toc-number">6.5.</span> <span class="toc-text">存储和恢复数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写随机访问文件"><span class="toc-number">6.6.</span> <span class="toc-text">读写随机访问文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件读写的实用工具"><span class="toc-number">7.</span> <span class="toc-text">文件读写的实用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#读取二进制文件"><span class="toc-number">7.1.</span> <span class="toc-text">读取二进制文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标准io"><span class="toc-number">8.</span> <span class="toc-text">标准IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从标准输入中读取"><span class="toc-number">8.1.</span> <span class="toc-text">从标准输入中读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将-systemout-转换成-printwriter"><span class="toc-number">8.2.</span> <span class="toc-text">将 System.out 转换成 PrintWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准io重定向"><span class="toc-number">8.3.</span> <span class="toc-text">标准IO重定向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程控制"><span class="toc-number">9.</span> <span class="toc-text">进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新io"><span class="toc-number">10.</span> <span class="toc-text">新IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#转换数据"><span class="toc-number">10.1.</span> <span class="toc-text">转换数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取基本类型"><span class="toc-number">10.2.</span> <span class="toc-text">获取基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#视图缓冲器"><span class="toc-number">10.3.</span> <span class="toc-text">视图缓冲器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用缓冲器操纵数据"><span class="toc-number">10.4.</span> <span class="toc-text">用缓冲器操纵数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲器的细节"><span class="toc-number">10.5.</span> <span class="toc-text">缓冲器的细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存映射文件"><span class="toc-number">10.6.</span> <span class="toc-text">内存映射文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件加锁"><span class="toc-number">10.7.</span> <span class="toc-text">文件加锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#压缩"><span class="toc-number">11.</span> <span class="toc-text">压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用gzip进行简单压缩"><span class="toc-number">11.1.</span> <span class="toc-text">用GZIP进行简单压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用zip进行多文件保存"><span class="toc-number">11.2.</span> <span class="toc-text">用Zip进行多文件保存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象序列化"><span class="toc-number">12.</span> <span class="toc-text">对象序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transient-关键字"><span class="toc-number">12.1.</span> <span class="toc-text">transient 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xml"><span class="toc-number">13.</span> <span class="toc-text">XML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#perferences"><span class="toc-number">14.</span> <span class="toc-text">Perferences</span></a></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-Java编程思想/18-IO系统" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">18-IO系统</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/18-IO%E7%B3%BB%E7%BB%9F/" class="article-date"><time datetime="2020-07-03T13:29:07.000Z" itemprop="datePublished">2020-07-03</time></a></span> <span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></span> <span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link" href="/tags/Java/" rel="tag">Java</a>, <a class="article-tag-link" href="/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/" rel="tag">编程思想</a></span> <span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></span> <span class="post-comment"><i class="icon icon-comment"></i> <a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/18-IO%E7%B3%BB%E7%BB%9F/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 12.2k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 47(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p><strong>对程序语言的设计者来说，创建一个好的输入/输出（I/O）系统是一项艰难的任务。</strong></p><p>挑战来自于要涵盖所有的可能性。不仅存在各种IO源和想要与之通信的接收端（文件、控制台、网络链接等），而且还需要以多种的方式与它们进行通信（顺序、随机存取、缓冲、二进制、按字符、按行、按字等）。</p><p>Java类库的设计者通过创建大量的类来解决这个问题（讽刺的是，Java IO设计初衷是为了避免过多的类）。自从Java 1.0版本以来，在原来面向字节的类中添加了面向字符和基于Unicode的类。在JDK 1.4中，添加了 <code>nio</code> 类，为了改进性能和功能。</p><h2 id="file-类"><a class="markdownIt-Anchor" href="#file-类"></a> <code>File</code> 类</h2><p><code>File</code> （文件）类这个名字有一定的误导性。我们可能认为它指代的是文件，实际上却并非如此。它既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。如果它指的是一个文件集，我们可以对此集合调用 <code>list()</code> 方法，这个方法会返回一个字符数组。所以如果我们想取得不同的目录列表，只需要再创建一个不同的 <code>File</code> 对象就可以了。实际上，FilePath(文件路径)对这个类来说是个更好的名字。</p><h3 id="目录列表器"><a class="markdownIt-Anchor" href="#目录列表器"></a> 目录列表器</h3><p>假设想查看一个目录列表，可以用两种方法来使用 <code>File</code> 对象。如果调用不带参数的 <code>list()</code> 方法，便可以获得此 <code>File</code> 对象包含的全部列表。然而，如果我们想获得一个受限列表，例如，得到所有扩展名为 <code>.java</code> 的文件。我们就要用到 <strong>“目录过滤器”</strong>，这个类会告诉我们怎样显示符合条件的 <code>File</code> 对象。</p><p>下面是一个示例，通过使用 <code>java.utils.Arrays.sort()</code> 和 <code>String.CASE_INSENSITIVE.ORDERComparator</code>，可以很容易地对结果进行排序（按字母排序）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File path = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        String[] list;</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            list = path.list();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list = path.list(<span class="keyword">new</span> DirFilter(args[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        <span class="keyword">for</span>(String dirItem : list) &#123;</span><br><span class="line">            System.out.println(dirItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DirFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DirFilter</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">            pattern = Pattern.compile(regex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>DirFilter</code> 类实现了 <code>FilenameFilter</code> 接口，这个接口十分简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建这个类的目的在于把 <code>accept()</code> 方法提供给 <code>list()</code> 使用，使 <code>list()</code> 可以回调 <code>accept()</code>，进而决定哪些文件包含在列表中。因此，这种结构也常常称为 <strong>回调</strong>。<code>accept()</code> 方法必须接收一个代表某个特定文件所在目录的 <code>File</code> 对象，以及包含了特定文件名的一个 <code>String</code>。记住一点，<code>list()</code> 方法会为此目录对象下的每个文件名调用 <code>accept()</code>，来判断该文件是否包含在内，判断结果由 <code>accept()</code> 返回的布尔值表示。</p><p>这个例子很适合用一个匿名内部类进行改写。首先创建一个 <code>filter()</code> 方法，它会返回一个指向 <code>FilenameFilter</code> 的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FilenameFilter <span class="title">filter</span><span class="params">(<span class="keyword">final</span> String regex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个匿名内部类 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            <span class="keyword">private</span> Pattern pattern = Pattern.compile(regex);</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File path = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        String[] list;</span><br><span class="line">        <span class="keyword">if</span>(args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            list = path.list();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list = path.list(filter(args[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        <span class="keyword">for</span>(String dirItem : list) &#123;</span><br><span class="line">            System.out.println(dirItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：传向 <code>filter()</code> 的参数必须是 <code>final</code> 的。这在匿名内部类中是必须的，这样它才能够使用该类范围之外的对象。</p><h3 id="目录实用工具"><a class="markdownIt-Anchor" href="#目录实用工具"></a> 目录实用工具</h3><p>程序设计中一项常见的任务就是在文件集上执行操作，这些文件要么在本地目录中，要么遍布于整个目录树。下面的实用工具类就可以通过实用 <code>local()</code> 方法产生由本地目录中的文件构成的 <code>File</code> 对象数组，或者通过使用 <code>find()</code> 方法产生给定目录下的由整个目录树中所有文件构成的 <code>List&lt;File&gt;</code>。<code>File</code> 对象比文件名更有用，因为包含更多的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * local() 方法用以寻找当前文件夹内所有的符合规则的文件对象</span></span><br><span class="line"><span class="comment">     * find() 方法用以寻找当前文件夹下(包括子文件夹内)所有符合规则的文件对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> File[] local(File dir, Pattern pattern) &#123;</span><br><span class="line">        <span class="keyword">return</span> dir.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pattern.matcher(<span class="keyword">new</span> File(name).getName()).matches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> File[] local(String path, String regex) &#123;</span><br><span class="line">        <span class="keyword">return</span> local(<span class="keyword">new</span> File(path), Pattern.compile(regex));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">find</span><span class="params">(String start, String regex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(<span class="keyword">new</span> File(start), Pattern.compile(regex));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">find</span><span class="params">(File start, Pattern pattern)</span> </span>&#123;</span><br><span class="line">        List&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;File&gt;();</span><br><span class="line">        <span class="keyword">for</span>(File file: local(start, pattern)) &#123;</span><br><span class="line">            files.add(file);</span><br><span class="line">            <span class="keyword">if</span>(file.isDirectory()) &#123;</span><br><span class="line">                files.addAll(find(file, pattern));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> files;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;File&gt; files = Directory.find(<span class="string">"."</span>, <span class="string">".*"</span>);</span><br><span class="line">        <span class="keyword">for</span>(File file : files) &#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>local()</code> 方法实用被称为 <code>listFile()</code> 的 <code>File.list()</code> 的变体来产生文件对象数组。如果需要 <code>List</code> 而不是数组，你可以使用 <code>Arrays.asList()</code> 自己对结果进行转换。</p><p><code>find()</code> 方法递归地遍历目录，并在每次递归中都收集更多的信息。</p><h3 id="目录的检查及创建"><a class="markdownIt-Anchor" href="#目录的检查及创建"></a> 目录的检查及创建</h3><p><code>File</code> 类不仅仅值代表存在的文件或目录。也可以用 <code>File</code> 对象来创建新的目录或尚不存在的整个目录路径。还可以查看文件的特性，如大小，最后修改日期，读写等，检查该对象对应是一个文件还是一个目录，并可以删除文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line"><span class="comment">// 文件是否存在</span></span><br><span class="line">file.exists();</span><br><span class="line"><span class="comment">// 获取绝对路径</span></span><br><span class="line">file.getAbsolutePath();</span><br><span class="line"><span class="comment">// 是否可读</span></span><br><span class="line">file.canRead();</span><br><span class="line"><span class="comment">// 是否可写</span></span><br><span class="line">file.canWrite();</span><br><span class="line"><span class="comment">// 文件名</span></span><br><span class="line">file.getName();</span><br><span class="line"><span class="comment">// 文件的父目录</span></span><br><span class="line">file.getParent();</span><br><span class="line"><span class="comment">// 文件的相对路径</span></span><br><span class="line">file.getPath();</span><br><span class="line"><span class="comment">// 文件的大小</span></span><br><span class="line">file.length();</span><br><span class="line"><span class="comment">// 文件上次修改的日期</span></span><br><span class="line">file.lastModified();</span><br><span class="line"><span class="comment">// 文件是否为一个目录</span></span><br><span class="line">file.isDirectory();</span><br><span class="line"><span class="comment">// 删除文件</span></span><br><span class="line">file.delete();</span><br></pre></td></tr></table></figure><h2 id="输入和输出"><a class="markdownIt-Anchor" href="#输入和输出"></a> 输入和输出</h2><p>编程语言的IO类库中常实用 <strong>流</strong> 这个抽象概念，它代表任何有能力产出数据的数据源对象或者是有能力接收数据的接收端对象。<strong>“流”</strong> 这个概念屏蔽了实际的IO设备中处理数据的细节。</p><p>Java类库中的IO类分成输入和输出两部分。通过继承，任何自 <code>InputStream</code> 或 <code>Reader</code> 派生而来的类都有名为 <code>read()</code> 的基本方法，用于读取单个字节或字节数组。同样，任何自 <code>OutputStream</code> 或 <code>Writer</code> 派生而来的类都含有 <code>write()</code> 基本方法，用于写单个字节或者字节数组。但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以实用它们，以便提供更有用的接口。因此，我们很少实用单一的类来创建流对象，而是通过 <strong>叠加多个对象</strong> 来提供所期望的功能（这是装饰器设计模式，也叫包装模式）。</p><p>实际上，Java中“流”类库让人迷惑的主要原因就在于：创建单一的结果流，却需要创建多个对象。</p><h3 id="inputstream-类型"><a class="markdownIt-Anchor" href="#inputstream-类型"></a> <code>InputStream</code> 类型</h3><p><code>InputStream</code> 的作用是用来表示那些从不同数据源产生输入的类，这些数据源包括：</p><ul><li>字节数组；</li><li><code>String</code> 对象；</li><li>文件；</li><li>管道：从一端输入，从另一端输出；</li><li>一个由其他种类的流组成的序列，以便我们可以将它们收集合并到一个流内；</li><li>其他数据源，如Internet连接等。</li></ul><p>每一种数据源都有相应的 <code>InputStream</code> 子类。另外，<code>FilterInputStream</code> 也属于一种 <code>InputStream</code>，为“装饰器”（decorator）类提供基类。其中，“装饰器”类可以把属性或有用的接口与输入流连接在一起。</p><table><thead><tr><th>类</th><th>功能</th><th>参数与如何实用</th></tr></thead><tbody><tr><td><code>ByteArrayInputStream</code></td><td>允许将内存的缓冲区当作 <code>InputStream</code> 使用</td><td>缓冲区，字节将从中取出。作为一种数据源：将其与 <code>FilterInputStream</code> 对象相连以提供有用接口</td></tr><tr><td><code>StringBufferInputStream</code></td><td>将 <code>String</code> 转为 <code>InputStream</code></td><td>字符串。底层实现实际使用 <code>StringBuffer</code> 作为一种数据源：将其与 <code>FilterInputStream</code> 对象相连以提供有用接口</td></tr><tr><td><code>FileInputStream</code></td><td>用于从文件中读取信息</td><td>字符串，表示文件名、文件或 <code>FileDescriptor</code> 对象。作为一种数据源：将其与 <code>FilterInputStream</code> 对象相连以提供有用的接口。</td></tr><tr><td><code>PipedInputStream</code></td><td>产生用于写入相关 <code>PipedOutputStream</code> 的数据。实现“管道化”概念。</td><td><code>PipedOutputStream</code>。作为多线程中数据源：将其与 <code>FilterInputStream</code> 对象相连以提供有用的接口。</td></tr><tr><td><code>SequenceInputStream</code></td><td>将两个或多个 <code>InputStream</code> 对象转换成单一 <code>InputStream</code></td><td>两个 <code>InputStream</code> 对象或一个容纳 <code>InputStream</code> 对象的容器 <code>Enumeration</code>。作为一种数据源：将其与 <code>FilterInputStream</code> 对象相连以提供有用的接口。</td></tr><tr><td><code>FilterInputStream</code></td><td>抽象类，作为“装饰器”的接口。其中，“装饰器”类为其他 <code>InputStream</code> 类提供有用功能。</td><td></td></tr></tbody></table><h3 id="outputstream-类型"><a class="markdownIt-Anchor" href="#outputstream-类型"></a> <code>OutputStream</code> 类型</h3><p>该类别的类决定了输出所要去往的目标：字节数组（但不是 <code>String</code>，不过你可以由此产生字节数组），文件或管道。</p><p>另外，<code>FilterOutputStream</code> 为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来。</p><table><thead><tr><th>类</th><th>功能</th><th>参数与如何使用</th></tr></thead><tbody><tr><td><code>ByteArrayOutputStream</code></td><td>在内存中创建缓冲区。所有送往“流”的数据都要放置在此缓冲区。</td><td>缓冲区初始化尺寸（可选的）。用于指定数据的目的地：将其与 <code>FilterOutputStream</code> 对象相连以提供有用接口。</td></tr><tr><td><code>FileOutputStream</code></td><td>用于将信息写至文件。</td><td>字符串，表示文件名、文件或 <code>FileDescriptor</code>。指定数据的目的地：将其与 <code>FilterOutputStream</code> 对象相连以提供有用接口。</td></tr><tr><td><code>PipedOutputStream</code></td><td>任何写入其中的信息都会自动作为相关 <code>PipedInputStream</code> 的输出。实现“管道化”概念。</td><td><code>PipedInputStream</code>。指定用于多线程的数据的目的地：将其与 <code>FilterOutputStream</code> 对象相连以提供有用接口。</td></tr><tr><td><code>FilterOutputStream</code></td><td>抽象类，作为“装饰器”接口。其中，“装饰器”为其他 <code>OutputStream</code> 提供有用功能。</td><td></td></tr></tbody></table><h2 id="添加属性和有用的接口"><a class="markdownIt-Anchor" href="#添加属性和有用的接口"></a> 添加属性和有用的接口</h2><p>Java IO类库需要多种不同功能的组合，这正是使用装饰器模式的理由所在。这也是存在 <code>filter</code> （过滤器）类的原因所在，抽象类 <code>filter</code> 是所有装饰器类的基类。装饰器类必须具有和它所装饰的对象相同的接口，但它也可以扩展接口，而这种情况是少数。</p><p>装饰器模式也有一个缺点：在编写程序时，它给我们提供了相当多的灵活性（因为我们可以很容易地混合和匹配属性），但是它同时也增加了代码的复杂性。Java IO类库操作不便的原因在于：我们必须创建许多类–核心IO类型加上所有的装饰器，才能得到我们所希望的单个IO对象。</p><p><code>FilterInputStream</code> 和 <code>FilterOutputStream</code> 是用来提供装饰器类接口以控制特定输入流（<code>InputStream</code>）和输出流（<code>OutputStream</code>）的两个类。它们的名字不是很直观。这两个类分别自IO类库的基类 <code>InputStream</code> 和 <code>OutputStream</code> 派生而来。这两个类是装饰器的必要条件（以便能为所有正在被修饰的对象提供通用接口）。</p><h3 id="通过-filterinputstream-从-inputstream-中读取数据"><a class="markdownIt-Anchor" href="#通过-filterinputstream-从-inputstream-中读取数据"></a> 通过 <code>FilterInputStream</code> 从 <code>InputStream</code> 中读取数据</h3><p><code>FilterInputStream</code> 类能够完成两件完全不同的事情。其中，<code>DataInputStream</code> 允许我们读取不同的基本类型以及 <code>String</code> 对象，所有的方法都以 <code>read</code> 开头，例如：<code>readByte()</code>, <code>readFloat()</code> 等等。搭配相应的 <code>DataOutputStream</code>，我们就可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方。</p><p>其他 <code>FilterInputStream</code> 类则在内部修改 <code>InputStream</code> 的行为方式：是否缓冲，是否保留它所读过的行（允许我们查询行数或设置行数），以及是否把单一字符推回输入流等等。最后两个类看起来更像是为了创建一个编译器，因此我们在一般编程不会使用它们。</p><p>我们几乎每次都要对输入进行缓冲，不管我们连接的是什么IO设备。所以，IO类库把无缓冲输入（而不是缓冲输入）作为特殊情况。</p><p><code>FilterInputStream</code> 的类型及功能如下表所示：</p><table><thead><tr><th>类</th><th>功能</th><th>参数以及如何使用</th></tr></thead><tbody><tr><td><code>DataInputStream</code></td><td>与 <code>DataOutputStream</code> 搭配使用，因此我们可以按照可移植方式从流读取基本类型。</td><td><code>InputStream</code>。包含用于读取基本类型的所有接口。</td></tr><tr><td><code>BufferedInputStream</code></td><td>使用它可以防止每次读取都进行实际的写操作。代表“使用缓冲区”。</td><td><code>InputStream</code>，可以指定缓冲区大小（可选）。本质上不提供接口，只不过是向进程中添加缓冲区必须的。与接口对象搭配。</td></tr><tr><td><code>LineNumberInputStream</code></td><td>跟踪输入流中的行号；可调用 <code>getLineNumber()</code> 和 <code>setLineNumber</code>。</td><td><code>InputStream</code>。仅仅增加了行号，因此可能要与接口对象搭配使用。</td></tr><tr><td><code>PushbackInputStream</code></td><td>具有能弹出一个字节的缓冲区。因此可以将读到的最后一个字符返回退。</td><td><code>InputStream</code>。通常作为编译器的扫描器，之所以包含在内是因为Java编译器的需要，我们可能永远不会用到。</td></tr></tbody></table><h3 id="通过-filteroutputstream-向-outputstream-写入"><a class="markdownIt-Anchor" href="#通过-filteroutputstream-向-outputstream-写入"></a> 通过 <code>FilterOutputStream</code> 向 <code>OutputStream</code> 写入</h3><p>与 <code>DataInputStream</code> 对应的是 <code>DataOutputStream</code>，它可以将各种基本类型和 <code>String</code> 对象格式化输入到“流”中。这样一来，任何机器上的任何 <code>DataInputStream</code> 能够读取它们。所有的方法都以 <code>write</code> 开头，例如 <code>writeByte()</code>, <code>writeFloat()</code> 等等。</p><p><code>PrintStream</code> 最初的目的便是为了以可视化格式打印所有的基本数据类型以及 <code>String</code> 对象。这和 <code>DataOutputStream</code> 不同，后者的目的是为了将数据置入“流”中，使 <code>DataInputStream</code> 可移植地重构它们。</p><p><code>PrintStream</code> 内有两个重要方法：<code>print()</code> 和 <code>println()</code>。对它们进行重载，以便可以打印出各种数据类型。它们之间的差异是，后者在操作完毕后添加一个换行符。</p><p><code>PrintStream</code> 可能有些问题，因为它捕捉了所有的 <code>IOException</code>。另外，<code>PrintStream</code> 也未完全国际化，不能以平台无关的方式处理换行动作。</p><p><code>BufferedOutputStream</code> 是一个修改过的 <code>OutputStream</code>，它对数据流使用缓冲技术。因此当每次向流写入时，不必每次都进行实际的物理写动作。所以在输出时，我们可能更经常使用它。</p><table><thead><tr><th>类</th><th>功能</th><th>参数以及如何使用</th></tr></thead><tbody><tr><td><code>DataOutputStream</code></td><td>与 <code>DataInputStream</code> 搭配使用，因此我们可以按照可移植方式向流写入基本类型。</td><td><code>OutputStream</code>。包含用于写入基本类型的所有接口。</td></tr><tr><td><code>PrintStream</code></td><td>用于产生格式化输出。其中 <code>DataOutputStream</code> 处理数据的存储，<code>PrintStream</code> 处理数据的显示。</td><td><code>OutputStream</code>，可以用 <code>boolean</code> 值指示是否在每次换行时清空缓冲区。应该是对 <code>OutputStream</code> 对象的 <code>final</code> 封装，可能会经常用到它。</td></tr><tr><td><code>BufferedOutputStream</code></td><td>使用它以避免每次发送数据时都要进行实际的写操作，代表“使用缓冲区”。可以调用 <code>flush()</code> 方法清空缓冲区。</td><td><code>OutputStream</code>,可以指定缓冲区大小（可选）。本质上不提供接口，只不过是向进程中添加缓冲区必须的。与接口对象搭配。</td></tr></tbody></table><h2 id="reader-和-writer"><a class="markdownIt-Anchor" href="#reader-和-writer"></a> <code>Reader</code> 和 <code>Writer</code></h2><p>Java 1.1对基本类型的IO流类库进行了重大的修改。<code>Reader</code> 和 <code>Writer</code> 不是用以替代 <code>InputStream</code> 和 <code>OutputStream</code> 的类。尽管一些原始的“流”类库不再被使用，但是 <code>InputStream</code> 和 <code>OutputStream</code> 在以面向字节形式的IO中仍可提供极有价值的功能。<code>Reader</code> 和 <code>Writer</code> 则提供兼容 Unicode 与面向字符的IO功能。另外：</p><ul><li>Java 1.1向 <code>InputStream</code> 和 <code>OutputStream</code> 的继承层次结构中添加了一些新类，所以显然这两个类是不会取代的。</li><li>有时我们必须把来自于“字节”层次结构中的类与“字符”层次结构中的类结合起来使用。为了实现这个目的，要用到 <strong>“适配器”（adapter）</strong> 类：<code>InputStreamReader</code> 可以把 <code>InputStream</code> 转换为 <code>Reader</code>，而 <code>OutputStreamWriter</code> 可以把 <code>OutputStream</code> 转换为 <code>Writer</code>。</li></ul><p>设计 <code>Reader</code> 和 <code>Writer</code> 继承层次结构主要为了国际化。老的IO流继承层次结构仅支持8位字节流，并不能很好的处理16位的 Unicode 字符。由于 Unicode 用于字符国际化（Java本身的 <code>char</code> 也是16位的 Unicode），所以添加 <code>Reader</code> 和 <code>Writer</code> 继承层次结构就是为了所有的IO操作中都支持 Unicode。另外，新类库的设计使得它的操作比旧类库要快。</p><h3 id="数据的来源与去处"><a class="markdownIt-Anchor" href="#数据的来源与去处"></a> 数据的来源与去处</h3><p>几乎所有原始的Java IO流类都有相应的 <code>Reader</code> 和 <code>Writer</code> 类来提供天然的 Unicode 操作。然而在某些场合，面向字节的流类库才是正确的解决方案。特别是，<code>java.util.zip</code> 类库就是面向字节的而不是面向字符的。因此，最明智的做法就是尽量使用 <code>Reader</code> 和 <code>Writer</code>，一旦程序无法编译，就转使用流类库。</p><p>下面展示两个继承层次结构中，信息的来源和去处。</p><table><thead><tr><th>来源于去处：Java 1.0类</th><th>相应的Java 1.1类</th></tr></thead><tbody><tr><td><code>InputStream</code></td><td><code>Reader</code>：适配器 <code>InputStreamReader</code></td></tr><tr><td><code>OutputStream</code></td><td><code>Writer</code>：适配器 <code>OutputStreamWriter</code></td></tr><tr><td><code>FileInputStream</code></td><td><code>FileReader</code></td></tr><tr><td><code>FileOutputStraem</code></td><td><code>FileWriter</code></td></tr><tr><td><code>StringBufferInputStream</code>（已弃用）</td><td><code>StringReader</code></td></tr><tr><td>无相应的类</td><td><code>StringWriter</code></td></tr><tr><td><code>ByteArrayInputStream</code></td><td><code>CharArrayReader</code></td></tr><tr><td><code>ByteArrayOutputStram</code></td><td><code>CharArrayWriter</code></td></tr><tr><td><code>PipedInputStream</code></td><td><code>PipedReader</code></td></tr><tr><td><code>PipedOutputStream</code></td><td><code>PipedWriter</code></td></tr></tbody></table><h3 id="更改流的行为"><a class="markdownIt-Anchor" href="#更改流的行为"></a> 更改流的行为</h3><p>对于 <code>InputStream</code> 和 <code>OutputStream</code> 来说，我们会使用 <code>FilterInputStream</code> 和 <code>FilterOutputStream</code> 的装饰器子类来修改“流”以满足特殊需要。<code>Reader</code> 和 <code>Writer</code> 的类继承层次结构继续沿用相同的思想，但是并不完全相同。</p><table><thead><tr><th>过滤器：Java 1.0类</th><th>相应的Java 1.1类</th></tr></thead><tbody><tr><td><code>FilterInputStream</code></td><td><code>FilterReader</code></td></tr><tr><td><code>FilterOutputStream</code></td><td><code>FilterWriter</code>（抽象类，没有子类）</td></tr><tr><td><code>BufferedInputStream</code></td><td><code>BufferedReader</code>（也有 <code>readLine()</code>）</td></tr><tr><td><code>BufferedOutputStream</code></td><td><code>BufferedWriter</code></td></tr><tr><td><code>DataInputStream</code></td><td>使用 <code>DataInputStream</code></td></tr><tr><td><code>PrintStream</code></td><td><code>PrintWriter</code></td></tr><tr><td><code>LineNumberInputStream</code>（已弃用）</td><td><code>LineNumberReader</code></td></tr><tr><td><code>StreamTokenizer</code></td><td><code>StreamTokenizer</code>(使用接受 <code>Reader</code> 的构造器)</td></tr><tr><td><code>PushbackInputStream</code></td><td><code>PushbackReader</code></td></tr></tbody></table><p>有一点很清楚：无论何时使用 <code>readLine()</code>，都不应该使用 <code>DataInputStream</code>，而应该使用 <code>BufferedReader</code>。除了这一点，<code>DataInputStream</code> 仍是IO类库的首选成员。</p><p>为了更容易地过渡到使用 <code>PrintWriter</code>，它提供了一个既能接受 <code>Writer</code> 对象有能接受任何 <code>OutputStream</code> 对象的构造器。<code>PrintWriter</code> 的格式化接口实际上与 <code>PrintStream</code> 相同。</p><h3 id="未发生变化的类"><a class="markdownIt-Anchor" href="#未发生变化的类"></a> 未发生变化的类</h3><p>有一些类在Java 1.0和Java 1.1之间则未做改变：</p><ul><li><code>DataOutputStream</code></li><li><code>File</code></li><li><code>RandomAccessFile</code></li><li><code>SequenceInputStream</code></li></ul><p>特别是 <code>DataOutputStream</code>，在使用时没任何变化。因此如果想以“可传输的”格式存储和检索数据，可以使用IO流继承层次结构。</p><h2 id="自我独立的类randomaccessfile"><a class="markdownIt-Anchor" href="#自我独立的类randomaccessfile"></a> 自我独立的类：<code>RandomAccessFile</code></h2><p><code>RandomAccessFile</code> 适用于大小已知的记录组成的文件，所以我们可以使用 <code>seek()</code> 将记录从一处转移到另一处，然后读取或修改记录。文件中记录的大小不一定都相同，只要我们能够确定那些记录有多大以及它们在文件中的位置即可。</p><p>它是一个完全独立的类，从头开始编写其所有的方法。这么做是因为其拥有和别的IO类型本质不同的行为，因为我们可以在一个文件内向前或向后移动。在任何情况下，它都是自我独立的，直接从 <code>Object</code> 派生而来。</p><p>其中方法 <code>getFilePointer()</code> 用于查找当前所处的文件位置，<code>seek()</code> 用于在文件内移至新的位置，<code>length()</code> 用于判断文件的最大尺寸。另外，其构造器还需要第二个参数（和C中的 <code>fopen()</code> 一样）用来指示我们只是“随机读”（r）还是“既读又写”（rw）。它并不支持只写文件。</p><p>只有 <code>RandomAccessFile</code> 支持搜寻方法，并且只适用于文件。<code>BufferedInputStream</code> 却能允许标注（<code>mark()</code>）位置（其值存储与内部某个简单变量）和重新设定位置（<code>reset()</code>），但这些功能都不是非常有用。</p><h2 id="io流的典型使用方式"><a class="markdownIt-Anchor" href="#io流的典型使用方式"></a> IO流的典型使用方式</h2><p>尽管可以通过不同的方式组合IO流类，但我们可能也只用到其中的几种组合。下面的例子可以作为典型的IO用法的基本参考。</p><h3 id="缓冲输入文件"><a class="markdownIt-Anchor" href="#缓冲输入文件"></a> 缓冲输入文件</h3><p>如果想要打开一个文件用于字符输入，可以使用以 <code>String</code> 对象或 <code>File</code> 对象作为文件名的 <code>FileInputReader</code>。为了提供速度，我们希望对那个文件进行缓冲，那么我们将所产生的引用传给一个 <code>BufferedREader</code> 构造器。由于 <code>BufferedREader</code> 也提供 <code>readLine()</code> 方法，所以这是我们最终对象和进行读取的接口。当 <code>readLine()</code> 返回 <code>null</code> 时，就到达了文件的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">        String s;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>((s = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(s + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        System.out.println(read(<span class="string">"BufferedInputFIle.java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串 <code>sb</code> 用来累积文件的全部内容（包括必须添加的换行符，因为 <code>readLine()</code>已将它们删掉 ）。最后，调用 <code>close()</code> 关闭文件。</p><h3 id="从内存输入"><a class="markdownIt-Anchor" href="#从内存输入"></a> 从内存输入</h3><p>下面的示例中，从 <code>BufferedInputFile.read()</code> 读如的 <code>String</code> 结果被用来创一个 <code>StringReader</code>。然后调用 <code>read()</code> 每次读取一个字符，并把它发送到控制台。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        StringReader in = <span class="keyword">new</span> StringReaer(BufferedInputFile.read(</span><br><span class="line">            <span class="string">"MemoryInput.java"</span>));</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>read()</code> 是以 <code>int</code> 形式返回下一字节，因此必须类型转换为 <code>char</code> 才能正确打印。</p><h3 id="格式化的内存输入"><a class="markdownIt-Anchor" href="#格式化的内存输入"></a> 格式化的内存输入</h3><p>要读取格式化数据，可以使用 <code>DataInputStream</code>，它是一个面向字节的IO类。因此我们必须使用 <code>InputStream</code> 而不是 <code>Reader</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattedMemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"TestEOF.java"</span>)));</span><br><span class="line">            <span class="keyword">while</span>(in.available() != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)in.readByte());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(EOFException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"End of stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>available()</code> 的工作方式会随着所读取的媒介类型的不同而有所不同：字面意思就是在没有阻塞的情况下所能读取的字节数。对于文件，这意味着整个文件。但是对于不同类型的流，可能就不是这样的，因此要谨慎使用。</p><p>我们也可以通过捕获异常来检测输入的末尾。</p><h3 id="基本的文件输出"><a class="markdownIt-Anchor" href="#基本的文件输出"></a> 基本的文件输出</h3><p><code>FileWriter</code> 对象可以向文件写入数据。首先，创建一个与指定文件连接的 <code>FileWriter</code>。实际上，我们通常会用 <code>BufferedWriter</code> 将其包装起来用以缓冲输出。在本例中，它被装饰成了 <code>PrintWriter</code>，以提供格式化机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFileOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"BasicFileOutput.out"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">"BasicFIleOutput.java"</span>)));</span><br><span class="line">        PrintWriter pw = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">            <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file)));</span><br><span class="line">        <span class="keyword">int</span> lineCount = <span class="number">1</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pw.println(lineCount++ + <span class="string">": "</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不显式调用 <code>close()</code>，就会发现缓冲区内容不会被刷新清空，那么文本也就不完整。</p><p>Java SE5在 <code>PrintWriter</code> 中添加了一个辅助构造器，使得你不必在每次希望创建文本文件并向其中写入时，都去执行所有的装饰工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String filename = <span class="string">"test.java"</span></span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(filename);</span><br></pre></td></tr></table></figure><h3 id="存储和恢复数据"><a class="markdownIt-Anchor" href="#存储和恢复数据"></a> 存储和恢复数据</h3><p><code>PrintWriter</code> 可以对数据进行格式化，以便人们的阅读。但是为了输出可供另一个“流”恢复的数据，我们需要用 <code>DataOutputStream</code> 写入数据，并用 <code>DataInputStream</code> 恢复数据。当然，这些流可以是任何形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoringAndRecoveringData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">            <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Data.txt"</span>)));</span><br><span class="line">        out.writeDouble(<span class="number">3.14159</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"That was pi!"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        </span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">            <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Data.txt"</span>)));</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们使用 <code>DataOutputStream</code> 写入数据，Java保证我们可以使用 <code>DataInputStream</code> 准确地读取数据，无论读和写的数据的平台多么的不同。</p><p>当我们使用 <code>DataOutputStream</code> 时，写字符串并且让 <code>DataInputStream</code> 能够恢复它的唯一可靠的做法就是使用 UTF-8 编码。UTF-8 是一种多字节格式，其编码长度根据实际使用的字符集会有所变化。UTF-8 将 ASCII 字符白鞍马成单一字节的形式，而非 ASCII 字符则编码成两到三个字节的形式。另外，字符串的长度存储在 UTF-8 字符串的前两个字节中。但是 <code>writeUTF()</code> 和 <code>readUTF()</code> 使用的是适合于Java的UTF-8变体，因此我们用一个非Java程序读取用 <code>writeUTF()</code> 所写的字符串，编序编写一些特殊代码才能正确读取字符串。</p><p>注意，对象序列化和XML可能是更容易的存储和读取复杂数据结构的方式。</p><h3 id="读写随机访问文件"><a class="markdownIt-Anchor" href="#读写随机访问文件"></a> 读写随机访问文件</h3><p>使用 <code>RandomAccessFile</code> 时，你必须知道文件排版，这样才能正确操作它。其拥有读取基本类型和UTF-8字符串的各种具体方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandomAccessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"rtest.dat"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Value"</span> + i + <span class="string">": "</span> + rf.readDouble());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(rf.readUTF());</span><br><span class="line">        rf.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++) &#123;</span><br><span class="line">            rf.writeDouble(i*<span class="number">1.414</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rf.writeUTF(<span class="string">"End of file!"</span>);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">        </span><br><span class="line">        rf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">        rf.seek(<span class="number">5</span>*<span class="number">8</span>);</span><br><span class="line">        System.out.println(rf.readDouble());</span><br><span class="line">        rf.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>double</code> 总是8字节长，所以使用 <code>seek(5*8)</code> 查找第5个双精度值。</p><h2 id="文件读写的实用工具"><a class="markdownIt-Anchor" href="#文件读写的实用工具"></a> 文件读写的实用工具</h2><p>一个常见的程序化人物就是读取文件到内存，修改，然后再写出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFile</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取文件内的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(</span><br><span class="line">                <span class="keyword">new</span> File(filename).getAbsoluteFile()));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String s;</span><br><span class="line">                <span class="keyword">while</span>((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sb.append(s);</span><br><span class="line">                    sb.append(<span class="string">"\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向文件写入内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String filename, String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintWriter pw = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                <span class="keyword">new</span> File(filename).getAbsoluteFile());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pw.print(text);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                pw.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取二进制文件"><a class="markdownIt-Anchor" href="#读取二进制文件"></a> 读取二进制文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] read(File bFile) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(bFile));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[bis.available()];</span><br><span class="line">            bis.read(data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>available()</code> 方法被用来产生恰当的数组尺寸，并且 <code>read()</code> 方法的特定的重载版本填充了这个数组。</p><h2 id="标准io"><a class="markdownIt-Anchor" href="#标准io"></a> 标准IO</h2><p>标准IO这个术语参考的是Unix中“程序所使用的单一信息流”这个概念。程序的所有输入都可以来自于 <strong>标准输入</strong>，它的所有输出也都可以发送到 <strong>标准输出</strong>，以及所有的错误信息都可以发送到 <strong>标准错误</strong>。标准IO的意义在于：我们可以很容易地把程序串联起来，一个程序的标准输出可以称为另一程序的标准输入。</p><h3 id="从标准输入中读取"><a class="markdownIt-Anchor" href="#从标准输入中读取"></a> 从标准输入中读取</h3><p>按照标准IO模型，Java提供了 <code>System.in</code>，<code>System.out</code> 和 <code>System.err</code>。<code>System.out</code> 已经实现被包装成了 <code>PrintStream</code> 对象。<code>System.err</code> 同样也是 <code>PrintStream</code>，但 <code>System.in</code> 却是一个没有被包装国的未经加工的 <code>InputStream</code>。这意味着我们可以立即实用 <code>System.out</code> 和 <code>System.err</code>，但是在读取 <code>System.in</code> 之前必须对其进行包装。</p><p>通常我们会用 <code>readLine()</code> 一次一行地读取输入，为此，我们将 <code>System.in</code> 包装成 <code>BufferedReader</code> 来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader stdin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s = stdin.readLine()) != <span class="keyword">null</span> &amp;&amp; s.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将-systemout-转换成-printwriter"><a class="markdownIt-Anchor" href="#将-systemout-转换成-printwriter"></a> 将 <code>System.out</code> 转换成 <code>PrintWriter</code></h3><p><code>System.out</code> 是一个 <code>PrintStream</code>，而 <code>PrintStream</code> 是一个 <code>OutputStream</code>。<code>PrintWriter</code> 有一个可以接受 <code>OutputStream</code> 作为参数的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(System.out, <span class="keyword">true</span>);</span><br><span class="line">pw.println(<span class="string">"Hello world!"</span>);</span><br></pre></td></tr></table></figure><p>将第二个参数设为 <code>true</code>，以便开启自动清空功能。否则，你可能看不到输出。</p><h3 id="标准io重定向"><a class="markdownIt-Anchor" href="#标准io重定向"></a> 标准IO重定向</h3><p>Java的 <code>System</code> 类提供了一简单的静态方法调用，以允许我们对标准输入，输出和错误IO流进行重定向：</p><ul><li><code>setIn(InputStream)</code></li><li><code>setOut(PrintStream)</code></li><li><code>setErr(printStream)</code></li></ul><p>如果我们突然开始在显示器创建大量输出，而这些输出滚动太快以至于无法阅读时，重定向输出就显得极为有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redirecting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintStream console = System.out;</span><br><span class="line">        <span class="function">BufferedInputStream in new <span class="title">BufferedInputStream</span><span class="params">(new FileInputStream(<span class="string">"Redirecting.java"</span>)</span>)</span>;</span><br><span class="line">        PrintStream out = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.out"</span>)));</span><br><span class="line">        System.setIn(in);</span><br><span class="line">        System.setOut(out);</span><br><span class="line">        System.setErr(out);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        SYstem.setOut(console);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序将标准输入附接到文件上，并将标准输出和标准错误重定向到另一个文件。注意，它在程序开头存储了对最初的 <code>System.in</code> 对象的引用，并且在结尾处将系统输出恢复到了该对象上。</p><p>IO重定向操纵的是字节流，而不是字符流。</p><h2 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h2><p>你经常会需要在Java内部执行其他操作系统的程序，并且要控制这些程序的输入和输出。</p><p>一项常见的人物是运行程序，并将产生的输出发送到控制台。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OSExecute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">command</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> err = <span class="keyword">false</span>;</span><br><span class="line">        Process process = <span class="keyword">new</span> ProcessBuilder(command.split(<span class="string">" "</span>)).start();</span><br><span class="line">        BufferedReader results = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream()));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s = results.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        BufferedReader errors = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getErrorStream()));</span><br><span class="line">        <span class="keyword">while</span>((s = errors.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.err.println(s);</span><br><span class="line">            err = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.lang.ProcessBuilder</code> 构造器要求命令作为一个 <code>String</code> 对象序列而被传递，然后所产生的 <code>ProcessBuilder</code> 对象被启动。</p><h2 id="新io"><a class="markdownIt-Anchor" href="#新io"></a> 新IO</h2><p>JDK 1.4的 <code>java.nio.*</code> 包中引入了新的Java IO类库，其目的在于提高速度。实际上，旧的IO包已经使用 <code>nio</code> 重新实现国，以便充分利用这种速度提高。因此，即使我们不显式地用 <code>nio</code> 编写代码，也能从中收益。</p><p>速度的提高来自于所使用的结构更接近于操作系统执行IO的方式：<strong>通道</strong> 和 <strong>缓冲器</strong>。我们并不直接和通道交互，我们只是和缓冲器交互，并把缓冲器派送到通道。通道要么从缓冲器获得数据，要么向缓冲器发送数据。</p><p>唯一直接与通道交互的缓冲器是 <code>ByteBuffer</code>，这是可以存储未加工字节的缓冲器。<code>java.nio.ByteBuffer</code> 是相当基础的类：通过告知分配多少存储空间来创建一个 <code>ByteBuffer</code> 对象，并且还有一个方法选择集，用于以原始的字节形式或基本数据类型输出和读取数据。但是，没办法输出或读取对象，即使是字符串对象也不行。</p><p>旧IO类库有三个类被修改了，用以产生 <code>FileChannel</code>。这三个被修改的类是 <code>FileInputStream</code>,<code>FileOutputStream</code>以及用于读写的 <code>RandomAccessFile</code>。注意这些是字节操纵流，与低层的 <code>nio</code> 性质一致。<code>Reader</code> 和 <code>Writer</code> 这种字符模式类不能用于产生通道，但是 <code>java.nio.channels.Channels</code> 类提供了实用方法，用以在通道中产生 <code>Reader</code> 和 <code>Writer</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 写文件</span></span><br><span class="line">        FileChannel fc = <span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(Some text).getBytes());</span><br><span class="line">        fc.close();</span><br><span class="line">        </span><br><span class="line">        fc = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">        fc.position(fc.size()); <span class="comment">// 移动到末尾</span></span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some more"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读文件</span></span><br><span class="line">        fc = <span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>).getChannel();</span><br><span class="line">        ByteBuffer buff = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        <span class="keyword">while</span>(buff.hasRemaining()) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)buff.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getChannel()</code> 将会产生一个 <code>FileChannel</code>。通道是一种相当基础的东西：可以向它传送用于读写的 <code>ByteBuffer</code>，并且可以锁定文件的某些区域用于独占式访问。</p><p>将字节存放于 <code>ByteBuffer</code> 的方法之一是：实用一个 <code>put</code> 方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值。也可以实用 <code>wrap()</code> 方法将已存在的字节数组包装到 <code>ByteBuffer</code> 中。一旦如此，就不再复制底层的数组，而是把它作为所产生的 <code>ByteBuffer</code> 的存储器，称之为数组支持的 <code>ByteBuffer</code>。</p><p>对于只读访问，我们必须显示地实用静态的 <code>allocate()</code> 方法来分配 <code>ByteBuffer</code>。<code>nio</code> 的目标是快速移动大量数据，因此 <code>ByteBuffer</code> 的大小就显得尤为重要。通常需要实际运行应用程序来找到最佳尺寸。</p><p>为了达到更高的速度，方法就是实用 <code>allocateDirect()</code> 而不是 <code>allocate()</code>，以产生一个与操作系统有更高耦合性的“直接”缓冲器。但是，这种分配的开支会更大。</p><p>一旦调用 <code>read()</code> 来告知 <code>FileChannel</code> 向 <code>ByteBuffer</code> 存储字节，就必须调用缓冲器上的 <code>flip()</code>，让它做好让别人读取字节的准备。如果我们打算使用缓冲器执行进一步的 <code>read()</code> 操作，也必须地调用 <code>clear()</code> 来为每个 <code>read()</code> 做好准备。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCopy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length != <span class="number">2</span>) System.exit(<span class="number">1</span>);</span><br><span class="line">        FileChannel in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel();</span><br><span class="line">        FileChannel out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">while</span>(in.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();  <span class="comment">// 准备好写</span></span><br><span class="line">            out.write(buffer);</span><br><span class="line">            buffer.clear(); <span class="comment">// 准备好读</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次 <code>read()</code> 操作之后，就会将数据输入到缓冲器中，<code>flip()</code> 则是准备缓冲器以便它的信息可以由 <code>write()</code> 提取。<code>write()</code> 操作之后，信息仍在缓冲器中，接着 <code>clear()</code> 操作则对所有的内部指针重新安排，以便缓冲器在另一个 <code>read()</code> 操作期间能够做好接受数据的准备。</p><p>特殊方法 <code>transferTo()</code> 和 <code>transferFrom()</code> 允许我们将一个通道和另一个通道直接相连：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length != <span class="number">2</span>) System.exit(<span class="number">1</span>);</span><br><span class="line">        FileChannel in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel();</span><br><span class="line">        FileChannel out = <span class="keyword">new</span> FileInputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        in.transferTo(<span class="number">0</span>, in.size(), out);</span><br><span class="line">        <span class="comment">// or </span></span><br><span class="line">        <span class="comment">// out.transferFrom(in, 0, in.size());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换数据"><a class="markdownIt-Anchor" href="#转换数据"></a> 转换数据</h3><p><code>java.nio.CharBuffer</code> 这个类的 <code>toString()</code> 方法是这样定义的：返回一个包含缓冲器中所有字符的字符串。<code>ByteBuffer</code> 可以看作是具有 <code>asCharBuffer()</code> 方法的 <code>CharBuffer</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferToText</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringp[] args)</span> </span>&#123;</span><br><span class="line">        FileChannel fc = <span class="keyword">new</span> FileInputStream(<span class="string">"data2.txt"</span>).getChannel();</span><br><span class="line">        ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        fc.flip();</span><br><span class="line">        <span class="comment">// 对字节数组解码</span></span><br><span class="line">        System.out.println(Charset.forName(<span class="string">"UTF-8"</span>).decode(buff));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取基本类型"><a class="markdownIt-Anchor" href="#获取基本类型"></a> 获取基本类型</h3><p>尽管 <code>ByteBuffer</code> 只能保存字节类型的数据，但是它具有可以从其所容纳的字节中产生出各种不同基本类型值的方法。</p><p>插入基本类型数据的最简单的方式是：利用 <code>asCharBuffer()</code>，<code>asShortBuffer()</code> 等获得该缓冲器上的视图，然后使用试图的 <code>put()</code> 方法。注意，使用 <code>ShortBuffer</code> 时候需要进行类型转换。</p><h3 id="视图缓冲器"><a class="markdownIt-Anchor" href="#视图缓冲器"></a> 视图缓冲器</h3><p><strong>视图缓冲器（view buffer）</strong> 可以让我们通过某个特定的基本数据类型的视窗查看其底层的 <code>ByteBuffer</code>。<code>ByteBuffer</code> 依然是实际存储数据的地方，支持着前面的视图，因此，对视图的任何修改都会映射成为对 <code>ByteBuffer</code>中数据的修改。视图还允许我们从 <code>ByteBuffer</code> 一次一个地或者成批地读取基本类型值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        IntBuffer ib = buffer.asIntBuffer();</span><br><span class="line">        ib.put(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>, <span class="number">42</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">143</span>, <span class="number">811</span>, <span class="number">1016</span>&#125;);</span><br><span class="line">        System.out.println(ib.get(<span class="number">3</span>));</span><br><span class="line">        ib.put(<span class="number">3</span>, <span class="number">1811</span>);</span><br><span class="line">        ib.flip();</span><br><span class="line">        <span class="keyword">while</span>(ib.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = ib.get();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦底层的 <code>ByteBuffer</code> 通过视图缓冲器填满了整数或其他基本类型时，就可以直接被写到通道中。</p><p>不同的机器可能会使用不同的字节排序方法来存储数据。<strong>“big endian”(高位优先)</strong> 将最重要的字节存放在地址最低的存储单元。而　<strong>“little endian”(低位优先)</strong>　则是将最终要的字节放在地址最高的存储单元。当存储量大于一个字节时，像　<code>int</code>, <code>float</code> 等，就要考虑字节的顺序问题。<code>ByteBuffer</code> 是以高位优先的形式存储数据的，并且数据在网上传送时也常常使用高位优先的形式。我们可以使用带有参数　<code>ByteOrder.BIG_ENDIAN</code> 或　<code>ByteOrder.LITTLE_ENDIAN</code> 的　<code>order()</code> 方法改变　<code>ByteBuffer</code>　的字节排序方式。</p><p><img src="https://raw.githubusercontent.com/hengxinCheung/ImageBed/master/images/20200627160117.png" alt=""></p><p>如果我们以　<code>short</code> 形式读取数据，得到的数字是97(二进制形式为：00000000 01100001)。但是如果更改为低位优先的形式，得到数字却是24832(二进制形式为：01100001 00000000)。</p><p><code>ByteBuffer</code>　有足够的空间，以存储作为外部缓冲器的　<code>charArray</code> 中所有的字节，因此可以调用　<code>array()</code> 方法显示视图底层的字节。<code>array()</code> 方法是可选的，并且我们只能对由数组支持的缓冲器调用此方法。否则，将会抛出　<code>UnsupportedOperationException</code>。</p><h3 id="用缓冲器操纵数据"><a class="markdownIt-Anchor" href="#用缓冲器操纵数据"></a> 用缓冲器操纵数据</h3><p><img src="https://raw.githubusercontent.com/hengxinCheung/ImageBed/master/images/20200621161903.png" alt=""></p><p>如果想把一个字节数组写到文件中去，那么就应该使用　<code>ByteBuffer.wrap()</code> 方法把字节数组包装起来，然后用　<code>getChannel()</code> 方法在 <code>FileOutputStream</code> 上打开一个他哦哦那个到，接着将来自于　<code>ByteBuffer</code> 的数据写到通道中。</p><p>注意：<code>ByteBuffer</code>　是将数据移进移出通道的唯一方式，并且我们只能创建一个独立的基本类型缓冲器，或者使用　<code>as</code> 方法从其获得。</p><h3 id="缓冲器的细节"><a class="markdownIt-Anchor" href="#缓冲器的细节"></a> 缓冲器的细节</h3><p><code>Buffer</code> 由数据和可以高效地访问及操作这些数据的四个索引组成：</p><ul><li>mark，标记</li><li>position，位置</li><li>limit，界限</li><li>capacity，容量</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>capacity()</code></td><td>返回缓冲区容量</td></tr><tr><td><code>clear()</code></td><td>清空缓冲区，将position设置为0，limit设置为容量</td></tr><tr><td><code>flip()</code></td><td>将limit设置为position，position设置为0.此方方用于准备从缓冲区读取已经写入的数据</td></tr><tr><td><code>limit()</code></td><td>返回limit值</td></tr><tr><td><code>litmit(int lim)</code></td><td>设置limit值</td></tr><tr><td><code>mark()</code></td><td>将makr设置为position</td></tr><tr><td><code>position()</code></td><td>返回position值</td></tr><tr><td><code>position(int pos)</code></td><td>设置position值</td></tr><tr><td><code>remaining()</code></td><td>返回（limit - position）</td></tr><tr><td><code>hasRemaining()</code></td><td>若有介于position和limit之间的元素，则返回 <code>true</code></td></tr></tbody></table><p>在缓冲器中插入和提取数据的方法会更新这些索引，用于反映所发生的变化。</p><h3 id="内存映射文件"><a class="markdownIt-Anchor" href="#内存映射文件"></a> 内存映射文件</h3><p>内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件。有了内存映射文件，我们就可以假定整个文件都放在内存中，而且可以完全把它当作非常大的数组来访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeMappedFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> length = <span class="number">0x8FFFFFF</span>;  <span class="comment">// 128MB</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MappedByteBuffer out = <span class="keyword">new</span> RandomAccessFIle(<span class="string">"test.data"</span>, <span class="string">"rw"</span>).getChannel()</span><br><span class="line">            .map(FIleChannel.MapMode.READ_WRITE, <span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">            out.put((<span class="keyword">byte</span>)<span class="string">'x'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length/<span class="number">2</span>;i&lt;length/<span class="number">2</span>+<span class="number">6</span>;i++) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)out.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得该文件上的通道后，然后调用 <code>map()</code> 方法以产生 <code>MappedByteBuffer</code>，这是一种特殊类型的直接缓冲器。注意我们必须指定映射文件的初始文值和映射区域的长度，这意味着我们可以映射某个大文件的较小的部分。</p><p><code>MappedByteBuffer</code> 由 <code>ByteBuffer</code> 继承而来，因此它具有 <code>ByteBuffer</code> 的所有方法。</p><p>映射文件访问往往可以更加显著地加快速度，但是建立映射文件的花费很大，这个需要根据具体的场景选择使用。</p><h3 id="文件加锁"><a class="markdownIt-Anchor" href="#文件加锁"></a> 文件加锁</h3><p>JDK 1.4引入了文件加锁机制，它允许我们同步访问某个作为共享资源的文件。文件锁对其他的操作系统进程是可见的，因为Java的文件加锁直接映射到了本地操作系统的加锁工具。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLocking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"file.txt"</span>);</span><br><span class="line">        FileLock fileLock = fos.getChannel().tryLock(); <span class="comment">// 尝试对文件上锁</span></span><br><span class="line">        <span class="keyword">if</span>(fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"locked file"</span>);</span><br><span class="line">            fileLock.release(); <span class="comment">// 释放文件锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对 <code>FileChannel</code> 调用 <code>tryLock()</code> 或 <code>lock()</code> 方法就可以获得整个文件的 <code>FileLock</code>。<code>SocketChannel</code>, <code>DatagramChannel</code> 和 <code>ServerSocketChannel</code> 不需要加锁，因为它们是从单进程实体继承而来，我们通常不在两个进程之间共享socket。<code>tryLock()</code> 方法是非阻塞式的，它设法获取锁，但是如果不能获得，它将直接从方法调用返回。<code>lock()</code> 则是阻塞式的，它要阻塞进程直至锁可以获得，或调用 <code>lock()</code> 的线程中断，或调用 <code>lock()</code> 的通道关闭。使用 <code>FileLock.release()</code> 可以释放锁。</p><p>也可以使用下面的方法对文件的一部分上锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tryLock(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">lock(<span class="keyword">long</span> position, <span class="keyword">long</span> size, booean shared);</span><br></pre></td></tr></table></figure><p>其中，加锁的区域由size-position决定。第三个参数指定是否是共享锁。例如，可以在数据库的数据文件中使用这种技术，只对需要影响的地方加锁，因此多个用户可以同时访问到它。</p><p>对独占锁或者共享锁的支持必须由底层的操作系统提供。如果操作系统不支持共享锁并为每一个请求都创建一个锁，那么它就会使用独占锁。锁的类型（共享或独占）可以通过 <code>FileLock.isShared()</code> 进行查询。</p><h2 id="压缩"><a class="markdownIt-Anchor" href="#压缩"></a> 压缩</h2><p>Java IO类库中的类支持读写压缩格式的数据流。这些类属于 <code>InputStream</code> 和 <code>OutputStream</code> 继承层次结构的一部分。这样做是因为压缩类库按字节方式而不是按字符方式处理。</p><table><thead><tr><th>压缩类</th><th>功能</th></tr></thead><tbody><tr><td><code>CheckedInputStream</code></td><td><code>GetCheckSum()</code> 为任何 <code>InputStream</code> 产生校验和（不仅是解压缩）</td></tr><tr><td><code>CheckedOutputStream</code></td><td><code>GetCheckSum()</code> 为任何 <code>OutputStream</code> 产生校验和（不仅是压缩）</td></tr><tr><td><code>DeflaterOutputStream</code></td><td>压缩类的基类</td></tr><tr><td><code>ZipOutputStream</code></td><td>用于将数据压缩成Zip文件格式</td></tr><tr><td><code>GZIPOutputStream</code></td><td>用于将数据压缩成GZIP文件格式</td></tr><tr><td><code>InflaterInputStream</code></td><td>解压缩类的基类</td></tr><tr><td><code>ZipInputStream</code></td><td>用于解压缩Zip文件格式的数据</td></tr><tr><td><code>GZIPInputStream</code></td><td>用于解压缩GZIP文件格式的数据</td></tr></tbody></table><h3 id="用gzip进行简单压缩"><a class="markdownIt-Anchor" href="#用gzip进行简单压缩"></a> 用GZIP进行简单压缩</h3><p>GZIP接口非常简单，因此如果我门只想对单个数据流（而不是一系列互异数据）进行压缩，那么它可能是比较适合的选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPcompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"data.txt"</span>));</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">           <span class="keyword">new</span> GZIPOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"data.gz"</span>)));</span><br><span class="line">       <span class="keyword">int</span> c;</span><br><span class="line">       <span class="keyword">while</span>((c = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">           out.write(c);</span><br><span class="line">       &#125;</span><br><span class="line">       in.close();</span><br><span class="line">       out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩类的使用非常直观，直接将输出流封装成 <code>GZIPOutputStream</code> 或 <code>ZipOutputStream</code>，并将输入流封装成 <code>GZIPInputStream</code> 或 <code>ZipInputStream</code> 即可。其他全部操作就是通常的IO读写。</p><h3 id="用zip进行多文件保存"><a class="markdownIt-Anchor" href="#用zip进行多文件保存"></a> 用Zip进行多文件保存</h3><p>支持Zip格式的Java库更加全面。利用该库可以方便地保存多个文件，它甚至有一个独立的类，使得读取Zip文件更加方便。这个类库使用的是标准Zip格式，所以能于当前那些可通过因特网下载的压缩工具很好地写作。</p><p>使用 <code>Checksum</code> 类来计算和校验文件的校验和的方法。一共有两种 <code>Checksum</code> 类型：<code>Adler32</code> （快一些）和 <code>CRC32</code> (慢一些，但更准确)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipCompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.zip"</span>);</span><br><span class="line">        CheckedOutputStream csum = <span class="keyword">new</span> CheckedOutputStream(f, <span class="keyword">new</span> Adler32());</span><br><span class="line">        ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(csum);</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(zos);</span><br><span class="line">        zos.setComment(<span class="string">"A test of Java Zipping"</span>);</span><br><span class="line">        <span class="keyword">for</span>(String arg: args) &#123;</span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(arg));</span><br><span class="line">            zos.putNextEntry(<span class="keyword">new</span> ZipEntry(arg));</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">while</span>((c = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每一个要加入压缩档案的文件，都必须调用 <code>putNextEntry()</code>，并将其传递给一个 <code>ZipEntry</code> 对象。<code>ZipEntry</code> 对象包含了一个功能很广泛的接口，允许你获取和设置Zip文件内该特定项上所有可利用的数据：名字、压缩的和未压缩的文件大小、日期、CRC校验和、额外字段数据、注释、压缩方法以及它是否是一个目录入口等等。然而，尽管Zip格式提供了设置密码的方法，但Java的Zip类库并不提供这方面的支持。</p><p>为了解压缩文件，<code>ZipInputStream</code> 提供一个 <code>getNextEntry()</code> 方法返回下一个 <code>ZipEntry</code>（如果存在的话）。解压缩文件有一个更简便的方法，利用 <code>ZipFile</code> 对象读取文件。该对象有一个 <code>entries()</code> 方法用来向 <code>ZipEntries</code> 返回一个 <code>Enumeration</code> （枚举）。</p><h2 id="对象序列化"><a class="markdownIt-Anchor" href="#对象序列化"></a> 对象序列化</h2><p>当你创建对象，只要你需要，它就会一直存在，但是程序终止时，它不会继续存在。如果对象能够在程序不运行的情况下仍能存在并保存其信息，那将非常有用。这样，在下次运行程序时，该对象将被重建，并且拥有的信息与程序上次运行时所有的信息相同。当然，你可以通过将信息写入文件或数据库来达到相同的效果。但如如果能够将一个对象声明为“持久性”的，并为我们处理掉所有细节，那将会非常方便。</p><p>Java的对象序列化将那些实现了 <code>Serializable</code> 接口的对象转换为一个字节序列，并能够在以后将这个字节序列完全恢复为原有的对象。这一过程甚至可通过网络进行，这意味着序列化机制能够自动弥补不同操作系统之间的差异。</p><p>对象的序列化非常有趣，因为利用它可以实现 <strong>轻量级持久性（lightweight persistence）</strong>。通过将一个序列化对象写入磁盘，然后在重新调用程序时恢复该对象，就能够实现持久性的效果。</p><p>对象序列化主要为了支持两种主要特性。一是Java的 <strong>远程方法调用（Remote Method Invocatrion， RMI）</strong> ，它使存活于其他计算机上的对象使用起来就像存活于本机上一样。当向远程对象发送信息时，需要通过对象序列化来传输参数和返回值。 再者，对JavaBean来说，对象的序列化也是必须的。</p><p>只要对象实现了 <code>Serializable</code> 接口（该接口仅是一个标记接口，不包括任何方法），对象的序列化处理就会非常简单。</p><p>要序列化一个对象，首先要创建某些 <code>OutputStream</code> 对象，然后将其封装在一个 <code>ObjectOutputStream</code> 对象内。这时，只需调用 <code>writeObject()</code> 方法即可将对象序列化，并将其发送给 <code>OutputStream</code>。要恢复一个对象，需要将一个 <code>InputStream</code> 封装在 <code>ObjectInputStream</code> 内，然后调用 <code>readObject()</code>。我们获得的是一个 <code>Object</code> 引用，必须向下转型才能直接设置它们。</p><p>对象序列化特别聪明的一个地方是它不仅保存了对象的全景图，而且能追踪对象内所包含的所有引用，并保存那些对象；接着又能对对象内包含的每个这样的引用进行追踪；依次类推。这种情况被称为“对象网”，单个对象可与之建立连接。</p><p>Java的对象序列似乎找不出什么缺点，所以请尽量不要自己动手，让它用优化的算法自动维护整个对象网。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Class Data implements Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="keyword">this</span>.n = n&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"n: "</span> + n;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">            <span class="keyword">new</span> FileOutputStream(<span class="string">"data.out"</span>));</span><br><span class="line">        out.writeObject(data);</span><br><span class="line">        out.close();</span><br><span class="line">        </span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(<span class="string">"data.out"</span>));</span><br><span class="line">        Data recoverData = (Data)in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        </span><br><span class="line">        System.out.println(recoverData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transient-关键字"><a class="markdownIt-Anchor" href="#transient-关键字"></a> <code>transient</code> 关键字</h3><p>当我们对序列化进行控制时，可能某个特定子对象不想让Java的序列化机制自动保存与恢复。可以使用 <code>transient</code> (瞬时)关键字逐个字段地关闭序列化。</p><h2 id="xml"><a class="markdownIt-Anchor" href="#xml"></a> XML</h2><p>一种更具互操作性的解决方案是将数据转化为XML格式，这可以使其被各种各样的平台和语言使用。</p><p>因为XML十分流行，所以用它来编程时的各种选择不胜枚举，包括随JDK发布的 <code>javax.xml.*</code> 类库。你也可以使用开源的XOM类库，因为它看起来最简单，同时也是最直观的用Java产生和修改XML的方式。另外XOM还强调了XML正确性。</p><h2 id="perferences"><a class="markdownIt-Anchor" href="#perferences"></a> Perferences</h2><p>Preferences API与对象序列化相比，前者与对象持久性更密切，因为它可以自动存储和读取信息。不过，它只能用于小的、受限的数据集合–我们只能存储基本类型和字符串，并且每个字符串的存储长度不能超过8K。顾名思义，Preferences API用于存储和读取用户的偏好（preferences）以及程序配置项的设置。</p><p>Preferences是一个键-值集合（类似映射），存储在一个节点层次结构中。尽管节点层次结构可用来创建更为复杂的结构，但通常是创建以你的类名命名的单一节点，然后将信息存储于其中。</p></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/18-IO%E7%B3%BB%E7%BB%9F/" title="18-IO系统" target="_blank" rel="external">https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/18-IO%E7%B3%BB%E7%BB%9F/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/hengxincheung" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/hengxincheung" target="_blank"><span class="text-dark">hengxincheung</span><small class="ml-1x">码农</small></a></h3><div>Encode my life, Decode the future</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/19-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/" title="19-枚举类型"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/17-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/" title="17-容器深入研究"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>感谢您的支持，我会继续努力的!</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipay.jpg" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p></div><div role="tabpanel" class="tab-pane fade" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpay.jpg" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">扫码打赏，你说多少就多少</p><p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a></li><li role="presentation"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/hengxincheung" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/null" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/null" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/null" target="_blank" title="Behance" data-toggle="tooltip" data-placement="top"><i class="icon icon-behance"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright"><div class="publishby"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>!function(T){var N={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"};T.INSIGHT_CONFIG=N}(window)</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta="nick,mail,link";meta=meta.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"",appKey:"",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script><script>$(document).ready(function(){$("article img").not("[hidden]").not(".panel-body img").each(function(){var a=$(this),t=a.attr("alt"),n=a.parent("a");if(n.length<1){var e=this.getAttribute("src"),r=e.lastIndexOf("?");-1!=r&&(e=e.substring(0,r)),n=a.wrap('<a href="'+e+'"></a>').parent("a")}n.attr("data-fancybox","images"),t&&n.attr("data-caption",t)}),$().fancybox({selector:'[data-fancybox="images"]',hash:!1,loop:!1})})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html><!-- rebuild by neat -->