{"meta":{"title":"hengxincheung's blog","subtitle":"","description":"","author":"hengxincheung","url":"https://hengxincheung.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2020-05-25T10:19:05.369Z","updated":"2020-05-25T10:19:05.369Z","comments":false,"path":"categories/index.html","permalink":"https://hengxincheung.github.io/categories/","excerpt":"","text":""},{"title":"个人简介","date":"2020-05-25T10:44:05.334Z","updated":"2020-05-25T10:44:05.334Z","comments":false,"path":"about/index.html","permalink":"https://hengxincheung.github.io/about/","excerpt":"","text":"联系方式移动电话：15626487308电子邮箱：hengxincheung@qq.com 教育背景时间学校专业学历2015-09 至 2019-06华南农业大学信息与计算科学本科2019-09 至 今电子科技大学软件工程硕士主修课程：数学分析、高等代数、离散数学、概率论、数值计算、常微分方程、组合优化、随机过程与排队论算法设计与分析、操作系统、Web开发、数据结构、数据挖掘、信息安全、Unix操作系统内核高级计算机结构、软件架构模型与设计、统计机器学习、网络计算模式、网络编程 项目经验修正 UWB 定位飘移算法研究人体检测与人体行为识别研究 技能评价具有良好的英语文本阅读能力以及书面写作；数学基础扎实，熟练掌握数学分析、数值计算、高等代数等，了解机器学习、深度学习，可以进行独立的数据挖掘和分析工作；熟练 C、Java、Python 等编程语言；熟悉常用的数据结构及算法、设计模式；掌握后台 Spring、Spring MVC、MyBatis、Hibernate 、Struts 等框架，前端 HTML\\CSS、JavaScript、Ajax、JQuery、Vue 等。 荣誉奖励美国大学生数学建模竞赛 H 奖（二等奖）、全国大学生数学建模竞赛三等奖；校级 ACM 竞赛专业组三等奖；校二等奖学金、校级三等奖学金；优秀志愿者、优秀团干部、优秀班委等。 自我评价思维严谨，有较强的学习和适应能力。工作主动，有责任心、执行力和抗压性，对代码有偏执地完美的追求，有着良好的规范代码编写习惯。热爱互联网行业，热爱编程开发，对互联网发展有敏锐触觉和十二分激情。"},{"title":"标签","date":"2020-05-25T10:19:35.595Z","updated":"2020-05-25T10:19:35.595Z","comments":true,"path":"tags/index.html","permalink":"https://hengxincheung.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"15-IO","slug":"numpy教程/15-IO","date":"2020-05-25T16:37:46.000Z","updated":"2020-05-25T16:39:35.354Z","comments":true,"path":"numpy教程/15-IO/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/15-IO/","excerpt":"","text":"Numpy 可以读写磁盘上的文本数据或二进制数据。NumPy 为ndarray对象引入了一个简单的文件格式：npy。npy文件用于存储重建ndarray所需的数据、图形、dtype 和其他信息。常用的 IO 函数有：load()和save()函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中。savze()函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npz的文件中。loadtxt()和savetxt()函数处理正常的文本文件(.txt等) numpy.save()和numpy.load()numpy.save()函数将数组保存到以.npy为扩展名的文件中。在这里我们可以使用load()函数来读取数据。1234567891011numpy.save(file, arr, allow_pickle=True, fix_imports=True)# file：要保存的文件，扩展名为.npy，如果文件路径末尾没有扩展名.npy，该扩展名会被自动加上# arr: 要保存的数组# allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python中的pickle用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化# fix_imports: 可选，为了方便Pyhton2中读取Python3保存的数据a = np.array([1,2,3,4,5]) # 保存到 outfile.npy 文件上np.save('outfile.npy',a)b = np.load('outfile.npy') np.savez()numpy.savez()函数将多个数组保存到以npz为扩展名的文件中。123456789101112131415161718numpy.savez(file, *args, **kwds)# file：要保存的文件，扩展名为.npz，如果文件路径末尾没有扩展名.npz，该扩展名会被自动加上# args: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为arr_0, arr_1, …。# kwds: 要保存的数组使用关键字名称import numpy as np a = np.array([[1,2,3],[4,5,6]])b = np.arange(0, 1.0, 0.1)c = np.sin(b)# c 使用了关键字参数 sin_arraynp.savez(\"out.npz\", a, b, sin_array = c)r = np.load(\"out.npz\") print(r.files) # 查看各个数组名称print(r[\"arr_0\"]) # 数组 aprint(r[\"arr_1\"]) # 数组 bprint(r[\"sin_array\"]) # 数组 c savetxt()和loadtxt()savetxt()函数是以简单的文本文件格式存储数据，对应的使用loadtxt()函数来获取数据。123456789np.loadtxt(FILENAME, dtype=int, delimiter=' ')np.savetxt(FILENAME, a, fmt=\"%d\", delimiter=\",\")# 参数delimiter可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等import numpy as np a=np.arange(0,10,0.5).reshape(4,-1)np.savetxt(\"out.txt\", a, fmt=\"%d\", delimiter=\",\") # 改为保存为整数，以逗号分隔b = np.loadtxt(\"out.txt\", dtype=int, delimiter=\",\") # load时也要指定为逗号分隔","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"14-线性代数","slug":"numpy教程/14-线性代数","date":"2020-05-25T16:37:14.000Z","updated":"2020-05-25T16:39:31.819Z","comments":true,"path":"numpy教程/14-线性代数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/14-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","excerpt":"","text":"NumPy 提供了线性代数函数库linalg，该库包含了线性代数所需的所有功能，可以看看下面的说明：函数描述dot两个数组的点积，即元素对应相乘vdot两个向量的点积inner两个数组的内积matmul两个数组的矩阵积determinant数组的行列式solve求解线性矩阵方程inv计算矩阵的乘法逆矩阵","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"13-矩阵库","slug":"numpy教程/13-矩阵库","date":"2020-05-25T16:36:15.000Z","updated":"2020-05-25T16:39:28.436Z","comments":true,"path":"numpy教程/13-矩阵库/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/13-%E7%9F%A9%E9%98%B5%E5%BA%93/","excerpt":"","text":"NumPy 中包含了一个矩阵库numpy.matlib，该模块中的函数返回的是一个矩阵，而不是ndarray对象。一个m∗nm*nm∗n的矩阵是一个由mmm行（row）nnn列（column）元素排列成的矩形阵列。矩阵里的元素可以是数字、符号或数学式。{123456789}\\left\\{ \\begin{matrix} 1&amp;2&amp;3\\\\ 4&amp;5&amp;6\\\\ 7&amp;8&amp;9 \\end{matrix} \\right\\}⎩⎨⎧​147​258​369​⎭⎬⎫​ matlib.empty()matlib.empty()函数返回一个新的矩阵，语法格式为：12345678910numpy.matlib.empty(shape, dtype, order)# shape: 定义新矩阵形状的整数或整数元组# Dtype: 可选，数据类型# order: C（行序优先） 或者 F（列序优先）import numpy.matlib import numpy as np print (np.matlib.empty((2,2)))# 填充为随机数据 numpy.matlib.zeros()numpy.matlib.zeros()函数创建一个以 0 填充的矩阵。1print (np.matlib.ones((2,2))) numpy.matlib.eye()numpy.matlib.eye()函数返回一个矩阵，对角线元素为 1，其他位置为零。123456numpy.matlib.eye(n, M,k, dtype)# n: 返回矩阵的行数# M: 返回矩阵的列数，默认为 n# k: 对角线的索引# dtype: 数据类型print (np.matlib.eye(n = 3, M = 4, k = 0, dtype = float)) numpy.matlib.identity()numpy.matlib.identity()函数返回给定大小的单位矩阵。单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。12# 大小为 5，类型位浮点型print (np.matlib.identity(5, dtype = float)) numpy.matlib.rand()numpy.matlib.rand()函数创建一个给定大小的矩阵，数据是随机填充的。1print (np.matlib.rand(3,3)) matrix与ndarray转换矩阵总是二维的，而ndarray是一个 n 维数组。两个对象都是可互换的。123i = np.matrix('1,2;3,4') j = np.asarray(i) k = np.asmatrix (j)","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"12-副本和视图","slug":"numpy教程/12-副本和视图","date":"2020-05-25T16:35:03.000Z","updated":"2020-05-25T16:39:25.308Z","comments":true,"path":"numpy教程/12-副本和视图/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/12-%E5%89%AF%E6%9C%AC%E5%92%8C%E8%A7%86%E5%9B%BE/","excerpt":"","text":"副本是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。视图是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。视图一般发生在：numpy 的切片操作返回原数据的视图。调用 ndarray 的 view() 函数产生一个视图。副本一般发生在：Python 序列的切片操作，调用deepCopy()函数。调用 ndarray 的 copy() 函数产生一个副本。 无复制简单的赋值不会创建数组对象的副本。相反，它使用原始数组的相同id()来访问它。id()返回 Python 对象的通用标识符，类似于 C 中的指针。此外，一个数组的任何变化都反映在另一个数组上。例如，一个数组的形状改变也会改变另一个数组的形状。 视图或浅拷贝ndarray.view()方会创建一个新的数组对象，该方法创建的新数组的维数更改不会更改原始数据的维数。 副本或深拷贝ndarray.copy()函数创建一个副本。对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"11-排序、条件刷选函数","slug":"numpy教程/11-排序、条件刷选函数","date":"2020-05-25T16:33:52.000Z","updated":"2020-05-25T16:39:07.231Z","comments":true,"path":"numpy教程/11-排序、条件刷选函数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/11-%E6%8E%92%E5%BA%8F%E3%80%81%E6%9D%A1%E4%BB%B6%E5%88%B7%E9%80%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"NumPy 提供了多种排序的方法。这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。种类速度最坏情况工作空间稳定性quicksort 快速排序1O(n^2)0否mergesort 归并排序2O(n*log(n))~n/2是heapsort 堆排序3O(n*log(n))0否 numpy.sort()numpy.sort()函数返回输入数组的排序副本。函数格式如下：12345678910111213141516171819# a: 要排序的数组# axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=0 按列排序，axis=1 按行排序# kind: 默认为'quicksort'（快速排序）# order: 如果数组包含字段，则是要排序的字段numpy.sort(a, axis, kind, order)# 实例import numpy as np a = np.array([[3,7],[9,1]]) print ('调用 sort() 函数：')print (np.sort(a))print ('按列排序：')print (np.sort(a, axis = 0))# 在 sort 函数中排序字段 dt = np.dtype([('name', 'S10'),('age', int)]) a = np.array([(\"raju\",21),(\"anil\",25),(\"ravi\", 17), (\"amar\",27)], dtype = dt) print ('按 name 排序：')print (np.sort(a, order = 'name')) numpy.argsort()numpy.argsort()函数返回的是数组值从小到大的索引值。1234567891011import numpy as np x = np.array([3, 1, 2]) print ('对 x 调用 argsort() 函数：')y = np.argsort(x) print (y)print ('以排序后的顺序重构原数组（从小到大排序）：')print (x[y])print ('使用循环重构原数组（从小到大排序）：')for i in y: print (x[i], end=\" \") numpy.lexsort()numpy.lexsort()用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取……这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。12345678910import numpy as np nm = ('raju','anil','ravi','amar') dv = ('f.y.', 's.y.', 's.y.', 'f.y.') ind = np.lexsort((dv,nm)) print ('调用 lexsort() 函数：') print (ind) print ('\\n') print ('使用这个索引来获取排序后的数据：') print ([nm[i] + \", \" + dv[i] for i in ind]) 其他函数函数描述msort(a)数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相等于 np.sort(a, axis=0)。sort_complex(a)对复数按照先实部后虚部的顺序进行排序。partition(a, kth[, axis, kind, order])指定一个数，对数组进行分区argpartition(a, kth[, axis, kind, order])可以通过关键字 kind 指定算法沿着指定轴对数组进行分区numpy.argmax()和 numpy.argmin()分别沿给定轴返回最大和最小元素的索引。numpy.nonzero()返回输入数组中非零元素的索引numpy.where()返回输入数组中满足给定条件的元素的索引numpy.extract()根据某个条件从数组中抽取元素，返回满条件的元素","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"10-统计函数","slug":"numpy教程/10-统计函数","date":"2020-05-25T16:31:45.000Z","updated":"2020-05-25T16:39:02.312Z","comments":true,"path":"numpy教程/10-统计函数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/10-%E7%BB%9F%E8%AE%A1%E5%87%BD%E6%95%B0/","excerpt":"","text":"NumPy 提供了很多统计函数，用于从数组中查找最小元素，最大元素，百分位标准差和方差等。 计算最小值和最大值numpy.amin()用于计算数组中的元素沿指定轴的最小值。numpy.amax()用于计算数组中的元素沿指定轴的最大值。12345678910111213import numpy as np a = np.array([[3,7,5],[8,4,3],[2,4,9]]) print (np.amin(a,1))# 结果：[3 3 2]print (np.amin(a,0))# 结果：[2 4 3]print (np.amax(a))# 结果：9print (np.amax(a, axis = 0))# 结果：[8 7 9]numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。12345678910import numpy as np a = np.array([[3,7,5],[8,4,3],[2,4,9]]) print (np.ptp(a))# 结果：7print (np.ptp(a, axis = 1))# 结果：[4 5 7]print (np.ptp(a, axis = 0))# 结果：[6 3 6] 百分位数百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数numpy.percentile()接受以下参数。1234numpy.percentile(a, q, axis)# a: 输入数组# q: 要计算的百分位数，在 0 ~ 100 之间# axis: 沿着它计算百分位数的轴首先明确百分位数：第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。1234567891011import numpy as np a = np.array([[10, 7, 4], [3, 2, 1]])# 50% 的分位数，就是 a 里排序之后的中位数print (np.percentile(a, 50)) # axis 为 0，在纵列上求print (np.percentile(a, 50, axis=0)) # axis 为 1，在横行上求print (np.percentile(a, 50, axis=1)) # 保持维度不变print (np.percentile(a, 50, axis=1, keepdims=True)) 中位数numpy.median()函数用于计算数组a中元素的中位数（中值）。12345678import numpy as np a = np.array([[30,65,70],[80,95,10],[50,90,60]]) print (np.median(a))# 沿轴 0 调用 median() 函数print (np.median(a, axis = 0))# 沿轴 1 调用 median() 函数print (np.median(a, axis = 1)) 算术平均值numpy.mean()函数返回数组中元素的算术平均值。如果提供了轴，则沿其计算。算术平均值是沿轴的元素的总和除以元素的数量。123456789import numpy as np a = np.array([[1,2,3],[3,4,5],[4,5,6]]) print ('调用 mean() 函数：')print (np.mean(a))print ('沿轴 0 调用 mean() 函数：')print (np.mean(a, axis = 0))print ('沿轴 1 调用 mean() 函数：')print (np.mean(a, axis = 1)) 加权平均值numpy.average()函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。该函数可以接受一个轴参数。如果没有指定轴，则数组会被展开。加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。即通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。123456789101112import numpy as np a = np.array([1,2,3,4]) print ('调用 average() 函数：')# 不指定权重时相当于 mean 函数print (np.average(a))# 权重数组wts = np.array([4,3,2,1]) print (np.average(a,weights = wts))# 如果 returned 参数设为 true，则返回权重的和 print ('权重的和：')print (np.average([1,2,3, 4],weights = [4,3,2,1], returned = True)) 标准差标准差是一组数据平均值分散程度的一种度量。标准差是方差的算术平方根。标准差公式如下：$$std=\\sqrt{mean((x-\\bar{x})^2)}$$123import numpy as np print (np.std([1,2,3,4])) 方差统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即mean((x−xˉ)2)mean((x-\\bar{x})^2)mean((x−xˉ)2)。换句话说，标准差是方差的平方根。123import numpy as np print (np.var([1,2,3,4]))","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"09-算术函数","slug":"numpy教程/09-算数函数","date":"2020-05-25T16:31:01.000Z","updated":"2020-05-25T16:38:55.418Z","comments":true,"path":"numpy教程/09-算数函数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/09-%E7%AE%97%E6%95%B0%E5%87%BD%E6%95%B0/","excerpt":"","text":"简单的加减乘除NumPy 算术函数包含简单的加减乘除:add()，subtract()，multiply()和divide()。需要注意的是数组必须具有相同的形状或符合数组广播规则。12345678910111213141516import numpy as np a = np.arange(9, dtype = np.float_).reshape(3,3) b = np.array([10,10,10]) print ('两个数组相加：')print (np.add(a,b))print ('两个数组相减：')print (np.subtract(a,b))print ('两个数组相乘：')print (np.multiply(a,b))print ('两个数组相除：')print (np.divide(a,b) 计算数组元素的倒数numpy.reciprocal()函数返回参数逐元素的倒数。如 1/4 倒数为 4/1。1234import numpy as np a = np.array([0.25, 1.33, 1, 100]) print (np.reciprocal(a)) 计算数组的幂numpy.power()函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。12345678910import numpy as np a = np.array([10,100,1000]) print (np.power(a,2))# 结果：[ 100 10000 1000000]b = np.array([1,2,3]) print (np.power(a,b))# 结果：[ 10 10000 1000000000] 计算数组的余数numpy.mod()计算输入数组中相应元素的相除后的余数。 函数 numpy.remainder()也产生相同的结果。1234567import numpy as np a = np.array([10,20,30]) b = np.array([3,5,7]) print (np.mod(a,b))print (np.remainder(a,b))# 结果：[1 0 2]","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"08-数学函数","slug":"numpy教程/08-数学函数","date":"2020-05-25T16:23:55.000Z","updated":"2020-05-25T16:38:50.321Z","comments":true,"path":"numpy教程/08-数学函数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/08-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/","excerpt":"","text":"NumPy 包含大量的各种数学运算的函数，包括三角函数，算术运算的函数，复数处理函数等。 三角函数NumPy 提供了标准的三角函数：sin()、cos()、tan()。arcsin，arccos，和arctan函数返回给定角度的sin，cos和tan的反三角函数。这些函数的结果可以通过numpy.degrees()函数将弧度转换为角度。1234567891011121314151617181920212223242526272829303132333435import numpy as np a = np.array([0,30,45,60,90]) print ('含有正弦值的数组：')sin = np.sin(a*np.pi/180) print (sin)print ('\\n')print ('计算角度的反正弦，返回值以弧度为单位：')inv = np.arcsin(sin) print (inv)print ('\\n')print ('通过转化为角度制来检查结果：')print (np.degrees(inv))print ('\\n')print ('arccos 和 arctan 函数行为类似：')cos = np.cos(a*np.pi/180) print (cos)print ('\\n')print ('反余弦：')inv = np.arccos(cos) print (inv)print ('\\n')print ('角度制单位：')print (np.degrees(inv))print ('\\n')print ('tan 函数：')tan = np.tan(a*np.pi/180) print (tan)print ('\\n')print ('反正切：')inv = np.arctan(tan) print (inv)print ('\\n')print ('角度制单位：')print (np.degrees(inv)) 舍入函数numpy.around()函数返回指定数字的四舍五入值。12345678910# 格式# a:数组；decimals:舍入的小数位数，默认值为0。如果为负，整数将四舍五入到小数点左侧位置numpy.around(a,decimals)# 实例import numpy as npa = np.array([1.0,5.55, 123, 0.567, 25.532])print (np.around(a))print (np.around(a, decimals = 1))print (np.around(a, decimals = -1))numpy.floor()返回数字的下舍整数。12345import numpy as np a = np.array([-1.7, 1.5, -0.2, 0.6, 10])print (np.floor(a))# 修改后的数组：[-2. 1. -1. 0. 10.]numpy.ceil()返回数字的上入整数。12345import numpy as np a = np.array([-1.7, 1.5, -0.2, 0.6, 10]) print (np.ceil(a))# 修改后的数组：[-1. 2. -0. 1. 10.]","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"07-位运算","slug":"numpy教程/07-位运算","date":"2020-05-25T16:23:12.000Z","updated":"2020-05-25T16:38:44.082Z","comments":true,"path":"numpy教程/07-位运算/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/07-%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"NumPy 位运算bitwise_开头的函数就是位运算函数。NumPy 位运算包括以下几个函数：函数描述bitwise_and对数组元素执行位与操作bitwise_or对数组元素执行位或操作invert按位取反left_shift向左移动二进制标志的位right_shift向右移动二进制表示的位注：也可以使用&amp;、~、|和^等操作符进行计算 bitwise_andbitwise_and()函数对数组中整数的二进制形式执行位与运算。与运算只要有一个0结果就为0,只有两个1的情况下结果才是1。123456789import numpy as np print ('13 和 17 的二进制形式：')a,b = 13,17print (bin(a), bin(b))print ('\\n') print ('13 和 17 的位与：')print (np.bitwise_and(13, 17)) bitwise_orbitwise_or()函数对数组中整数的二进制形式执行位或运算。或运算只要有一个1结果就为1,只有两个0的情况下结果才是0。12345678import numpy as np a,b = 13,17 print ('13 和 17 的二进制形式：')print (bin(a), bin(b)) print ('13 和 17 的位或：')print (np.bitwise_or(13, 17)) invertinvert()函数对数组中整数进行位取反运算，即0变成1，1变成0。对于有符号整数，取该二进制数的补码，然后+1。二进制数，最高位为0表示正数，最高位为1表示负数。看看~1的计算步骤：将1(这里叫：原码)转二进制 ＝ 00000001按位取反 ＝ 11111110发现符号位(即最高位)为1(表示负数)，将除符号位之外的其他数字取反 ＝ 10000001末位加1取其补码 ＝ 10000010转换回十进制 ＝ -212345678910111213import numpy as np print ('13 的位反转，其中 ndarray 的 dtype 是 uint8：')print (np.invert(np.array([13], dtype = np.uint8)))print ('\\n')# 比较 13 和 242 的二进制表示，我们发现了位的反转 print ('13 的二进制表示：')print (np.binary_repr(13, width = 8))print ('\\n') print ('242 的二进制表示：')print (np.binary_repr(242, width = 8)) left_shift 和 right_shiftleft_shift()函数将数组元素的二进制形式向左移动到指定位置，右侧附加相等数量的0。right_shift()函数将数组元素的二进制形式向右移动到指定位置，左侧附加相等数量的0。123456# 左移一位相当于乘2，右移一位相当于除以2print ('将 10 左移两位：')print (np.left_shift(10,2))print ('将 4 右移两位：')print (np.right_shift(4,2))","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"06-数组操作","slug":"numpy教程/06-数组操作","date":"2020-05-25T16:21:58.000Z","updated":"2020-05-25T16:38:39.304Z","comments":true,"path":"numpy教程/06-数组操作/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/06-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"NumPy 数组操作 修改数组形状函数描述reshape不改变数据的条件下修改形状flat数组元素迭代器flatten返回一份数组拷贝，对拷贝所作的修改不会影响原始数组ravel返回展开数组12345678910111213141516171819202122# numpy.reshape函数可以在不改变数据的条件下修改形状,，格式如下：# arr:要修改形状的数组；newshape:整数或者整数数组，新形状应该兼容原有形状；order:C-按行，F-按列，A-原顺序，k-在内存中的顺序numpy.reshape(arr, newshape,order='C')a = np.arange(8)b = a.reshape(4,2)# numpy.ndarray.flat 是一个数组元素迭代器a = np.arange(9).reshape(3,3)#对数组中每个元素都进行处理，可以使用flat属性，该属性是一个数组元素迭代器：for element in a.flat: print (element)# numpy.ndarray.flatten返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，格式如下：ndarray.flatten(order='C')a = np.arange(8).reshape(2,4)b = a.flatten(order='F')# numpy.ravel()展平的数组元素，顺序通常是\"C风格\"，返回的是数组视图（view，有点类似C/C++引用reference的意味），修改会影响原始数组。# 该函数接收两个参数：numpy.ravel(a, order='C')a = np.arange(8).reshape(2,4)a.ravel(order = 'F') 翻转数组函数描述transpose转置，对换数组的维度ndarray.T转置rollaxis向后滚动指定的轴swapaxes对换数组的两个轴1234567891011121314151617181920# numpy.transpose 函数用于对换数组的维度，格式如下：# arr：要操作的数组；axes：整数列表，对应维度，通常所有维度都会对换numpy.transpose(arr, axes)a = np.arange(12).reshape(3,4)# 下面两条语句效果一样np.transpose(a)a.T# numpy.rollaxis函数向后滚动特定的轴到一个特定位置，格式如下：# arr：数组;axis：要向后滚动的轴，其它轴的相对位置不会改变;start：默认为零，表示完整的滚动。会滚动到特定位置。numpy.rollaxis(arr, axis, start)# 创建三维的ndarraya = np.arange(8).reshape(2,2,2)np.rollaxis(a,2,1)# numpy.swapaxes函数用于交换数组的两个轴，格式如下：numpy.swapaxes(arr, axis1, axis2)a = np.arange(8).reshape(2,2,2)# 现在交换轴 0（深度方向）到轴 2（宽度方向）np.swapaxes(a, 2, 0) 修改数组维度维度描述broadcast产生模仿广播的对象broadcast_to将数组广播到新形状expand_dims扩展数组的形状squeeze从数组的形状删除一维条目1234567891011121314151617181920# numpy.broadcast用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。x = np.array([[1], [2], [3]])y = np.array([4, 5, 6])# 对 y 广播 xb = np.broadcast(x,y) # numpy.broadcast_to函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。numpy.broadcast_to(array, shape, subok)a = np.arange(4).reshape(1,4)np.broadcast_to(a,(4,4))# numpy.expand_dims函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下:numpy.expand_dims(arr, axis)x = np.array(([1,2],[3,4]))y = np.expand_dims(x, axis = 0)# numpy.squeeze函数从给定数组的形状中删除一维的条目，函数格式如下：numpy.squeeze(arr, axis)x = np.arange(9).reshape(1,3,3)y = np.squeeze(x) 连接数组函数描述concatenate连接沿现有轴的数组序列stack沿着新的轴加入一系列数组hstack水平堆叠序列中的数组（列方向）vstack竖直堆叠序列中的数组（行方向）12345678910111213141516# numpy.concatenate函数用于沿指定轴连接相同形状的两个或多个数组，格式如下：numpy.concatenate((a1, a2, ...), axis)a = np.array([[1,2],[3,4]])b = np.array([[5,6],[7,8]])np.concatenate((a,b),axis = 1)# numpy.stack 函数用于沿新轴连接数组序列，格式如下：numpy.stack(arrays, axis)a = np.array([[1,2],[3,4]])b = np.array([[5,6],[7,8]])np.stack((a,b),1)# numpy.hstack是numpy.stack函数的变体，它通过水平堆叠来生成数组# numpy.vstack是numpy.stack函数的变体，它通过垂直堆叠来生成数组np.hstack((a,b))np.vstack((a,b)) 分隔数组函数数组及操作split将一个数组分割为多个子数组hsplit将一个数组水平分割为多个子数组（按列）vsplit将一个数组垂直分割为多个子数组（按行）12345678910111213141516171819# numpy.split函数沿特定的轴将数组分割为子数组，格式如下：# ary：被分割的数组# indices_or_sections：果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭# axis：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分numpy.split(ary, indices_or_sections, axis)a = np.arange(9)# 将数组分为三个大小相等的子数组b = np.split(a,3)# 将数组在一维数组中表明的位置分割b = np.split(a,[4,7])# numpy.hsplit函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组harr = np.floor(10 * np.random.random((2, 6)))np.hsplit(harr, 3)# numpy.vsplit沿着垂直轴分割，其分割方式与hsplit用法相同a = np.arange(16).reshape(4,4)b = np.vsplit(a,2) 数组元素的添加与删除函数元素及描述resize返回指定形状的数组append将值添加到数组末尾insert沿指定轴将值添加到指定下标之前delete删除某个轴的子数组，并返回删除后的新数组unique查找数组内的唯一元素123456789101112131415161718192021222324252627282930313233343536373839404142# numpy.resize 函数返回指定大小的新数组# 如果新数组大小大于原始大小，则包含原始数组中的元素的副本# arr：要修改大小的数组;shape：返回数组的新形状numpy.resize(arr, shape)a = np.array([[1,2,3],[4,5,6]])b = np.resize(a, (3,2))# numpy.append函数在数组的末尾添加值# 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError# append 函数返回的始终是一个一维数组# arr：输入数组;values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）# axis：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）numpy.append(arr, values, axis=None)a = np.array([[1,2,3],[4,5,6]])b = np.append(a, [7,8,9])# numpy.insert函数在给定索引之前，沿给定轴在输入数组中插入值# 如果值的类型转换为要插入，则它与输入数组不同。插入没有原地的，函数会返回一个新数组。此外，如果未提供轴，则输入数组会被展开。numpy.insert(arr, obj, values, axis)a = np.array([[1,2],[3,4],[5,6]])# 未传递 Axis 参数。 在插入之前输入数组会被展开np.insert(a,3,[11,12])# 传递了 Axis 参数。 会广播值数组来配输入数组np.insert(a,1,[11],axis = 0)# numpy.delete函数返回从输入数组中删除指定子数组的新数组。与 insert()函数的情况一样，如果未提供轴参数，则输入数组将展开。Numpy.delete(arr, obj, axis)a = np.arange(12).reshape(3,4)# 删除第二列np.delete(a,1,axis = 1)# numpy.unique函数用于去除数组中的重复元素# arr：输入数组，如果不是一维数组则会展开# return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储# return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储# return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数numpy.unique(arr, return_index, return_inverse, return_counts)a = np.array([5,2,6,2,7,5,6,8,2,9])# 去重值和去重数组的索引数组u,indices = np.unique(a, return_index = True)# 返回去重元素的重复数量u,indices = np.unique(a,return_counts = True)","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"05-广播与迭代","slug":"numpy教程/05-广播与迭代","date":"2020-05-25T16:04:37.000Z","updated":"2020-05-25T16:38:28.917Z","comments":true,"path":"numpy教程/05-广播与迭代/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/05-%E5%B9%BF%E6%92%AD%E4%B8%8E%E8%BF%AD%E4%BB%A3/","excerpt":"","text":"NumPy 广播（Broadcast）广播(Broadcast)是numpy对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。如果两个数组 a 和 b 形状相同，即满足a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。广播的规则：让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。输出数组的形状是输入数组形状的各个维度上的最大值。如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。**简单理解：**对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足数组拥有相同形状。当前维度的值相等。当前维度的值有一个是 1。若条件不满足，抛出ValueError: frames are not aligned异常。12345678import numpy as np # 4x3 的二维数组与长为 3 的一维数组相加，等效于把数组 b 在二维上重复 4 次再运算a = np.array([[ 0, 0, 0], [10,10,10], [20,20,20], [30,30,30]])b = np.array([1,2,3])print(a + b) NumPy 迭代数组NumPy迭代器对象numpy.nditer提供了一种灵活访问一个或者多个数组元素的方式。迭代器最基本的任务的可以完成对数组元素的访问。12345678910# 用 arange() 函数创建一个 2X3 数组，并使用 nditer 对它进行迭代。import numpy as npa = np.arange(6).reshape(2,3)print ('原始数组是：')print (a)print ('\\n')print ('迭代输出元素：')for x in np.nditer(a): print (x, end=\", \" )print ('\\n')以上实例不是使用标准C或者Fortran顺序，选择的顺序是和数组内存布局一致的，这样做是为了提升访问的效率，默认是行序优先（row-major order，或者说是C-order）。这反映了默认情况下只需访问每个元素，而无需考虑其特定顺序。 控制遍历顺序for x in np.nditer(a, order='F'):Fortran order，即是列序优先；for x in np.nditer(a.T, order='C'):C order，即是行序优先； 修改数组中元素的值nditer对象有另一个可选参数op_flags。 默认情况下，nditer将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。12345678910import numpy as npa = np.arange(0,60,5) a = a.reshape(3,4) print ('原始数组是：')print (a)print ('\\n')for x in np.nditer(a, op_flags=['readwrite']): x[...]=2*x print ('修改后的数组是：')print (a) 使用外部循环nditer类的构造器拥有flags参数，它可以接受下列值：参数描述c_index可以跟踪C顺序的索引f_index可以跟踪Fortran顺序的索引multi-index每次迭代可以跟踪一种索引类型external_loop给出的值是具有多个值的一维数组，而不是零维数组123456789import numpy as np a = np.arange(0,60,5) a = a.reshape(3,4) print ('原始数组是：')print (a)print ('\\n')print ('修改后的数组是：')for x in np.nditer(a, flags = ['external_loop'], order = 'F'): print (x, end=\", \" ) 广播迭代如果两个数组是可广播的，nditer组合对象能够同时迭代它们。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。1234567891011121314import numpy as np a = np.arange(0,60,5) a = a.reshape(3,4) print ('第一个数组为：')print (a)print ('\\n')print ('第二个数组为：')b = np.array([1, 2, 3, 4], dtype = int) print (b)print ('\\n')print ('修改后的数组为：')for x,y in np.nditer([a,b]): print (\"%d:%d\" % (x,y), end=\", \" )","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"04-切片与索引","slug":"numpy教程/04-切片与索引","date":"2020-05-25T16:03:19.000Z","updated":"2020-05-25T16:04:00.026Z","comments":true,"path":"numpy教程/04-切片与索引/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/04-%E5%88%87%E7%89%87%E4%B8%8E%E7%B4%A2%E5%BC%95/","excerpt":"","text":"NumPy 切片和索引ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中list的切片操作一样。ndarray数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的slice函数，并设置start, stop及step参数进行，从原数组中切割出一个新数组。我们可以通过冒号分隔切片参数start:stop:step来进行切片操作：12345678import numpy as np a = np.arange(10)# 从索引 2 开始到索引 7 停止，间隔为2s = slice(2,7,2) print (a[s])# 从索引 2 开始到索引 7 停止，间隔为 2b = a[2:7:2] 冒号:的解释(重点)如果只放置一个参数，如[2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如[2:7]，那么则提取两个索引(不包括停止索引)之间的项。1234567import numpy as npa = np.arange(10) # [0 1 2 3 4 5 6 7 8 9]b = a[5] # 5a[2:] # [2 3 4 5 6 7 8 9]a[2:5] # [2 3 4]a = np.array([[1,2,3],[3,4,5],[4,5,6]])a[1:] # [[3 4 5] [4 5 6]]切片还可以包括省略号…，来使选择元组的长度与数组的维度相同。如果在行位置使用省略号，它将返回包含行中元素的ndarray。1234a = np.array([[1,2,3],[3,4,5],[4,5,6]])print (a[...,1]) # 第2列元素print (a[1,...]) # 第2行元素print (a[...,1:]) # 第2列及剩下的所有元素 NumPy 高级索引NumPy比一般的 Python 序列提供更多的索引方式。除了之前看到的用整数和切片的索引外，数组可以由整数数组索引、布尔索引及花式索引。 整数数组索引以下实例获取数组中(0,0)，(1,1)和(2,0)位置处的元素。1234567import numpy as np x = np.array([[1, 2], [3, 4], [5, 6]]) y = x[[0,1,2], [0,1,0]] print (y)# 输出结果# [1 4 5]以下实例获取了 4X3 数组中的四个角的元素。 行索引是 [0,0] 和 [3,3]，而列索引是 [0,2] 和 [0,2]。12345678910111213141516import numpy as np x = np.array([[ 0, 1, 2],[ 3, 4, 5],[ 6, 7, 8],[ 9, 10, 11]]) print ('我们的数组是：' )print (x)print ('\\n')rows = np.array([[0,0],[3,3]]) cols = np.array([[0,2],[0,2]]) y = x[rows,cols] print ('这个数组的四个角元素是：')print (y)''' 结果如下：[[ 0, 2], [ 9, 11]]'''可以借助切片:或…与索引数组组合。如下面例子：1234567import numpy as np a = np.array([[1,2,3], [4,5,6],[7,8,9]])b = a[1:3, 1:3] # 取2、3行的第2、3列c = a[1:3,[1,2]] # 取2、3行的第2和3个元素d = a[...,1:] # 取第2列和后面的所有列 布尔索引我们可以通过一个布尔数组来索引目标数组。布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。123456789101112131415import numpy as np # 获取大于 5 的元素x = np.array([[ 0, 1, 2],[ 3, 4, 5],[ 6, 7, 8],[ 9, 10, 11]]) print ('我们的数组是：')print (x)print ('\\n')# 现在我们会打印出大于 5 的元素 print ('大于 5 的元素是：')print (x[x &gt; 5])# 使用了 ~（取补运算符）来过滤 NaNa = np.array([np.nan, 1,2,np.nan,3,4,5]) print (a[~np.isnan(a)])# 从数组中过滤掉非复数元素a = np.array([1, 2+6j, 5, 3.5+5j])a[np.iscomplex(a)] 花式索引花式索引指的是利用整数数组进行索引。花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。花式索引跟切片不一样，它总是将数据复制到新数组中。1234567891011import numpy as np # 传入顺序索引数组x=np.arange(32).reshape((8,4))print (x[[4,2,1,7]])# 传入倒序索引数组x=np.arange(32).reshape((8,4))print (x[[-4,-2,-1,-7]])# 传入多个索引数组（要使用np.ix_）x=np.arange(32).reshape((8,4))print (x[np.ix_([1,5,7,2],[0,3,1,2])])","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"03-数组","slug":"numpy教程/03-数组","date":"2020-05-25T16:01:51.000Z","updated":"2020-05-25T16:04:06.437Z","comments":true,"path":"numpy教程/03-数组/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/03-%E6%95%B0%E7%BB%84/","excerpt":"","text":"NumPy数组属性NumPy 数组的维数称为秩（rank），一维数组的秩为 1，二维数组的秩为 2，以此类推。在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作。NumPy 的数组中比较重要ndarray对象属性有：属性说明ndarray.ndim秩，即轴的数量或维度的数量ndarray.shape数组的维度，对于矩阵，n行m列ndarray.size数组元素的总个数,n*mndarray.dtypendarray对象的元素类型ndarray.itemsizendarray对象中每个元素的大小，以字节为单位ndarray.flagsndarray对象的内部信息ndarray.realndarray元素的实部ndarray.imagndarray元素的虚部ndarray.data包含实际数组元素的缓冲区，一般通过数组索引获取元素，所以不需要使用这个属性 NumPy创建数组ndarray数组除了可以使用底层ndarray构造器来创建外，也可以通过以下几种方式来创建。 numpy.emptynumpy.empty方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：123456789# 格式numpy.empty(shape, dtype=float, order='C')# 实例x = numpy.empty([3,2],dtype=int)''' 结果如下：里面的数据将会随机生成[[ 5.11798224e-307 3.44897992e-307] [ 1.24610383e-306 1.37961709e-306] [ 1.29057883e-306 1.24610927e-306]]'''参数说明：参数说明shape数组形状dtype数据类型，可选order有’C’和’F’两个选项，分别代表行优先和列优先，在计算机内存中存储元素的顺序注意 数组元素为随机值，因为它们未初始化 numpy.zeros创建指定大小的数组，数组元素以 0 来填充：1234567891011# 格式numpy.zeros(shape, dtype=float, order='C')# 实例# 默认为浮点数x = numpy.zeros(5) # 1*5的矩阵y = numpy.zeros([2,3],dtype=np.int) # 2*3的矩阵''' 结果如下:[ 0. 0. 0. 0. 0.][[ 0. 0. 0.] [ 0. 0. 0.]]''' numpy.ones创建指定形状的数组，数组元素以 1 来填充：12345678# 格式numpy.ones(shape, dtype = None, order = 'C')# 实例x = np.ones([2,2], dtype = int)''' 结果如下：[[1 1] [1 1]]''' NumPy从已有的数组创建数组 numpy.asarray12345# 格式numpy.asarray(a, dtype = None, order = None)# 实例x = [[1,2,3],[4,5,6]]a = numpy.asarray(x)参数说明参数描述a任意形式的输入参数，可以是列表、元组、多维数组等dtype数据类型，可选order可选，有&quot;C&quot;和&quot;F&quot;两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。 numpy.frombuffernumpy.frombuffer用于实现动态数组。numpy.frombuffer接受buffer输入参数，以流的形式读入转化成ndarray 对象。123456# 格式numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)# 实例s = b'Hello World' a = numpy.frombuffer(s, dtype = 'S1') print (a)注意 buffer是字符串的时候，Python3 默认str是Unicode类型，所以要转成bytestring在原str前加上 b。参数说明参数说明buffer可以是任意对象，会以流的形式读入。dtype可选，数据类型count读取的数据数量，默认为-1，读取所有数据offset读取的起始位置，默认为0 numpy.fromiternumpy.fromiter方法从可迭代对象中建立 ndarray`对象，返回一维数组。123456789# 格式numpy.fromiter(iterable, dtype, count=-1)# 实例# 使用 range 函数创建列表对象 list=range(5)it=iter(list) # 使用迭代器创建 ndarray x=numpy.fromiter(it, dtype=float)参数说明iterable可迭代对象dtype返回的数组的数据类型count读取的数据量，默认为-1，读取所有数据 NumPy 从数值范围创建数组 numpy.arangenumpy包中的使用arange函数创建数值范围并返回ndarray对象，函数格式如下：12345678numpy.arange(start, stop, step, dtype)# 实例：生成 0 到 5 的数组x = numpy.arange(5)# 指定数据类型x = numpy.arange(5, dtype=float)# 设置起始值、终止值和步长x = numpy.arange(10, 20, 2)根据start与stop指定的范围以及step 设定的步长，生成一个ndarray。参数说明：参数说明start起始值，默认为0stop终止值（不包含）step步长，默认为1dtype返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型 numpy.linspacenumpy.linspace函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下：12345678910numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)# 实例# 设置起始点为 1 ，终止点为 10，数列个数为 10a = numpy.linspace(1,10,10)''' 结果如下[ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10.]'''# 设置10个全是1的数列a = numpy.linspace(1,1,10)参数说明：参数说明start起始值，默认为0stop终止值，如果endpoint为true，该值包含在数列中num要生成的等步长的样本数量，默认为50endpoint是否包含终止值，默认为Trueretstep如果为True，生成的数组中会显示间距，反之不显示dtypendarray的数据类型 numpy.logspacenumpy.logspace函数用于创建一个于等比数列di=baseid_i=base^idi​=basei。格式如下：1234567numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)# 实例# 默认底数是 10a = numpy.logspace(1.0,2.0,num=10)# 设置底数是2a = numpy.logspace(0,9,10,base=2)参数描述start序列的起始值为：base**startstop序列终止值为：base**stop。如果endpoint为true，该值包含在序列中num要生成的等步长的样本数量，默认为50endpoint是否包含终止值，默认为Truebase对数log的底数dtypendarray的数据类型","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"02-数据对象","slug":"numpy教程/02-数据对象","date":"2020-05-25T16:01:10.000Z","updated":"2020-05-25T16:04:10.610Z","comments":true,"path":"numpy教程/02-数据对象/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/02-%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"Numpy数据类型numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型。名称描述bool_布尔型数据类型（True或者False）int8/16/32/64整数unit8/16/32/64无符号整数float16/32/64半/单/双精度浮点数complex64/128复数numpy 的数值类型实际上是dtype对象的实例，并对应唯一的字符，包括np.bool_，np.int32，np.float32等等。 数据类型对象(dtype)数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：数据的类型（整数，浮点数或者Python对象）数据的大小（例如整数用多少字节存储）数据的字节顺序（小端法或大端法）在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分如果数据类型是子数组，它的形状和数据类型字节顺序是通过对数据类型预先设定&lt;或&gt;来决定的。&lt;意味着小端法（最小值存储在最小的地址，即低位放前面）。&gt;意味着大端法（最重要的字节存储在最小的地址，即高位组放在最前面）。dtype对象是使用以下语法构造的：1numpy.dtype(object, align, copy)object-要转换为的数据类型对象align-如果为true,填充字段使其类似C的结构体copy-复制dtype对象，如果为false，则是内置数据类型对象的引用","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"01-numpy导论","slug":"numpy教程/01-numpy导论","date":"2020-05-25T15:24:43.000Z","updated":"2020-05-25T16:00:07.134Z","comments":true,"path":"numpy教程/01-numpy导论/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/01-numpy%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"什么是 NumPyNumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。NumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含：一个强大的 NNN 维数组对象ndarray广播功能函数整合 C/C++/Fortran 代码的工具线性代数、傅里叶变换、随机数生成等功能 NumPy Ndarray对象NumPy 最重要的一个特点是其N维数组对象ndarray，它是一系列同类型数据的集合，以0下标为开始进行集合中元素的索引。ndarray对象是用于存放同类型元素的多维数组。ndarray中的每个元素在内存中都有相同存储大小的区域。ndarray内部由以下内容组成：一个指向数据（内存或内存映射文件中的一块数据）的指针。数据类型或dtype，描述在数组中的固定大小值的格子。一个表示数组形状（shape）的元组，表示各维度大小的元组。一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要&quot;跨过&quot;的字节数。跨度可以是负数，这样会使数组在内存中后向移动，切片中obj[::-1]或obj[:,::-1]就是如此。 创建ndarray对象1numpy.array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)参数说明:名称描述object数组或嵌套的数列dtype数据元素的数据类型，可选copy对象是否需要复制，可选order创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）subok默认返回一个与基本类型一致的数组ndmin指定生成数组的最小维度下面给出示例代码创建实例：123import numpy as npa = np.array([[1,2,3],[4,5,6]])b = np.array([1,2,3],dtype=complex,ndmin=2)ndarray对象由计算机内存的连续一维部分组成，并结合索引模式，将每个元素映射到内存块中的一个位置。内存块以行顺序(C样式)或列顺序(FORTRAN或MatLab风格，即前述的F样式)来保存元素。","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"06-访问权限控制","slug":"Java编程思想/06-访问权限控制","date":"2020-05-25T15:15:28.000Z","updated":"2020-05-25T15:16:13.869Z","comments":true,"path":"Java编程思想/06-访问权限控制/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/06-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/","excerpt":"","text":"访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关。重构即重写代码，以使它更可读、更易理解、更高效，并因此而更具可维护性。但在这种修改和完善代码的愿景之下，也存在着巨大的压力。第一是资源（主要指时间、开发效率）浪费，二是客户端程序员需要你的代码在某些方面（即调用的接口方法）保持不变。因此你想改变代码，而他们却想让代码保持不变。这对于类库（library）而言尤其重要。为了解决这个问题，Java提供了访问权限修饰词，以供类库开发人员向客户端程序员指明哪些是可用的，哪些不可用。访问权限修饰词等级从权限最大到权限最小依次为：publicprotected包访问权限（默认不加访问权限关键词）private你会尽可能将一切方法都定为private，而仅向客户端程序员公开你愿意让他们使用的方法。对于如何将构件捆绑到一个内聚的类库单元的问题，Java用关键字package加以控制，而访问权限会因为类是否存在于相同的包中受到影响。 包：库单元包内包含有一组类，它们在单一的名字空间之下被组织在了一起。例如，在Java标准发布中有一个工具库，它被组织在java.util名字空间之下。java.util中存在有一个叫ArrayList的类，那么使用ArrayList类的一种方式是使用其全限定名字:java.util.ArrayList。1java.util.ArrayList list = new java.util.ArrayList();这会使得程序变得十分冗长，因此Java提供了import关键字帮助我们去简化。使用import关键字的意思是将全限定名字与简单名字(simple-name)做一个绑定，因此可以下面的代码编写中使用简单名字去替代全限定名字。123456import java.util.ArrayList;public class Test&#123; public static main(String[] args)&#123; ArrayList list = new ArrayList(); &#125;&#125;但是这样做，java.util中的其他类仍旧是不可用简单名字的。要想导入其中所有的类，只需要使用*，如import java.util.*。但个人并不推荐这种方式，应该是使用一个类并导入其对应的全限定名字，这样会使程序更稳健快速（因为在不同的名字空间下有许多相同的类名）。我们之所以要导入，就是要提供一个管理名字空间的机制。所有类成员的名称都是彼此隔离的。当编写一个Java源文件时，此文件通常被称为编译单元（或转译单元）。每个编译单元都必须有一个后缀名.java，而在编译单元中最多可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，不包括后缀名.java）。每个编译单元只能有一个public类，否则编译器会提示出错。如果在编译单元之中还有其他额外的类的话，那么在包之外的世界是无法看见这些类的（因为不加关键字默认是包访问权限），它们主要是为主public类提供支持。 代码组织当编译一个.java文件时，在.java文件中的每个类都会有一个输出文件，而该输出文件的名称与每个类的名称相同，只是多了一个后缀名.class。一般来说，编译型语言的编译流程如下：对于编译器根据编译单元产生一个中间文件（通常是obj文件），然后再将中间文件通过链接器（用以创建一个可执行文件）或类库产生器（librarian，用以创建一个类库）产生的其他同类文件捆绑起来。但这并不是Java的工作方式。Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR）的.class文件。Java解释器负责这些文件的查找、装载和解释。类库实际上是一组类文件。其中每个文件都有一个public类，一人任意数量的非public类。因此每个文件都有一个构件，如果希望这些构件从属于同一个群组，就可以使用关键字package。package语句必须是文件除注释以外的第一句程序代码。package和import关键字允许你做的是，将单一的全局名字空间分割开，使得无论多少人使用Internet和Java开始编写类，都不会出现名称冲突的情况。 创建独一无二的包名一种合乎逻辑的做法就是将特定包的所有.class文件都置于一个目录下。也就是说，利用操作系统的层次化的文件结构来解决混乱问题。将所有的同一类文件收入一个子目录还可以解决另外两个问题：怎样创建独一无二的名称怎么查找有可能隐藏于目录结构中某处的类这些任务是通过将.class文件所在的路径位置编码成package的名称来实现的。Java解释器的运行过程如下：首先找到环境变量CLASSPATH；CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，以从CLASSPATH跟中产生一个目录名称。得到的路径会与CLASSPATH的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类名称相关的.class文件。 定制工具库现在可以创建自己的工具库来减少或消除重复的程序代码，并可以使用一个更具可读性的静态import语句来导入：123456package cn.hengxin.utilpublic class Print&#123; public static void print(Object obj)&#123; System.out.println(obj); &#125;&#125;123456import cn.hengxin.util.Printpublic class PrintTest&#123; public static void main(String[] args)&#123; Print(\"Available from now on!\"); &#125;&#125; 用import改变行为Java没有C的条件编译功能，该功能可以使你不必更改任何程序代码，就能切换开关并产生不同的行为。Java去掉功能的原因可能是因为C在绝大多数情况下是用此功能来解决跨平台问题，即程序代码的不同部分是根据不同的平台来编译。由于Java本身可以自动跨越不同的平台，因此这个功能对Java而言是没有必要的。 Java访问权限修饰词 包访问权限默认访问权限没有任何关键字，但通常是指包访问权限（或friendly），这意味着当前包的所有其他类对那个成员都有访问权限，但对于这个包之外的所有类，这个成员却是private。包访问权限允许将包内所有相关的类组合起来，以使它们彼此之间可以轻松地相互作用。 public：接口访问权限使用关键字public就意味着之后紧跟的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。 private：你无法访问关键字private的意思是，除了包含该成员的类之外，其他任何类都无法访问这个成员，等于说是自己隔离了自己。private的使用是十分重要的，在多线程环境下更是如此。任何可以肯定是该类的一个“助手”都可以把它指定为private，以确保不会在包内的其他地方误用它，于是也就防止了你会去改变或删除这个方法。 protected：继承访问权限关键字protected处理的是继承的概念，通过继承可以利用一个现有类（称之为基类），然后将新成员添加到该现有类中而不必碰现有类，还可以改变该类的现有成员的行为。 接口和实现访问权限的控制常被称为是具体实现的隐藏。封装常被认为是：把数据和方法包装进类中，以及具体实现的隐藏。其结果是一个同时带有特征和行为的数据类型。访问权限控制将边界划在了数据类型内部：设定客户端程序员可以使用和不可以使用的界限将接口和具体实现进行分离 类的访问权限在Java中，访问权限修饰词也可以用于确定库中的哪些类对于该库的使用者是可用的。如果希望某个类可以为某个客户端程序员所用，就可以通过把关键字public作用在整个类的定义来达到目的。为了控制某个类的访问权限，**修饰词必须出现在关键字class之前。额外的限制：每个编译单元（文件）都只能有一个public类public类的名称必须完全与编译单元的文件名相匹配，包括大小写类即不可以是private也不可以是protected的。所以对于类的访问权限，仅有两个选择：包访问权限或者是public。如果不希望其他任何人对类拥有访问权限，可以将所有构造器都指定为private。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"05-初始化与清理","slug":"Java编程思想/05-初始化与清理","date":"2020-05-25T15:13:29.000Z","updated":"2020-05-25T15:16:27.177Z","comments":true,"path":"Java编程思想/05-初始化与清理/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/05-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/","excerpt":"","text":"随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。**初始化（initialize）和清理（cleanup）**正是涉及安全的两个问题。许多C程序的错误都源于程序员忘记初始化变量。清理也是一个特殊问题，当使用完一个元素时，容易把它忘掉，以至于这个元素占用的资源一直得不到释放，结果是计算机资源（特别是内存）用尽。C++引入了构造器（constructor）的概念，这是一个在创建对象时被自动调用的特殊方法。Java也采用了构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。 用构造器确保初始化在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果类具有构造器，Java就会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。考虑到编译器会在初始化期间自动调用构造器，构造器采用与类相同的名称。假设我们拥有以下这样一个类：12345class Rock&#123; Rock()&#123; System.out.println(\"I'm Rock!\"); &#125;&#125;现在，在创建对象时new Rock()，将会为对象分配存储空间，并调用相应的构造器。这就确保了在你能操作对象之前，它已经被恰当地初始化了。注意：构造器也是一个方法，但是这个方法与其他方法不一样的地方在于，不需要为其声明任何返回类型。不接受任何参数的构造器叫做默认构造器，Java文档中通常使用术语无参构造器。和其他方法一样，构造器也能带有形式参数，以便指定如何创建对象。1234567891011class Speaker&#123; // 这是无参构造器 Speaker()&#123; System.out.println(\"Sorry, I don't know who you are!\"); &#125; // 这是有参构造器 Speaker(String name)&#123; System.out.println(\"Hello\" + name + \"!\"); &#125;&#125;从概念上讲，“初始化”与“创建”是彼此独立的。但在Java中，“初始化”与“创建”捆绑在一起，两者不能分离。**构造器是一种特殊类型的方法，因为它没有返回值（不是指void，带有void的方法实际上返回的是一个void类型的变量）。**需要注意的是，new表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值。正如上述所说，其实这里是两步：创建对象与调用该对象的构造器方法（初始化），只是Java在我们new一个对象时，会自动帮我们调用其构造器方法。 方法重载任何程序设计语言都具备的一项重要特性就是名字的运用。当创建一个对象时，也就给此对象分配到的存储空间取了一个名字。所谓方法则是给某个动作取的名字。通过使用名字，你可以引用所有的对象和方法。在Java和C++里，构造器是强制重载方法名的一个重要原因。因为构造器必须与类同名，但我们又想为用户提供多种初始化的方式。为了让方法名相同而形式参数不同的构造器同时存在，必须用到方法重载，同时其亦可用于其他方法且用法相同。12345678910111213141516171819class Speaker&#123; // 这是无参构造器 Speaker()&#123; System.out.println(\"Sorry, I don't know who you are!\"); &#125; // 重载：这是有参构造器 Speaker(String name)&#123; System.out.println(\"Hello\" + name + \"!\"); &#125; // 方法sayHello() void sayHello()&#123; System.out.println(\"Hello world\"); &#125; // 重载方法sayHello(),向具体的人 void sayHello(String name)&#123; System.out.println(\"Hello\" + name + \"!\"); &#125;&#125; 区分重载方法每个重载的方法都必须有一个有一个独一无二的参数类型列表。在Java中，编译器是通过方法名+参数列表作为唯一的方法签名去识别具体调用哪个方法。 涉及基本类型的重载基本类型能从一个“较小”的类型自动提升至一个“较大”的类型，此类型一旦牵涉到重载，可能会造成一些混淆。1234567891011class PrimitiveOverloading&#123; // void f1(char x)&#123;System.out.println(\"char\");&#125; // void f1(byte x)&#123;System.out.println(\"byte\");&#125; void f1(int x)&#123;System.out.println(\"int\");&#125; void f1(float x)&#123;System.out.println(\"float\");&#125; // void f1(double x)&#123;System.out.println(\"double\");&#125;&#125;// 下面的输出是:intnew PrimitiveOverloading().f1('c');// 下面会编译器报错new PrimitiveOverloading().f1(5.0D);从上面的代码可以得出结论：如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际参数类型会被提升；如果传入的实际参数较大，就得手动通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。 以返回值区分重载方法在Java中，根据方法的返回值来区分重载方法是行不通的。因为Java是通过**方法签名（方法名+参数列表）**来标识和区分不同的方法的。 默认构造器默认构造器（又名“无参”构造器）是没有形式参数的–它的作用是创建一个“默认对象”。如果你的类中没有构造器，则编译器会自动帮你创建一个默认构造器。1class Bird&#123;&#125;上面的类中并未明确定义构造器，但你创建其对象时仍会触发默认构造器的方法，因为编译器会为你自动添加一个默认构造器。**但是，如果你已经定义了一个构造器（无论有无参数），编译器就不会帮你自动创建默认构造器。**因为编译器会认为你只允许用户由该“入口”创建并初始化该对象。 this关键字为了能用简便、面向对象的语法来编写代码–即“发送消息给对象”。在你调用对象方法时候，编译器会做一些幕后的工作，它暗自把“所操作对象的引用”作为第一个参数传递给方法。12345Person person = new Person();// 你调用sayHello()方法person.sayHello();// 实际在内部的表达形式如下Person.sayHello(person);假设你希望在方法的内部获得对当前对象的引用，可以使用关键字this。因为这个引用是由编译器“偷偷”传入的，所以没有标识符可用。**this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。**一般来说，只有当需要明确指出对当前对象的引用时，才需要使用this关键字。例如，当需要返回对当前对象的引用时，就常常在return语句里这样写:1234567public class Leaf&#123; int i = 0; Leaf increament()&#123; i++; return this; &#125;&#125; 在构造器中调用构造器可能为一个类写了多个构造器，有时可能想在一个构造器中调用另一个构造器，以避免重复代码。可以用this关键字做到这一点：123456789101112131415public class Person&#123; private String name; private String email; public Person(String name)&#123; // 如果传入参数与对象内部参数同名，需要使用this关键字加以区分 this.name = name; &#125; public Person(String name, String email)&#123; // 调用其他的构造器方法 this(name)； this.email = email; &#125;&#125;注意：构造器中调用构造器通过this(...)的方法，但该条语句必须是构造器的第一行代码。 static的含义**static（静态）方法是没有this的方法，在static方法内部不能调用非静态方法。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。**这实际正是static方法的主要用途。Java禁止全局方法，但你可以在类中置入static方法就可以访问其他static方法和static域（这句话我觉得有点问题）。1234567public class Person&#123; public static void sayHello()&#123; System.out.println(\"Hello world!\"); &#125;&#125;Person.sayHello();在上面的代码中，我们为Person类声明了一个sayHello()的静态方法。在外部，我们可以通过类名直接调用该方法，而不需要初始化该对象。 清理：终结处理和垃圾回收程序员常常忘记十分重要的清理工作。在使用程序时，把一个对象用完就“弃之不理”的做法是不安全的。当然，Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：假定你的对象（并非使用new创建）获得了一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存。为了应对这种情况，Java允许在类中定义一个名为finalize()的方法。finalize()的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。换言之，只有当“垃圾回收”发生时（不能保证一定会发生），finalize()才会得到调用。 finalize()用途何在不应该将finalize()作为通用的清理方法。请先记住下面这一点：垃圾回收只与内存有关：也就是说，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是finalize()方法），它们也必须同内存及其回收有关。之所以要有finalize()是由于分配内存时候可能采用了类似C语言的做法，而非Java中的通常做法。这种情况主要发生在使用**“本地方法”**的情况下，本地方法是一种在Java中调用非Java代码的方式。本地方法目前只支持C和C++，但它们可以调用其他语言的代码，所以实际上可以调用任何代码。 你必须实施清理要清理一个对象，用户必须在需要清理的时刻调用执行清理动作的方法。Java不允许创建局部对象，必须使用new创建对象。在Java中，也没有用于释放对象的delete，因为垃圾回收器会帮助你释放存储空间。但你现在需要知道垃圾回收器的存在并不能完全替代析折函数（而且绝对不能直接调用finalize（），这不是一种解决方案）。记住，无论是“垃圾回收”还是“终结”，都不一定保证会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存。 终结条件通常不能指望finalize()，必须创建其他的&quot;清理&quot;方法，并且明确调用它们。不过，finalize()还有一个有趣的用法，它并不依赖于每次都要对finalize()进行调用，这就是对象终结条件的验证。12345678910111213141516171819202122class Book&#123; boolean checkedOut = true; void checkIn()&#123; checkedOut = false; &#125; protected void finalize()&#123; if(checkedOut)&#123; throw new Exception(\"Error!\"); &#125; &#125; public static void main(String[] args)&#123; Book novel = new Book(); novel.checkIn(); // 忘记清理 new Book(); // 强制发生垃圾回收 System.gc(); &#125;&#125;所有的Book对象在被当作垃圾回收器前都应该被签入(check in)，在上面代码中的第二个Book对象未被签入，在发生垃圾回收时会导致异常错误。注意：System.gc()用于强制进行终止动作。 垃圾回收器如何工作在以前的程序语言中，在堆上分配对象的代价十分高昂。然而，垃圾回收器对于提高对象的创建速度，却具有明显的效果。这意味着，Java从堆分配空间的速度，可以和其他语言从堆栈上分配空间的速度相媲美。C里面的堆可以想象成一个院子，里面每个对象都负责管理自己的地盘。一段时间以后，对象可能会被销毁，但地盘必须加以重用。在某些Java虚拟机中，堆的实现截然不同：它更像一个传送带，每分配一个对象，它就往前移动一格。这就意味着对象存储空间的分配速度非常快。**Java的“堆指针”只是简单地移动到尚未分配的区域，其效率比得上C在堆栈上分配空间的效率。**但更重要的原因在于垃圾回收器的介入。当它工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样“堆指针”就可以很容易移动到更靠近传送带的开始处，也就尽量避免了页面错误。通过垃圾回收器对对象重新排列，实现了一种高速的、有无限空间可供分配的堆模型。 如何寻找垃圾引用计数是一种简单但速度很慢的垃圾回收技术。每个对象都含有一个引用计数器，当有引用连接到对象时，引用计数加1。当引用离开作用域或者置为null时，引用计数减1。垃圾回收器会在含有全部对象的列表上遍历，当发现某个对象的引用计数为0时，就释放其占有的空间。这种方法有个缺陷，如果对象之间存在循环引用，可能会出现“对象应被回收，但引用计数却不为零”的情况。如下面的代码所示：123456789101112131415class Teacher&#123; Student student;&#125;class Student&#123; Teacher teacher;&#125;class Test&#123; public static void main(String[] args)&#123; // 两个对象循环引用 Teacher teacher = new Teacher(); Student student = new Student(); teacher.student = student; student.teacher = teacher; &#125;&#125;在一些更快的模式，垃圾回收器使用可达路径，依据的思想是：对任何“活”对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。这条引用链条可能会穿过数个对象层次。由此，如果从堆栈和静态存储区开始，遍历所有的引用，就能找到所有“或的对象”。对于发现的每个引用，必须追踪到它所引用的对象，然后是此对象包含的所有引用，如此反复进行，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。在这种方式下，Java虚拟机将采用一种自适应的垃圾回收技术。 如何处理垃圾如何处理找到的存活的对象，取决于不同的Java虚拟机的实现。有一种做法叫做停止-复制（stop-and-copy）。显然这意味着，先暂停程序的运行（所以这不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有复制的全部都是垃圾。当对象复制到新堆时，它们是一个挨着一个的，所以新堆保持紧凑排列。当把对象从一处搬到一处时，所有指向它的那些引用都必须修正。位于堆或静态存储区的引用可以直接修正，但可能还有其他指向这些对象的引用，它们在遍历过程中才能被找到（可以想象有个表格，将旧地址映射到新地址）。对于这种“复制式回收器”而言，效率会降低。这有两个原因：首先，得有两个堆，然后得在这两个分离的堆上来回折腾，从而维护比实际需要多一倍的空间。某些Java虚拟机对此处理的方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块的内存之间。第二个问题在于复制。程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。此时复制回收器仍将会将所有内存自一处复制到另一处，这很浪费。为了避免上述情形，一些Java虚拟机会进行检查：要是没有新垃圾产生，就会自适应转换到另一种工作模式：标记-清扫（mark-and-sweep）（Sun公司早期版本的Java虚拟机使用该技术）。标记-清扫所依据的思路是：从堆栈和静态存储区出发，遍历所用引用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象设一个标记，这个过程不会发生任何回收对象。只有当所有标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将会被释放，不会发生复制动作。所以剩下的堆空间是不连续的。垃圾回收器如果希望得到连续空间的话，就得重新整理剩下的对象。 自适应技术如前文所述，在这里所讨论的Java虚拟机中，内存分配以较大的**“块”**为单位。如果对象较大，它会占用单独的块。严格来说，“停止-复制”要求在释放旧有对象之前，必须先把所有存活对象从旧堆复制到新堆。有了块之后，垃圾回收器在回收的时候就可以往废弃的块里拷贝对象。每个块有相应的**代数（generation count）**来记录它是否还存活。通常，如果块在某处被引用，其代数会增加；垃圾回收器会定期进行完整的清理动作–大型对象仍然不会被复制（只是其代数会增加），内含小对象的那些快则被复制斌整理。自适应技术：Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低，就会切换到“标记-清扫”方式。同样，Java虚拟机会跟踪“标记-清扫”的效果，如果堆里面出现很多碎片，就会切换为“停止-复制”方式。可以给一个罗嗦的称呼：“自适应的、分代的、停止-复制、标记-清扫”式垃圾回收器。 即时编译技术Java虚拟机有许多附加技术用以提升速度。尤其是与加载器操作有关的，被称为即时编译器技术（Just-In-Time，JIT）。这种技术可以把程序全部或部分翻译成本地机器码（这本来是Java虚拟机的工作），程序运行速度因此得到提升。当需要装载某个类（通常是在为该类创建第一个对象时），编译器为找到其.class文件，然后将该类的字节码装入内存。此时有两种方案可供选择：一是让即时编译器编译所有代码。但存在以下两种缺陷：加载动作散落在整个程序生命周期内，累加起来花更多时间；增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），将导致页面调度，从而降低程序速度二是惰性评估（lazy evaluation），意思是即时编译器只在必要的时候才编译代码。这样从不会被执行的代码也许就压根不会被JIT所编译。新版JDK中的Java HotSpot技术采用了类似方法，代码每次被执行都会做一些优化，所以执行次数越多速度就越快。 成员初始化所有变量在使用前都应得到恰当的初始化。对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。唯一有点例外的是，类的每个基本类型数据成员保证都会得到一个初始值。数据类型初始值booleanfalsechar0byte0short0int0long0float0.0double0.0referencenull 构造器初始化可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初值，这让编程变得更灵活。但需要注意：无法阻止自动初始化的进行，它将在构造器被调用前发生。123456class Test&#123; int i; test()&#123; i = 1; &#125;&#125;代码解读：变量i会先被初始化为0，再赋值为1。 初始化顺序在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。 静态数据的初始化无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准值；如果它是一个对象引用，那么它的默认初始值就是null。静态初始化只有在必要时刻才会进行，只有在第一个类对象被创建（或第一次访问静态数据）时候，它们才会被初始化。此后，静态对象不会再次被初始化，每次引用的都是同一个对象。初始化的顺序是先静态对象，而后是“非静态”对象。 显式的静态初始化Java允许将多个静态初始化动作组织成一个特殊的“静态子块”（也可称为“静态代码块”）。如：123456class Teacher&#123; static Student student; static&#123; student = new Student(); &#125;&#125; 非静态实例初始化Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量。例如：12345678public class Mugs&#123; Mug mug1; Mug mug2; &#123; mug1 = new Mug(); mug2 = new Mug(); &#125;&#125;这种语法对于支持**“匿名内部类”**的初始化时必须的，但是它也使得你可以保证无论调用哪个显式构造器，某些操作都会发生。这个代码块也是会在调用构造器执行。 数组初始化**数组是相同类型、用一个标识符名称封装到一起的一个对象序列或基本数据类型序列。**数组是通过方括号下标操作符[]来定义和使用的。要定义一个数组，只需在类型名后加上一对空括号即可：1234int[] a1;// 实际上也可以将方括号放在变量名后int a2[];// 但是后面这种方式不利于识别是一个数组对于数组，你不能直接在引用上指定大小。为了给数组创建相应的存储空间，必须写初始化表达式。对于数组，初始化动作可以出现在代码的任何地方，但也可以用一种特殊的初始化表达式，它必须在创建数组的地方出现。这种特殊的初始化是由一对花括号{}括起来的值组成。在这种情况下，存储空间的分配（等价于使用new）将由编译器负责。例如：1234// 直接给数组赋int[] a1 = &#123;1,2,3,4,5&#125;;// 开辟一个大小为5的int数组int[] a2 = new int[5];所有数组（无论它们的元素是对象还是基本类型）都有一个固定成员–length，可以通过它获知数组内包含了多少元素，但不能对其修改。与C和C++类似，Java数组计数也是从第0个元素开始，所以能使用的最大下标数是length-1。一旦你访问下标越界，就会出现运行时错误（异常，indexOfBoundException）。 可变参数列表JAVA SE5提供了一种方便的语法来创建对象并调用方法，以获得与C的**可变参数列表（varages）**一样的效果。这可以应用于参数个数或类型未知的场合。由于所有的类都直接或间接继承于Object类。123456789void printArray(Object... objects)&#123; for(Object object:objects)&#123; System.out.println(object); &#125;&#125;public static void main(String[] args)&#123; printArray(new Integer(47), new Float(3.4), new Double(11.11))&#125;打印一个类只会出现类的名称以及后面紧接着一个@符号以及多个十六进制数字，因为默认行为（没有定义toString()方法）就是打印类的名字和对象的地址。有了可变参数，就不用再显式地编写数组方法了，当你指定参数的时候，编译器实际上会为你去填充数组。获取的仍旧是一个数组。如果该参数列表中没有任何元素，那么转变成的数据的尺寸为0。 枚举类型在Java SE5中添加了一个看似很小的特性，即enum关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便的处理。在此之前，你需要创建一个静态常量集，但是这些枚举值并不会必然地将其自身的取值限制在这个常量集的范围之内，因此显得更有风险，且难使用。枚举的出现正是为了解决这个问题。123public enum Spiciness&#123; NOT,MILD,MEDIUM,HOT,FLAMING;&#125;上述的代码创建了一个名为Spiciness的枚举类型，它具有5个具名值。由于枚举类型的实例是常量，因此按照命名惯例都用大写字母表示。当你创建enum时，编译器会自动添加一些有用的特性。例如，它会创建toString()方法，以便你可以很方便地显示某个enum实例的名字。编译器还会创建ordinal()方法，用来表示某个特定的enum常量的声明顺序；以及static values()方法，用来按照enum常量声明顺序，产生由这些常量值构成的数组。123456789101112131415public class EnumTest&#123; public static void main(String[] args)&#123; for(Spiciness s:Spiciness.values())&#123; System.out.println(s + \"：\" + s.ordinal()); &#125; &#125;&#125;/** output:* NOT:0* MILD:1* MEDIUM:2* HOT:3* FLAMING:4*/尽管enum看起来像是一种新的数据类型，但是这个关键字只是为enum生成对应类时，产生了某些编译器行为，因为你可以将enum当作一般的类来处理，只是具有某些特别的方法。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"04-控制执行流程","slug":"Java编程思想/04-控制执行流程","date":"2020-05-25T15:12:36.000Z","updated":"2020-05-25T15:16:23.834Z","comments":true,"path":"Java编程思想/04-控制执行流程/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/04-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/","excerpt":"","text":"程序必须在执行过程中控制它的世界，并做出选择。在Java中，涉及的关键字包括：if-else,while,do-while,for,return,break以及选择语句switch。goto不做介绍。 true和false所有条件语句都利用条件表达式的真或假来决定执行路径。即若条件表达式为真时，执行该条件语句的代码块；若为假，则不执行。注意：Java不允许我们将一个数字作为布尔值使用，虽然这在C和C++里允许。 if-elseif-else语句是控制程序流程的最基本形式。其中else是可选的，所以可按下述两种形式来使用if：123456789if(Boolean-expression)&#123; statement;&#125;if(Boolean-expression)&#123; statement;&#125;else&#123; statement;&#125;布尔表达式必须产生一个布尔结果，statement指用分号结尾的简单语句，或复合语句（封闭在花括号内的一组简单语句）。在中间可以看到一个或多个else if，那并非新的关键字，而仅仅只是一个else后面紧跟另一个新的if语句。1234567if(Boolean-expression)&#123; statement;&#125;else if(Boolean-expression)&#123; statement;&#125;else&#123; statement;&#125; 迭代while、do-while和for用来控制循环，有时也将它们划分为迭代语句（iteration statement）。代码块会重复执行，直到起控制作用的**布尔表达式（Boolean Expression）**得到“假”的结果为止。while循环的格式如下：123while(Boolean-expression)&#123; statement;&#125;在循环刚开始时，会计算一次布尔表达式的值；而在代码块的下一次迭代开始前会在计算一次。 do-whiledo-while的格式如下：123do&#123; statement;&#125;while(Boolean-expression);while和do-while唯一的区别是do-while中的语句至少会执行一次，即便布尔表达式第一次就被计算为false。但在实际应用中，while更常用一些。 forfor循环可能是最经常使用的迭代形式，这种在第一次迭代之前要进行初始化。随后它会进行条件测试。而且在每一次迭代结束时，进行某种形式的“步进”。for循环的格式如下：123for(initialization;Boolean-expression;step)&#123; statement;&#125;初始化(initialization)、布尔表达式（BooleanExprssion）、步进（step）运算都可以为空。每次迭代前都会测试布尔表达式。若获得的结果是true就执行代码块内语句。每次循环结束，会执行一次步进。下面以在一个数组内遍历寻找一个数为例：12345678// 在数组中寻找到数字3,并返回其下标int[] arr = new int[]&#123;1,2,3,4,5&#125;;for(int i=0;i&lt;arr.length;i++)&#123; if(arr[i] == 3)&#123; return i; &#125;&#125;return -1; 逗号操作符Java里唯一用到逗号操作符的地方就是for循环的控制表达式。在控制表达式的初始化和步进控制部分，可以使用一系列由逗号分隔的语句，而且那些语句均会被独立执行。通过使用逗号操作符，可以在for语句内定义多个变量，但是它们必须具有相同的类型。1234for(int i=1,j=j+10;i&lt;5;i++,j=i*2)&#123; System.out.println(\"i=\" + i); System.out.println(\"j=\" + j);&#125;在初始化部分可以拥有任意数量的具有相同类型的变量定义，这种能力只限于for循环，在其他任何选择或迭代语句中都不能使用这种方式。 Foreach语句Java SE5引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。假如拥有一个float数组，我们要选取该数组中的每一个元素：1234float[] arr = new float[]&#123;1.0f, 1.1f, 1.2f, 1.5f&#125;;for(float f:arr)&#123; System.out.println(f);&#125;上面的语句定义了一个float类型的变量f，继而将每一个arr的元素赋值给f。 return在Java中有多个关键词表示无条件分支，它们只是表示这个分支无需任何测试即可发生，这些关键词包括return、break、continue。return关键词有两方面的用途：一方面指定一个方法返回什么值，另一方面会导致当前的方法退出，并返回那个值。 break和continue在任何迭代语句的主体部分，都可以用break和continue控制循环的流程。其中，break用于强行退出循环，不执行剩下的循环。而continue则停止执行当前的迭代，不再执行当前循环剩下的语句而马上开始下一次循环。无尽循环有两种方式：while(true)和for(;;)，对于这两者只有通过break语句才能退出循环。注意：break会中断for循环，而且在抵达for循环的末尾之前，递增表达式不会执行。其实Java中存在着带标签的continue和break，但并不提倡使用这种语法，故不在此记录。 switchswitch有时也被划分为一种选择语句，选择使用其的原因一般是因为if-else if的结构十分复杂，这时我们选择使用switch来替代它，来使我们的程序结构更加清晰明了。switch语句可以从一系列的代码中选出一段去执行，它的格式如下：1234567891011121314switch(selector)&#123; case value1: statement; break; case value2: statement; break; case value3: statement; break; default: statement; break;&#125;在上面的代码中，会根据输入进来的selector去与我们定义的value比较，找到相等的case开始执行语句。一般来说，每个case均以一个break语句结尾，这样可使执行流程跳转至switch主体的末尾。但break是可选的，若省略break会继续执行后面的case语句，直到遇到一个break或走到switch的末尾为止。switch语句是实现多路选择的一种干净利落的方法，但它要求使用一个选择因子，并且必须是int或char那样的整数值（在Java SE7时String类型也被支持了）。 臭名昭著的goto编程语言一开始就有goto关键词。事实上，goto起源于汇编语言的程序控制：“若条件A成立，则跳到这里；否则跳到哪里”。如果阅读由编译器最终生成的汇编代码，就会发现程序控制里包含了许多跳转。注：Java编译器生成自己的“汇编代码”，但是这个代码运行在Java虚拟机上的，而不是直接运行在CPU硬件上。goto语句是在源码级上的跳转，这使得很难识别程序的控制流程。尽管**goto仍是Java中的一个保留字**，但在语言中并未使用它，即Java没有goto。然而，Java也能完成一些类似于跳转的操作，这与break和continue这两个关键词有关。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"03-操作符","slug":"Java编程思想/03-操作符","date":"2020-05-25T15:10:54.000Z","updated":"2020-05-25T15:16:20.460Z","comments":true,"path":"Java编程思想/03-操作符/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/03-%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"在最底层，Java中的数据是通过使用操作符来操作的。 使用Java操作符操作符接受一个或多个参数，并生成一个新值。参数的形式与普通的方法调用不同，但效果是相同的。加号和一元的正号（+）、减号和一元的负号（-）、乘号（*）、除号（/）以及赋值号（=）的用法与其他编程语言类似。几乎所有操作符都只能操作“基本类型”。例外的操作符是“=”、“==”、和“！=”，这些操作符能操作所有对象。除此之外，String类支持“+”和“+=”，这是通过重载操作符来实现的。需要说明的是，Java的底层C++语言支持由程序员重载操作符，但Java是不支持这一特性的，String是个唯一的特例。 优先级当一个表达式中存在多个操作符时，操作符的优先级就决定了各部分的计算顺序。其中，最简单的规则就是先乘除和加减，也可以使用括号来明确规定计算顺序。 赋值赋值使用操作符“=”，它的意思是“取右边的值复制给左边”。右值可以是任何常数、变量和表达式（只要它能生成一个值就行）。但左值必须是一个明确的、已命名的变量。也就是说，必须有一个物理空间可以存储等号右边的值。但是不能把任何东西赋给一个常数，即常数不能作为左值（4=a）。对于基本类型的赋值，是直接将一个地方的内容复制到了另一个地方。而为对象赋值时，实际是将引用从一个地方复制到了另一个地方。 算数操作符Java的基本算术操作符与其他大多数程序设计语言是相同的。其中包括加号（+）、减号（-）、除号（/）、乘号（*）以及取模操作符（%，它从整数除法中产生余数）。整数除法会直接去掉结果的小数位（相当于向下取整），而不是四舍五入地圆整结果。 一元加、减操作符一元减号（-）和一元（+）与二元减号和加号使用相同的符号。根据表达式的书写形式，编译器会自动判断出是哪一种。例如：1x = -a;一元减号用于转变数据的符号，而一元加号只是为了与一元减号相对应，但是它唯一的作用仅仅是将较小类型的操作数提升为int。 自动递增和递减递增和递减运算是两种相当不错的快捷运算（吐槽一下python，并不支持此语法）。其中，递减操作符是--，意为减少一个单位；递增操作符是++，意为增加一个单位。这两个操作符各有两种使用方式，通常被称为**“前缀式”和“后缀式”**。对于前缀递增、减（如++a），会先改变值，再执行运算；而后缀递增、减（如a--），会先执行运算，再改变值。*一些注释:*在C++中前缀递增、减与后缀递增、减是有效率区别的，前缀会比后缀效率高20%（没记错的话，以前看过一篇博客分析）。但是在Java中，如果你是用的后缀与前缀是等价的，会自动帮你转化为前缀表达式以提高效率（这一点也忘了在哪里瞎看到的）。 关系操作符关系操作符生成的是一个boolean布尔结果，它们计算的是操作数值之间的关系。如果关系是真，关系表达式会生成true；否则，则生成false。关系操作符包括小于(&lt;)、大于(&gt;)、小于等于(&lt;=)、大于等于(&gt;=)、等于(==)以及不等于(!=)。等于和不等于适用于所有数据类型，而其他比较符适用于除boolean类型之外的所有基本数据类型。 ==和equals的区别对于==运算符：基本类型：比较的是值是否相同引用类型：比较的是引用是否相同1234567String x = \"string\";String y = \"string\";String z = new String(\"string\");System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true代码解读：当你使用String s = &quot;a&quot;这种形式生成字符串时，会先检索方法区中的字符串常量池是否已经存在一个这样的对象，如果存在则返回该对象的引用；若不存在，则创建一个字符串对象并将其放入字符串常量池中。所以上述代码中的变量x和y实际上指向了同一个引用。而使用关键字new则会每次都申请内存空间创建一个新的对象。对于equals方法，其本质上就是==，只不过String和Integer等重写了该方法，把它变成了值比较。因为，equals是一个方法，只有对象具有方法，所以其默认情况是引用比较。但许多类都重写了equals方法，所以一般情况下其比较的是值是否相等。 逻辑操作符逻辑操作符**“与”（&amp;&amp;）、“或”（||）、“非”（！）**能根据参数的逻辑关系，生成一个布尔值（true或false）。与、或、非操作只可应用于布尔值。### 短路当使用逻辑操作符时，我们会遇到一种短路现象。即一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下的部分。因为，逻辑表达式靠后的部分有可能不会被运算。121. a||b2. a&amp;&amp;b代码解读：在式子1中，如果a为true，那么b就不会被计算，因为该表达式必定为真；在式子2中，如果a为false，那么b也不会被计算，因为该表达式必定为假。 直接常量如果在程序里使用了直接常量，需要对编译器加以适当的指导，用与直接常量相关的某些字符来额外增加一些信息。直接常量的后缀字符标志了它的类型。若为大写（或小写）的L，代表Long（尽量使用大写，因为小写的l看起来像数字1，容易造成混淆）；大小（或小写）字母F，代表float；大写（或小写）字母D，则代表double。十六进制数适用于所有整数数据类型，以前缀0x或(0X)，后面跟随0-9或小写（大写）的a-f来表示。如果试图将一个变量初始化成超出自身范围的值，编译器都会向我们报告一条错误信息。八进制由前缀0以及后续的0-7的数字来表示。在C、C++和Java中，二进制数没有直接常量表示方法。但是在使用十六进制和八进制计数法时，以二进制形式显示结果将非常有用。通过使用Integer和Long类型的静态方法toBinaryString()可以很容易实现这一点。1234567int i1 = 0x2f; // Hexadecimalint i2 = 0177; // Octal(leading zero)char c = 0xffff; // max char hex valuebyte b = 0x7f; // max byte hex valuelong n1 = 200L;float f1 = 1F;double d1 = 1D; 指数计数法Java采用了一种很不直观的计数法来表示指数，例如：1float f = 1.39e-43f;上面的变量f表示1.39×10−431.39 \\times 10^{-43}1.39×10−43。编译器通常会把指数作为双精度（double）处理，所以上述代码如果没有这个尾随的f，就会收到一条出错信息。 按位操作符按位操作符用来操作整数基本类型中的单个**“比特”（bit）**，即二进制位。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。按位操作符来源于C语言面向底层的操作，在这种操作中经常需要直接操纵硬件，设置硬件寄存器内的二进制位。如果两个输入位都是1，则按位**“与”操作（&amp;）**生成一个输出位1；否则生成一个输出位0。如果两个输入位只要一个是1，则按位**“或”操作（|）**生成一个输出位1；只有在两个输入位都是0的情况下，“或”操作才会生成一个输出位0。如果输入位的某一个是1，但不全是1，那么按位**“异或”操作（^）**生成一个输出位1。按位**“非”（~）**，也称取反操作符，它属于一元操作符，只对一个操作数进行操作。“非”操作生成与输入位相反的值–若输入0，则输出1；若输入1，则输出0。按位操作符可与等号（=）联合使用，以便合并运算和赋值：&amp;=、|=、^=都是合法的。由于~是一元操作符，故不能与“=”号联合使用。布尔类型作为一种单比特值对待，可以对其执行按位“与”（&amp;）、按位“或”（|）和按位“异或”（^）运算，但不能执行按位“非”。对于布尔值，按位操作符具有与逻辑操作符相同的效果，只是它们不会中途“短路”。 移位操作符移位操作符操作的运算对象也是二进制的“位”，移位操作符只可以用来处理整数类型。**左移位操作符（&lt;&lt;）**能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）。左移1位相当于乘以2，所以说计算5*8，最快的方法应该是将5向左移动三位5&lt;&lt;3。**“有符号”右移位操作符（&gt;&gt;）**则按照操作符右侧指定的位数将操作符左边的操作数向右移动。“有符号”右移位操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1。Java中增加了一种**“无符号”右移位操作符（&gt;&gt;&gt;）**，它使用“零扩展”：无论正负，都在高位插入0.*注意：*如果对char、byte或者short类型的数值进行移位处理，那么在移位进行之前，它们会被转换为int类型的值，并且得到的结果也是一个int类型的值。只有数值右端的低5位有用。这样防止移位超过int类型值所具有的位数（因为25=322^5=3225=32，int类型只有32位）。若对一个long类型的数值进行处理，最后得到结果也是long此时只会用到数值右端的低6位。“移位”可与“等号”组合使用（&lt;&lt;=或&gt;&gt;=或&gt;&gt;&gt;=）。此时，操作符左边的值会移动由右边的值指定的位数，再将得到的结果赋给左边的变量。12345678int i = -1;i &gt;&gt;&gt;= 10;system.out.println(i);long l = -1;l &gt;&gt;= 3;system.out.println(l);l &lt;&lt;= 2;system.out.println(l); 三元操作符 if-else三元操作符也称为条件操作符，因为它有三个操作数；但它确实属于操作符的一种，因为它最终也会生成一个值。1boolean-exp?value0:value1;如果boolean-exp的结果为true，就计算value0，而且这个计算结果也就是操作符最终产生的值；若为false，就计算value1，同样它的结果也就成为操作符最终产生的值。 字符串操作符+和=这个操作符在Java中有一项特殊用途：连接不同的字符串。这项功能用在C中似乎是个不错的主意，所以引入了**操作符重载（operator overloading）**机制，以便C程序员可以为几乎所有操作符增加功能。但操作符重载是一种非常复杂的特性，程序员在设计自己的类时必须对此有周全的考虑。尽管操作符重载在Java这种更容易实现，但Java程序员不能像C++和C#程序员那样实现自己的重载操作符。如果表达式以一个字符串起头，那么后续所有操作数必须都是字符串型。请记住，编译器会把双引号内的字符序列自动转换为字符串。1234int x = 0, y = 1, z = 2;String s = \"x, y, z\";system.out.println(s);system.out.println(s + x + y +z); 使用操作符时常犯的错误第一个常犯的错误是：即使对表达式如何计算有点不确定，也不愿意使用括号。此外，一个常犯的错误如下：123while(x = y)&#123; // ...&#125;程序员明显是想测试是否“相等”（==），而不是进行赋值操作。在Java中，这个表达式的结果并不是布尔值，而编译器期望的是一个布尔值。Java不会自动地将int数值转换成布尔值，所以在编译时抛出一个编译时错误，从而阻止进一步运行这个程序。而在C和C++中，编译器会将int数值转换成布尔值（非0为true，0为false）。 类型转换操作符类型转换（cast）：Java会将一种数据类型自动转换成另一种。例如为某浮点数变量赋一个整数值，编译器为将int自动转换为float。类型转换运算允许显式地进行这种类型的转换，或者在不能自动进行转换的时候强制进行类型转换。要想执行类型转换，需要将希望得到的数据类型置于圆括号()内，并放在要进行类型转换的值左边。12int i = 100;long l = (int)i;在C和C++中，类型转换有时会让人头疼。但是在Java中，类型转换则是一种比较安全的操作。窄化转换（narrowing conversion）：将能容纳更多信息的数据类型转换为无法容纳那么多信息的类型，可能会导致信息丢失。扩展转换（widening conversion）：不必显式地进行类型转换，因为新类型肯定能容纳原来类型的信息，不会造成任何信息的丢失。Java允许把任何基本数据类型转换成其他的基本数据类型，但布尔型除外，后者不允许进行任何类型的转换处理。“类”数据类型不允许进行类型转换，为了将一种类转换成另一种，必须采用特殊的方法。 截尾和舍入在执行窄化转换时，必须注意截尾和舍入问题。123float f = 29.7;int i = (int)f;system.out.println(i); // 29将float或double转型为整型值时，总是对该数字执行截尾。如果想要得到舍入结果，需要使用java.lang.Math.round()方法。 提升如果对基本数据类型执行算术运算或按位运算，大家会发现，只要类型比int小（即char,byte,short），在运算前，这些值会自动转换为int。如果想要把结果赋值给较小的类型，就必须使用类型转换。通常，表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。 Java没有sizeof在C和C++中，sizeof()操作符可以告诉你为数据项分配的字节数。sizeof()最大的用处是为了移植，因为不同的数据类型在不同的机器上可能有不同的大小。Java不需要sizeof()操作符，因为所有的数据类型在所有机器中的大小都是相同的，它已经被设计在语言中。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"02-一切都是对象","slug":"Java编程思想/02-一切都是对象","date":"2020-05-25T14:54:04.000Z","updated":"2020-05-25T16:13:20.277Z","comments":true,"path":"Java编程思想/02-一切都是对象/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"Java是基于C++的，但是相比之下，Java是一种更纯粹的面向对象程序设计语言。 用引用操纵对象每种编程语言都有自己的操纵内存中元素的方式。在Java中，一切都被视为对象，因此可采用固定单一的语法。尽管一切都看作对象，但操纵的标识符实际是对象的一个“引用”（reference）。可以将这一情形想象成用遥控器（引用）来操纵电视机（对象）。引用可以独立存在，但在操纵时会返回错误，因为其没有与一个具体的对象绑定，如下面的代码所示：12String s; &#x2F;&#x2F; 这声明了一个字符串引用s.length(); &#x2F;&#x2F; 编译会错误 必须由你创建所有对象一旦创建一个引用，就希望它能与一个新的对象相关联。通过用new操作符来实现这一目的。new关键字意思是“给我一个新对象”。1String s = new String(\"hello world!\");Java提供了大量过剩的现成类型。重要的是，你可以自行创建类型。 存储到什么地方程序运行时，有五个不同的地方可以存储数据:寄存器：这是最快的存储区，因为它位于不同于其他存储区的地方–处理器内部。但寄存器数量极其有限，所以寄存器根据需求怎么分配。堆栈：位于通用RAM（随机访问存储器）中，通过堆栈指针可以从处理器那里直接获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方式，仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。某些Java数据存储在堆栈中–特别是对象引用，但是Java对象并不存储于其中。堆：一种通用的内存池（也位于RAM区），用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当需要一个对象时，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。灵活性的代价是：用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间。常量存储：常量值通常直接存放在程序代码内部。非RAM存储：如果数据完全存活在程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是流对象和持久化对象。这种存储方式的技巧在于：把对象转换成可以存放在其他媒介上的食物，在需要时可恢复成常规的、基于RAM的对象。Java提供了对轻量级持久化的支持。 补充：Java的内存模型首先回顾一下Java程序的执行流程：如上图所示，首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件。加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area （运行时数据区），也就是我们常说的JVM内存。因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。根据JVM规范，JVM内存共分为五个部分：虚拟机栈堆方法区程序计数器本地方法栈 特例：基本类型在程序设计中经常用到一系列类型，它们需要特殊对待。因为new将对象存储在堆里，故用new创建一个对象–特别是小的、简单的变量，往往不是很有效。因此对于基本类型，Java采取与C和C++相同的方法。也就是不用new来创建变量，而是创建一个并非是引用的“自动”的变量。这个变量直接存储值，并置于堆栈中，因此更加高效。基本类型大小最小值最大值包装器类型boolean---Booleanchar16-bitUnicode oUnicode 216−12^{16}-1216−1Characterbyte8 bits−128-128−128+127+127+127Byteshort16 bits−215-2^{15}−215+215−1+2^{15}-1+215−1Shortint32 bits−231-2^{31}−231+231−1+2^{31}-1+231−1Integerlong64 bits−263-2^{63}−263+263−1+2^{63}-1+263−1Longfloat32 bitsIEEE 754IEEE 754Floatdouble64 bitsIEE 753IEEE 754Doublevoid---Void所有数值类型都有正负号，所以不要去寻找无符号的数值类型。boolean类型所占的存储空间大小没有明确规定，仅定义为能够取字面值true或false。Java SE5的自动包装功能将自动地将基本类型转换为包装器类型，并可以反向转换。 高精度数字Java提供了两个用于高精度计算的类：BigInteger和BigDecimal。这两个类包含的方法，提供的操作与对基本类型所能执行的操作相似。也就是说，能作用于int和float的操作，也同样能应用在BigInteger和BigDecimal`，只不过必须以方法调用方式取代运算符来实现。BigInteger支持任意精度的整数。也就是说，在运算中，可以准确地表示任意大小的整数值，而不丢失任何信息。BigDecimal支持任意精度的定点数，例如，可以用它来进行精确的货币计算。 永远不需要销毁对象在大多数程序设计语言中，变量生命周期的概念，占据了程序设计工作非常重要的部分。Java帮助我们大大简化了这个问题。 作用域大多数过程语言都有**作用域（Scope）**的概念。作用域决定了其内定义的变量名的可见性和生命周期，作用域由花括号{}的位置决定。在作用域里定义的变量只可用于作用域结束之前。且在Java中，较大作用域的变量不会“隐藏”，故较小作用域中不能定义与较大作用域同名的变量。 对象的作用域Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。假如你编写了下述代码：123&#123; String s = new String(\"hello world!\");&#125;引用s在作用域终点就消失了。然而s指向的String对象仍继续占据内存空间。事实证明，由new创建的对象，只要你需要，就会一直保留下来。同时，Java有一个垃圾回收器，用来监视new创建的对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以供新的对象使用。就是说，程序员不用关心内存回收的问题。Java从天然上隔绝了内存泄漏。 创建新的数据类型：类如果一切都是对象，那么是什么决定了某一类对象的外观与行为呢？大多数面向对象的程序设计语言习惯用关键字class来表示“我准备告诉你一种新类型的对象看起来像什么样子”。1class ATypeName &#123;/* Class body goes here */&#125;这就引入了一种新的类型了，然后你已经可以用new来创建这种类型的对象。 字段和方法一旦定义了一个类，就可以在类中设置两种类型的元素：字段（有时称为数据成员）和方法（有时称为成员函数）。字段可以是任何类型的对象，可以通过其引用与其进行通信；也可以是基本类型中的一种。每个字段都有用来存储其字段的空间；普通字段不能在对象中共享。基本成员默认值：基本类型默认值booleanfalsechar'\\uooooo'(null)byte(byte)oshort(short)ointolongoLfloato.ofdoubleo.od若类的某个成员是基本数据类型，即使没有初始化，Java也会确保它获得一个默认值，以确保那些是基本类型的成员变量得到初始化，防止产生程序错误。提醒：最好明确地对变量进行初始化。 方法、参数和返回值Java的方法决定了一个对象能够接收什么样的消息。方法的基本组成部分包括：名称参数返回值方法体下面是它最基本的形式：123ReturnType methodName(/* Argument list */)&#123; /* Method Body */&#125;返回类型描述的是在调用方法之后从方法返回的值。参数列表给出了要传给方法的信息的类型和名称。方法名和参数列表（它们合起来被称为**“方法签名”**）唯一地标识出某个方法。**Java中的方法只能作为类的一部分来创建，方法只有通过对象才能被调用，且这个对象必须能执行这个方法调用。**通过这个对象调用方法时，需要先列出对象名，紧接着是句点，然后和方法名和参数列表。1objectName.methodName(arg1, arg2, arg3); 参数列表方法的参数列表指定要传递给方法什么样的信息。这些信息如Java中的其他信息一样，采用都是对象的形式。因此，在参数列表必须指定每个所传递对象的类型及名字，这里的传递实际上也是引用。疑问：Java中的参数传递不是副本拷贝吗？正如你把一个对象A传递进方法f(A)，在方法中对A进行操作，并不会影响外部的A的值。在方法体中，可以使用return关键字进行值的返回。当然，如果你的方法返回类型为void的时候，可以不返回任何值，并且通过return;语句，在程序中随时退出方法。 构建第一个Java程序 名字可见性名字管理对任何程序设计语言来说，都是一个重要问题。如果在程序的某个模块使用了一个名字，而其他人的程序的另一个模块也使用了相同的名字，那么怎样区分这两个名字并防止二者相互冲突呢？Java采用了一种全新的方法来解决上述问题。为了给一个类库生成不会与其他名字混淆的名字，Java设计者希望程序员放过来使用自己Internet域名，因为这样可以保证它们肯定是独一无二的。例如：cn.hengxin，这个将域名进行了反转，句点就用来代表子目录的划分。一般来说，这被称为包，建议包名采用全小写的形式。这种机制意味着所有的文件都能自动存活在它们自己的名字空间中，而且同一个文件内每个类都有唯一的标识符–类名。 运用其他构件如果想在自己程序里使用预先定义好的类，那么编译器就必须知道怎么定位它们。当然，这个类可能就在发出调用的源文件中；在这种情况下，就可以直接使用这个类–即使这个类在文件的后面才会被定义。Java消除了所谓的**“向前引用”**问题。例如，C语言在调用一个函数时，这个函数必须在调用语句前被定义。为了消除所有可能的混淆情况，可以使用关键字import来准确地告诉编译器你想要的类是什么。import指示编译器导入一个包，也就是一个类库。1import java.util.ArrayList;如果你想使用Java的util包下数量众多的类，又不想逐一声明，那么可以使用通配符*来达到这个目的：1import java.util.*;当然，现代的IDE一般都会存在提示或者自动导入包的机制，因此你并不需要记住这个类来自于那个包，仅需在IDE提示你的时候进行判断选择就可以了。在eclipse中，我们可以使用crtl+shift+O进行包的自动导入，如果存在混淆的情况，eclipse将会要求你进行选择导入那个包以匹配正确的类 static关键字通常来说，除非用new创建类对象，否则实际上并未获得任何对象。执行new来创建对象时，数据存储空间才被分配，其方法才供外界调用。但是，当使用static关键字去修饰一个字段或者方法时，就意味着这个域不会与包含它的类的任何对象实例关联起来。所以，即使从未创建某个类的任何对象，也可调用其static方法或者访问其static域。1234567class ATest&#123; static int i=0; static void increment()&#123; ATest.i++; &#125;&#125;","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"01-对象导论","slug":"Java编程思想/01-对象导论","date":"2020-05-25T12:21:35.000Z","updated":"2020-05-25T13:01:20.295Z","comments":true,"path":"Java编程思想/01-对象导论/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"计算机革命起源于机器，因此，编程语言的产生也始于对机器的模仿。但是计算机并非只是机器那么简单，计算机是头脑延伸的工具。**面向对象程序设计（Object-oriented Programming，OOP）**是以计算机作为表达媒体的大趋势中的组成部分。 抽象过程所有的编程语言都提供抽象机制，人们所能够解决的问题的复杂性直接取决于抽象的类型与质量。汇编语言是对底层机器的轻微抽象。接着出现的许多所谓的“命令式”语言（如FORTRAN、BASIC、C等）都是对汇编语言的抽象。它们所作的主要抽象仍要求在解决问题时要基于计算机的结构，而不是基于所要解决的问题的结构来考虑。另一种对机器建模的方式就是只针对待解问题建模。早期的编程语言，如LISP和APL，都选择考虑世界的某些特定视图（分别对应于**“所有问题最终都是列表”或者“所有问题都是算法形式的”**）。这些方式对需要解决的特定类型的问题都是不错的解决方案，但一旦超出其特定领域，就会显得力不从心。面向对象方式通过向程序员提供表示问题空间中的元素的工具。这种表示方式非常通用，使程序员不会受限于任何特定类型的问题。我们将问题空间中的元素及其在解空间中的表示称为**“对象”**。OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。每个对象看起来都像一台微型计算机–具有状态和操作，用户可以要求对象执行这些操作。第一个成功的面向对象语言Smalltalk（Java语言的祖先之一）的五大特性：万物皆对象：将对象视为奇特的变量，它可以存储数据，还可以要求它在自身上执行操作；程序是对象的集合：对象通过发送消息来告诉彼此所要做的事。要想请求一个对象，就必须对该对象发送一条消息（即调用对象方法的请求）；每个对象都有自己的由其他对象所构成的存储：可以通过创建包含现有对象的新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后；每个对象都拥有类型：每个对象都是某个类(class)的一个实例(instance)；某一特定类型的所有对象都可以接收同样的消息:一个“圆形”类型的对象同时也是“几何形”类型的对象，所以一个“圆形”对象必定能够接受发送给“几何形”对象的消息。这种**替代性（substitutability）**是OOP中最强有力的概念之一。Booch对对象提出了一个更加简洁的描述：对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据（对象的状态）和方法（产生的行为），并且每一个对象都可以唯一地与其他对象区分开来（即在内存中都有一个唯一的地址）。 每个对象都有一个接口创建抽象数据类型（类）是面向对象程序设计的基本概念之一。因为类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。程序员通过定义类来适应问题，通过添加新的数据类型来扩展编程语言。编程系统欣然接受新的类，并且像内置类型一样地照管它们和进行类型检查。每个对象都只能满足某些请求，这些请求由对象的**接口（interface）**所定义，决定接口的便是类型。接口确定了对某一特定对象所能发出的请求。但是，在程序中必须有满足这些请求的代码。这些代码和隐藏的数据一起构成了实现。在类型中，每一个可能的请求都有一个方法与之相关联，当对对象发送请求时，与之相关联的方法就会被调用。 每个对象都提供服务最好将对象想象为**“服务提供者”**。程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这一目的。当正在试图开发或理解一个程序设计时，首先去想一想需要那些“服务提供者”去帮助我们完成。例如，假设你正在创建一个簿记系统，那么可以想象，系统应该具有：完成簿记输入屏幕的服务提供者；执行簿记计算的服务提供者；处理在不同打印机上打印支票和开发票的服务提供者。上述的服务提供者，本质上就是一类对象，这是将问题分解为对象集合的一种合理方式。将对象看作是服务提供者还有一个附带的好处：它有助于提高对象的内聚性。高内聚是软件设计的基本质量要求之一。将对象看作服务提供者是一项伟大的简化工具，这不仅在设计过程中非常有用，而且当其他人试图理解你的代码或重用某个对象时，使用或调整的过程变得简单许多。 被隐藏的具体实现将程序开发人员按照角色分为类创建者（那些创建新数据类型的程序员）和客户端程序员（那些在应用中使用数据类型的类消费者）。客户端程序员收集各种用来实现快速开发应用的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必须的部分，而隐藏其他部分。如果加以隐藏，那么客户端程序员将不能访问它，这就意味着类创建者可以任意修改被隐藏的部分，而不用担心对其他人造成影响。被隐藏的部分通常代表对象内部脆弱的部分，它们很容易被粗心的或不知内情的客户端程序员所毁坏。因此，将实现隐藏起来可以减少程序BUG。在任何相互关系中，具有关系所涉及的各方都遵守的边界是十分重要的事情。因此，我们需要引入访问控制：访问控制让客户端程序员无法触及他们不应该触及的部分–这些部分对数据类型的内部操作是必须的，但并不是用户解决特定问题所需的接口的一部分；访问控制允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。Java使用三个关键字（或叫访问指定词，access specifier ）在类的内部设定边界：public：表示紧随其后的元素对任何人都可以用；private：表示除类型创建者和类型内部方法之外的任何人都不能访问。如果有人试图访问private成员，就会在编译时得到错误信息；protected：protected关键字与private作用相当，差别仅在于继承的类可以访问protected成员，但是不能访问privae成员。Java还有一种默认的访问权限，当没有使用前面提到的任何访问指定词，它将发挥作用，这种权限通常被称为包访问权限。在这种权限下，类可以访问同一包（库构件）中的其他类的成员。但是在包之外，这些成员如同指定了private一样。 复用具体实现一旦类被创建并被测试完，那么它就应该（在理想情况下）代表一个有用的代码单元。最简单地复用某个类的方式是直接使用该类的一个对象，此外也可以将那个类的一个对象置于新的类中。我们称其为**“创建一个成员对象”**。新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。这种概念被称为组合（composition）。如果组合式动态发生的，那么可以称为聚合（aggregation）。组合经常被视为**“has-a”（拥有）**关系。组合带来了极大的灵活性，设计会变得更加清晰。 继承类型不仅仅只是描述了作用于一个对象集合上的约束条件，同时还有与其他类型之间的关系。两个类型可以有相同的特性和行为，但是其中一个类型可能比另一个含有更多特性，并且可以处理更多的消息（或以不同的方式来处理消息）。**继承使用基类型和导出类型的概念表示这种类型之间的相似性。一个基类型包含其所有导出类型的所共享的特性和行为。**可以创建一个基类型来表示系统中某些对象的核心概念，从基类型中导出其他类型，来表示此核心可以被实现的各种不同方式。以同样的术语将解决方案转换成问题是大有裨益的，因为不需要在问题描述和解决方案描述之间建立许多中间模型。使导出类与基类之前产生差异的方法之一是改变现有基类的方法的行为，这被称之为覆盖（overriding），即重写基类的方法。 伴随多态的可互换对象在试图将导出类型的对象当作其泛化基类型对象看待时，存在着一个问题：让泛化的导出类工作时，编译器在编译时不可能知道应该执行哪一段代码。一个非面向对象编程的编译器产生的函数调用会引起所谓的前期绑定，即每个函数都会被绑定一个绝对地址。而在OOP中，程序直到运行时才能确定代码的地址。为了解决这个问题，面向对象程序设计语言使用了后期绑定的概念。为了执行后期绑定，Java使用了一小段特殊的代码来替代绝对地址调用。这段代码使用在对象存储的信息中来计算方法体的地址。在某些语言中，必须明确地声明希望某个方法具备后期绑定所带来的灵活性（C++通过使用virtual关键字来实现的）。而在Java中，动态绑定是默认行为，无需添加额外的关键字。将导出类看作是它的基类的过程称为向上转型（upcasting）。一个面向对象程序肯定会在某处包含向上转型，因为这正是将自己从必须知道确切类型中解放出来的关键。 单根继承结构在Java中，所有的类最终都继承自单一的基类–Object。事实证明，单根继承结构带来了很多好处：在单根继承结构中所有对象都具有一个共用接口，所以它们归根到底都是相同的基本类型。单根继承结构保证了所有对象都具备某些功能。因此你知道，你可以对任何对象执行某些基本操作。所有的对象都可以很容易地在堆上创建，而参数的传递也得到了很大的简化。单根继承结构使垃圾回收器的实现变得容易了很多。由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局。这对于系统级操作（如异常处理）显得尤其重要，并给编程带来了更大的灵活性。 容器容器：在任何需要时都可以扩充自己以容纳你置于其中的所有东西。因为程序员不需要知道将来把多少对象置于容器内，只需要创建一个容器对象，然后让它处理所有的细节。Java中具有满足不同需要的各种类型的容器：List：用于存储序列；Map：关联数组，用来建立对象之间的关联；Set：每种对象类型只持有一个的集合其他：如队列、树、堆栈等 参数化类型在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型：Object。单根继承结构意味着所有东西都是Object类型，所以可以存储Object的容器可以存储任何东西。这使得容器很容易被复用。但是由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object。因此它会丢失其身份。当把它取回时，就获取了一个对Object对象的引用，而不是对置入的那个类型对象的引用。这个时候需要**向下转型(downcasting)**才能得到确切的类型对象。我们知道，向上转型是安全的，但是向下转型却很危险（除非确切知道所要处理的对象类型）。解决方案被称为：参数化类型机制。参数化类型就是一个编译器可以自动定制作用于特定类型上的类。在Java中它称为范型。一对尖括号，中间包含类型信息（26个大写字母），通过这些特征就可以识别对范型的使用。1ArrayList&lt;Shape&gt; shapeLst = new ArrayList&lt;Shape&gt;(); 对象的创建和生命期在使用对象时，最关键的问题之一便是生成和销毁方式。每个对象为了生存都需要资源，尤其是内存。当我们不再需要一个对象时，它必须被清理掉，使其占有的资源可以被释放和重用。Java完全采用动态内存分配方式，每当想要创建新对象时，就要使用new关键字，在**堆（heap）**的内存池中动态创建对象实例。对于允许在堆栈上创建对象的语言，编译器可以确定对象的存活时间，并可以自动销毁它，即对象生命周期由编译器确定。Java提供了被称为“垃圾回收器”的机制，它可以自动发现对象何时不再被使用，并继而销毁它。垃圾回收器减少了所必需考虑的议题和必须编写的代码，提供了更高层的保障，可以避免暗藏的内存泄漏问题。C++为了追求最大的执行速度，对象的存储空间和生命周期都必须在编写程序时确定。而Java必须花费更多的CPU时间去回收对象。但是C++必须手动分配和释放对象，灵活性差，且常发生内存泄漏问题。 并发编程在计算机编程中有一个基本概念，就是在同一时刻处理多个任务的思想。我们想把问题切分成多个可独立运行的部分（任务），从而提高程序的响应能力。在程序中，这些彼此独立运行的部分称之为线程，上述概念称之为**“并发”**。多线程所带来的便利之一便是程序员不用再担心机器上是有多个处理器还是只有一个处理器，因为程序在逻辑上被分为线程，同时使程序执行更快。但并发存在一个隐患：共享资源。如果有多个并发任务都要访问同一项资源，那么就会出问题。解决的方案一般是：某个任务锁定某项资源，完成其任务，然后释放资源锁，使其他任务可以使用这项资源。并发：从时间上也是有先后顺序的，只是时间极短，故在人感受上是同时的。例如，线程A和线程B实际上是先后执行的，但对用户来看是一起发生的。那么为什么会发生争夺共享资源呢？因为CPU分配的时间片是长度是一定的，线程A在这个时间片上使用资源1，使用到一半时间片用完了。那么这时候轮到线程B，它要使用资源1。这个时候如果不加锁，就会发生数据不一致的问题之类的。并行：从时间上是一致，比如两匹马同时在跑。 异常处理：处理错误异常处理将错误处理直接置于编程语言中，甚至于操作系统中。**异常是一种对象，它从出错地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”。**异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径。因为它是另一条完全分离的执行路径，所以它不会干扰正常的执行代码。**异常不能被忽略，所以它保证一定会在某处得到处理。**需要指出的是：异常提供了一种从错误状态进行可靠恢复的途径，这帮助编写更健壮的程序。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"工厂模式","slug":"设计模式/工厂模式","date":"2020-05-25T11:57:00.000Z","updated":"2020-05-25T14:26:28.981Z","comments":true,"path":"设计模式/工厂模式/","link":"","permalink":"https://hengxincheung.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"引言工厂模式是一种创建型模式，它提供了了一种创建对象的最佳方式。使用工厂模式，创建对象时不会暴露客户端暴露创建逻辑（这个有点像接口的概念，客户端程序员不必关心内部的实现细节，并有效减少发生bug的概率），并且通过使用一个共同的接口来指向新创建的对象。 针对的问题许多类对象的创建都需要一系列的步骤，可能需要计算或取得对象的初始设置，选择生成哪个子对象实例，或者在生成需要的对象之前必须先生成一些辅助对象的对象。这些情况下，对象的建立是一个过程，是一个操作。简而言之，工厂模式存在的意义是：高效地创建某一类对象。 工厂模式的种类一般来说，工厂模式分为以下三种：简单工厂模式，又称静态工厂模式工厂方法模式，全程多个工厂方法模式抽象工厂模式 角色组成 概念工厂类角色：工厂模式的核心，含有一定的商业逻辑和判断逻辑，用以创建产品抽象产品角色：一类对象的抽象概念，即具体产品继承的父类或者实现的接口具体产品角色：工厂类所创建的对象就是此角色的实例，在Java中由一个具体类实现 手机制造工厂本文以手机制造工厂生产各类手机为场景学习工厂模式。手机分为两类：苹果手机华为手机。注：随便举例，不存在任何话题。 手机抽象父类123456public abstract class Phone&#123; // 手机的名字 private String name; // 打电话的方法 public abstract void call();&#125; 苹果手机123456789public class IPhone extends Phone&#123; public IPhone()&#123; super(\"苹果手机\"); &#125; @Override public void call()&#123; System.out.println(super.getName() + \"正在打电话\"); &#125;&#125; 华为手机123456789public class Huawei extends Phone&#123; public Huawei()&#123; super(\"华为手机\"); &#125; @Override public void call()&#123; System.out.println(super.getName() + \"正在打电话\"); &#125;&#125; 简单（静态）工厂模式 实现简单工厂模式的实现思想是：创建对象时候传入代表类型的参数type，然后再通过if-else或者switch语句根据type创建对应的对象返回。先看一下简单的代码实现：123456789101112131415161718public class PhoneFactory&#123; // 通过静态方法返回需要的手机实例 // type参数建议使用枚举，好处多多 public static Phone producePhone(String type)&#123; Phone phone; switch(type)&#123; case \"iphone\": phone = new IPhone(); break; case \"huawei\": phone = new Huawei(); break; default: throw new IllegalArgumentException(\"此型号手机暂不支持制造\"); &#125; return phone; &#125;&#125;简单工厂的机制很简单：根据传入的类型，创建对应的对象 总结在简单工厂模式中，提供创建对象的方法一般是静态的，故也被称为静态工厂模式。 优点实现简单：代码逻辑简单可复用高：所有对象的创建都通过同名的方法创建 缺点容错率低：如果传入的类型参数因为粗心写错，则创建的产品会与预期不符耦合度高：所有对象的共用一个创建方法，每增减一种产品，都需要对这个唯一的方法进行修改扩展性差：每增减一种产品，都需要修改工厂类，违背了设计模式中的开放-封闭原则（OCP，对扩展开放，对修改关闭） （多个）工厂方法模式 实现工厂方法模式的关键点在于：为每种对象提供相应的工厂方法。12345678910public class PhoneFactory&#123; // 制造苹果手机的方法 public static Phone produceIPhone()&#123; return new IPhone(); &#125; // 制造华为手机的方法 public static Phone produceHuawei()&#123; return new Huawei(); &#125;&#125; 总结（多个）工厂方法模式，为每种对象分别编写专用的创建方法，根据调用的创建方法不同，产生不同对象。 优点实现简单：代码逻辑容易理解容错率高：每种对象都有专用的创建方法，无需传入类型等参数，只要调用正确的创建方法就不会出错。（这一点有点异议，感觉跟简单工厂模式传参错误的概率是一样）耦合度低：每增减一种产品，只需要增减一个创建方法，不会影响其他对象的创建方法 缺点扩展性差：每增减一种产品，都需要修改工厂类，违背了开闭原则可复用低：所有对象的创建方法都不同名 抽象工厂模式 实现抽象工厂模式的关键点在于：为每种对象提供单独的工厂和工厂方法。所以需要把工厂类抽象出来，形成抽象工厂，然后针对每种对象分别实现专用的工厂及工厂方法，这就是抽象工厂的命名由来。1.抽象工厂:AbstractPhoneFactory1234public abstract class AbstractPhoneFactory&#123; // 生成手机的抽象方法 public abstract Phone producePhone();&#125;2.苹果手机专用生产工厂：IPhoneFactory123456public class IPhoneFactory extends AbstractPhoneFactory&#123; @Override public Phone producePhone()&#123; return new IPhone(); &#125;&#125;3.华为手机专用生产工厂：HuaweiFactory123456public class HuaweiFactory extends AbstractPhoneFactory&#123; @Override public Phone producePhone()&#123; return new Huawei(); &#125;&#125;4.测试1234567// 苹果手机的工厂AbstractPhoneFactory factory = new IPhoneFactory();// 制造一台苹果手机Phone phone = factory.producePhone();// 调用苹果手机的打电话方法phone.call();// 输出：苹果手机正在打电话 总结抽象工厂模式：定义一个抽象工厂和其抽象方法，每种对象都有专用的子工厂及对象创建方法。个人理解，就像富士康（抽象父工厂）有许多的车间（具体的工厂）生产不同的产品。 优点容错率高：因为每种对象都有专用的工厂及创建方法，只要调用正确的工厂就不会出错耦合度低：每增减一种产品，只需要增减一个工厂及其方法，不会影响其他对象的创建方法扩展性好：每增减一种产品，只需要增减此对象的工厂及其创建方法，不会修改其他工厂，遵循开闭原则可复用高：所有对象的创建都通过同名的方法创建 缺点实现复杂：代码逻辑相对复杂，nnn 个对象需要定义 nnn 个工厂类","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"},{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"},{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}