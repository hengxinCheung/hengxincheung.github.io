{"meta":{"title":"hengxincheung's blog","subtitle":"","description":"","author":"hengxincheung","url":"https://hengxincheung.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2020-05-25T10:19:05.369Z","updated":"2020-05-25T10:19:05.369Z","comments":false,"path":"categories/index.html","permalink":"https://hengxincheung.github.io/categories/","excerpt":"","text":""},{"title":"标签","date":"2020-05-25T10:19:35.595Z","updated":"2020-05-25T10:19:35.595Z","comments":true,"path":"tags/index.html","permalink":"https://hengxincheung.github.io/tags/","excerpt":"","text":""},{"title":"个人简介","date":"2020-05-25T10:44:05.334Z","updated":"2020-05-25T10:44:05.334Z","comments":false,"path":"about/index.html","permalink":"https://hengxincheung.github.io/about/","excerpt":"","text":"联系方式移动电话：15626487308电子邮箱：hengxincheung@qq.com 教育背景时间学校专业学历2015-09 至 2019-06华南农业大学信息与计算科学本科2019-09 至 今电子科技大学软件工程硕士主修课程：数学分析、高等代数、离散数学、概率论、数值计算、常微分方程、组合优化、随机过程与排队论算法设计与分析、操作系统、Web开发、数据结构、数据挖掘、信息安全、Unix操作系统内核高级计算机结构、软件架构模型与设计、统计机器学习、网络计算模式、网络编程 项目经验修正 UWB 定位飘移算法研究人体检测与人体行为识别研究 技能评价具有良好的英语文本阅读能力以及书面写作；数学基础扎实，熟练掌握数学分析、数值计算、高等代数等，了解机器学习、深度学习，可以进行独立的数据挖掘和分析工作；熟练 C、Java、Python 等编程语言；熟悉常用的数据结构及算法、设计模式；掌握后台 Spring、Spring MVC、MyBatis、Hibernate 、Struts 等框架，前端 HTML\\CSS、JavaScript、Ajax、JQuery、Vue 等。 荣誉奖励美国大学生数学建模竞赛 H 奖（二等奖）、全国大学生数学建模竞赛三等奖；校级 ACM 竞赛专业组三等奖；校二等奖学金、校级三等奖学金；优秀志愿者、优秀团干部、优秀班委等。 自我评价思维严谨，有较强的学习和适应能力。工作主动，有责任心、执行力和抗压性，对代码有偏执地完美的追求，有着良好的规范代码编写习惯。热爱互联网行业，热爱编程开发，对互联网发展有敏锐触觉和十二分激情。"}],"posts":[{"title":"03-k近邻法","slug":"统计机器学习/03-k近邻法","date":"2020-07-07T14:18:36.000Z","updated":"2020-07-07T14:41:26.107Z","comments":true,"path":"统计机器学习/03-k近邻法/","link":"","permalink":"https://hengxincheung.github.io/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03-k%E8%BF%91%E9%82%BB%E6%B3%95/","excerpt":"","text":"k近邻法（k-nearest neighbor，k-NN）是一种基本分类与回归方法。这里值讨论分类问题中的k近邻法。k近邻法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。分类时，对新的实例，根据其k个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，k近邻法不具有显式的学习过程。k值选择、距离度量以及分类决策规则是k近邻法的三个基本要素。 k近邻算法k近邻算法简单、直观：给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，就把这个输入实例分为这个类。k近邻法算法：输入：训练数据集 $$T = { (x_1,y_1), (x_2, y_2), …, (x_N,y_N) }$$输出：实例 xxx 所属的类 yyy根据给定的距离度量，在训练集 TTT 中找出与 xxx 最邻近的k个点，涵盖这k个点的 xxx 的邻域记作 Nk(x)N_k(x)Nk​(x)在 Nk(x)N_k(x)Nk​(x) 中根据分类规则（如多数表决）决定 xxx 的类别 yyy ：$$y = argmax \\sum_{x_i \\in N_k(x) I(y_i = c_j)}$$k近邻法的特殊情况是k=1的情形，称为最近邻算法。 k近邻模型k近邻法使用的模型实际上对应于对特征空间的划分。模型由三个基本要素：距离度量，k值选择和分类决策规则决定。 模型k近邻法中，当训练集，距离度量（如欧式距离），k值以及分类决策规则（如多数表决）确定后，对于任何一个新的输入实例，它所属的类唯一地确定。这相当于根据上述要素将特征空间划分为一些子空间，确定子空间中每个点所属的类。特征空间中，对每个训练实例点 xix_ixi​，距离该点比其他点更近的所有点组成一个区域，叫做单元(cell)。每个训练实例点拥有一个单元，所有训练实例点的单元构成特征空间的一个划分。最近邻将实例 xix_ixi​ 的类 yiy_iyi​ 作为其单元中所有点的类标记（class label）。这样，每个单元的实例点的类别是确定的。 距离度量特征空间中两个实例点的距离是两个实例点相似程序的反映。常用的距离有欧式距离，也可以是其他距离，如更一般的 LpL_pLp​ 距离(LpdistanceL_p distanceLp​distance)或 Minkowski距离（Minkowski distance）。xi,xjx_i,x_jxi​,xj​ 的 LpL_pLp​ 距离定义为：Lp(xi,xj)=(∑l=1n∣xi(l)−xj(l)∣p)1pL_p(x_i, x_j) = (\\sum_{l=1}^{n} \\vert x_{i}^{(l)} - x_{j}^{(l)} \\vert ^{p})^{\\frac{1}{p}}Lp​(xi​,xj​)=(l=1∑n​∣xi(l)​−xj(l)​∣p)p1​当 p=2p=2p=2 时候，称为欧式距离（Euclidean distance）。当 p=2p=2p=2 时候，称为曼哈顿距离（Manhattan distance）。当 p=∞p=\\inftyp=∞ 时候，它是各个坐标距离的最大值。 k值选择k值选择会对k近邻法的结果产生重大影响。如果选择较小的k值，就相当于用较小的领域中的训练实例进行预测，学习的近似误差（approximation error）会减小，只有与输入实例较近（相似的）训练实例才会对预测结果其作用。但缺点是学习的估计误差（estimation error）会增大，预测结果会对近邻的实例点非常敏感。如果邻近的实例点恰巧是噪声，预测就会出错。换句话说，k值的减小意味着整体模型变复杂，容易发生过拟合。如果选择较大的k值，就相当于用较大领域中的训练实例进行预测。其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。k值增大就意味着整体的模型变得简单。如果 k=Nk=Nk=N，无论输入实例是什么，都将简单地预测它属于在训练实例中最多的类。这时，模型过与简单，完全忽略训练实例中的大量有效信息，是不可取的。在应用中，k值一般取一个比较小的数值，通常采用交叉验证法来选择最优的k值。 分类决策规则k近邻法中的分类决策规则往往是多数表决，即由输入实例的k个邻近的训练实例中的多数类决定输入实例的类。多数表决规则（majority voting rule）有如下解释：如果分类的损失函数为0-1损失函数，分类函数为：f:Rn→{c1,c2,...,cK}f: R^n \\rightarrow \\{ c_1,c_2,...,c_K \\}f:Rn→{c1​,c2​,...,cK​}那么误分类的概率是：P(Y≠f(X))=1−P(Y=f(X))P(Y \\neq f(X)) = 1 - P(Y = f(X))P(Y​=f(X))=1−P(Y=f(X))对给定的实例 x∈Xx \\in Xx∈X，其最近邻的k个训练实例点构成集合 Nk(x)N_k(x)Nk​(x)。如果涵盖 Nk(x)N_k(x)Nk​(x) 的区域的类别是 cjc_jcj​，那么误分类率是：1k∑xi∈Nk(x)I(yi≠cj)=1−1k∑xi∈Nk(x)I(yi=cj)\\frac{1}{k} \\sum_{x_i \\in N_k(x)} I(y_i \\neq c_j) = 1 - \\frac{1}{k} \\sum_{x_i \\in N_k(x)} I(y_i = c_j)k1​xi​∈Nk​(x)∑​I(yi​​=cj​)=1−k1​xi​∈Nk​(x)∑​I(yi​=cj​)要使误分类率最小即经验风险最小，就要使 ∑xi∈Nk(x)I(yi=cj)\\sum_{x_i \\in N_k(x)} I(y_i = c_j)∑xi​∈Nk​(x)​I(yi​=cj​) 最大，所以多数表决规则等价于经验风险最小化。 k近邻法的实现：kd树实现k近邻法时，主要考虑的问题是如何对训练数据进行快速k近邻搜索。这点在特征空间的维数大以及训练数据容量大时尤其必要。k近邻法最简单的实现方法使线性扫描（linear scan）。这时要计算输入实例与每一个训练实例的距离。当训练集很大时，计算非常耗时，这种方法使不可行的。为了提高k近邻搜索的效率，可以考虑使用特殊的结构存储训练数据，以减少计算距离的次数。 构造kd树kd树是一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。kd树是二叉树，表示对k维空间的一个划分（partition）。构造kd树相当于不断用垂直于坐标轴的超平面将k维空间切分，构成一系列的k维超矩形区域。kd树的每个节点对应于一个k维超矩形区域。构造kd树的方法如下：构造根节点，使根节点对应于k维空间中包含所有实例点的超矩形区域：通过下面的递归方法，不断地对k维空间进行切分生成子结点。在超矩形区域（节点）上选择一个坐标轴和此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子节点）；这时，实例被分到两个子区域，这个过程直到子区域内没有实例时终止（终止时的节点为叶节点）。在此过程中，将实例保存在相应的节点上。通常，依次选择坐标轴对空间划分，选择训练实例点在选定坐标轴上的中位数（median）为切分点，这样得到的kd树是平衡的。注意，平衡的kd树在搜索时的效率未必使最优的。构造平衡kd树的算法输入：k维空间数据集 T=x1,x2,...,xNT = {x_1,x_2,...,x_N}T=x1​,x2​,...,xN​输出：kd树开始：构造根节点，根节点对应于包含 TTT 的k维空间的超矩形区域。选择 x(1)x^{(1)}x(1) 为坐标轴，以 TTT 中所有实例的 x(1)x^{(1)}x(1) (特征向量的第一个维度)坐标的中位数为切分点，将根节点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴 x(1)x^{(1)}x(1) 垂直的超平面实现。由根节点生成深度为1的左、右子结点；左子节点对应坐标 x(1)x^{(1)}x(1) 小与切分点的子区域，右子结点对应于坐标 x(1)x^{(1)}x(1) 大于切分点的子区域。将落在切分超平面上的实例点保存在根节点。重复：对深度为 jjj 的节点，选择 x(l)x^{(l)}x(l) 为切分的坐标轴，其中 l=j(modk)+1l = j(mod k)+1l=j(modk)+1，以该节点的区域中所有实例的 x(l)x^{(l)}x(l) 坐标的中位数为切分点，将该节点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴 x(l)x^{(l)}x(l) 垂直的超平面实现。由该节点生成深度为 j+1j+1j+1 的左、右子结点：左子结点对应坐标 x(l)x^{(l)}x(l) 小于切分点的子区域，右子节点对应坐标 x(l)x^{(l)}x(l) 大于切分点的子区域。将落在切分超平面上的实例点保存在该节点。直至两个子区域没有实例存在时停止，从而形成kd树的区域划分。 搜索kd树利用kd树可以省去对大部分数据点的搜索，从而减少搜索的计算量。给定一个目标点，搜索其最近邻。首先找到包含目标点的叶节点；然后从该叶节点出发，依次回退到父节点；不断查找与目标点最邻近的节点，当确定不可能存在更近的节点时终止。这样搜索就被限制在空间的局部区域上，效率大为提高。包含目标点的叶节点对应包含目标点的最小超矩形区域。以此叶节点的实例点作为当前最近点。目标点的最近邻一定在以目标点为中心并通过当前最近点的超球体的内部。然后返回当前节点的父节点，如果父节点的另一子结点的超矩形区域与超球体相交，那么在相交的区域内寻找与目标点更近的实例点。如果存在这样的点，将此点作为新的当前最近点。算法转到更上一级的父节点，继续上述过程。如果父节点的另一子结点的超矩形区域与超球体不相交，或不存在比当前最近点更近的点，则停止搜索。用kd树的最近邻搜索的算法：输入：已构造的kd树；目标点 xxx；输出：xxx 的最近邻在kd树中找出包含目标点 xxx 的叶节点：从根节点除法，递归地向下访问kd树。若目标点 xxx 当前维的坐标小于切分点的坐标，则移动到左子节点，否则移动到右子节点，直到子节点为叶节点为止。以此叶节点为“当前最近点”。递归地向上回退，在每个节点进行以下操作：如果该节点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点”当前最近点一定存在于该节点一个子结点对应的区域。检查该子节点的父节的另一子节点对应的区域是有更近的点。具体地，检查另一子节点对应的区域是否以目标点为球心、以目标点与“当前最近点”间的距离为半径的超球体相交。如果相交，可能在另一子节点对应的区域内存在距目标点更近的点，移动到另一子节点。接着，递归地进行最近邻搜索。如果不相交，向上回退。当回退到根节点时，搜索结束。最后的“当前最近点”即为 xxx 的最近邻点。如果实例点使随机分布的，kd树搜索的平均计算复杂度是 O(logN)O(log N)O(logN)，这里 NNN 是训练实例树。kd树更适用于训练实例数远大于空间维数时的k近邻搜索。当空间维数接近训练实例数时，它的效率会迅速下降，几乎接近线扫描。 代码实现kd树代码实现","categories":[{"name":"统计机器学习","slug":"统计机器学习","permalink":"https://hengxincheung.github.io/categories/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"02-感知机","slug":"统计机器学习/02-感知机","date":"2020-07-07T14:17:50.000Z","updated":"2020-07-07T14:18:53.609Z","comments":true,"path":"统计机器学习/02-感知机/","link":"","permalink":"https://hengxincheung.github.io/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02-%E6%84%9F%E7%9F%A5%E6%9C%BA/","excerpt":"","text":"感知机（perceptron）是一个二分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，取 +1 和 -1 二值。感知机对应于输入空间（特征空间）中将实例划分为正负两类的分离超平面。为此，倒入基于误分类的损失函数，利用梯度下降法对损失函数进行极小化，求得感知机模型。感知机学习算法具有简单而易于实现的优点，分为原始形式和对偶形式。 感知机模型假设输入空间（特征空间）是 X⊆RnX \\subseteq R^nX⊆Rn，输出空间是 Y=+1,−1Y = {+1, -1}Y=+1,−1。由输入空间到输出空间的如下函数称为感知机：f(x)=sign(w⋅x+b)f(x) = sign(w \\cdot x + b)f(x)=sign(w⋅x+b)其中，www 和 bbb 为感知机模型参数。www 叫做权值（weight）或权值向量（weight vecotr)，bbb 叫做偏置（bias）。w⋅xw \\cdot xw⋅x 表示 www 和 xxx 的内积，signsignsign 是符号函数，即：sign(x)={1,x≥00,x&lt;0sign(x)=\\begin{cases} 1, &amp;x \\ge 0 \\\\ 0, &amp;x \\lt 0 \\\\ \\end{cases}sign(x)={1,0,​x≥0x&lt;0​感知机是一种线性分类模型，属于判别模型。感知机模型的假设空间是定义在特征空间中的所有线性分类模型（linear classification model）或线性分类器（linear classifier），即函数集合 {f∣f(x)=w⋅x+b}\\{f | f(x)=w \\cdot x + b\\}{f∣f(x)=w⋅x+b}。感知机有如下几何解释：线性方程w⋅x+b=0w \\cdot x + b = 0w⋅x+b=0对应于特征空间 RnR^nRn 中的一个超平面 SSS，其中 www 是超平面的法向量，bbb 是超平面的截距。这个超平面将特征空间划分为两个部分，位于两部分的点（特征向量）分别被分为正、负两类。因此，超平面 SSS 也被称为分离超平面（separating hyperplane）。 感知机学习策略 数据集的线性可分性给定一个数据集，如果存在某个超平面 SSS：w⋅x+b=0w \\cdot x + b = 0w⋅x+b=0能够将数据集正实例点和负实例点完全正确地划分到超平面的两侧，即对所有 yi=+1y_i = +1yi​=+1 的实例 iii,有 w⋅xi+b&gt;0w \\cdot x_i + b &gt; 0w⋅xi​+b&gt;0；对有yi=−1y_i = -1yi​=−1 的实例 iii,有 w⋅xi+b&lt;0w \\cdot x_i + b &lt; 0w⋅xi​+b&lt;0。则称数据集为线性可分数据集（linearly separable data set）；否则，称数据集线性不可分。 感知机学习策略假设训练数据集是线性可分的，感知机学习的目标是求得一个能够将训练集正实例点和负实例点完全正确分开的分离超平面。为了找出这样的超平面，即确定感知机模型参数 www,bbb，需要确定一个学习策略，即定义（经验）损失函数并将损失函数极小化。损失函数的一个自然选择是误分类点的总数。但是，这样的损失函数不是参数 www,bbb 的连续可导函数，不易优化。损失函数的另一个选择是误分类点到超平面 SSS 的总距离，这是感知机锁采用的。为此，首先写出输入空间任一点到超平面的距离：1∣∣w∣∣∣w⋅x0+b∣\\frac{1}{\\vert\\vert w \\vert\\vert} \\vert w \\cdot x_0 + b \\vert∣∣w∣∣1​∣w⋅x0​+b∣这里的 ∣∣w∣∣\\vert\\vert w \\vert\\vert∣∣w∣∣ 是 www 的 L2L_2L2​ 范数。其次，对于误分类的数据 (xi,yi)(x_i,y_i)(xi​,yi​) 来说，−yi(w⋅xi+b)&gt;0-y_i (w \\cdot x_i + b) &gt; 0−yi​(w⋅xi​+b)&gt;0成立。因为当 w⋅xi+b&gt;0w \\cdot x_i + b &gt; 0w⋅xi​+b&gt;0 时，yi=−1y_i = -1yi​=−1，而当 w⋅xi+b&lt;0w \\cdot x_i + b &lt; 0w⋅xi​+b&lt;0 时，yi=+1y_i = +1yi​=+1。因此，误分类点 xix_ixi​ 到超平面 SSS 的距离是：−1∣∣w∣∣∑xi∈Myi(w⋅x+b)-\\frac{1}{\\vert\\vert w \\vert\\vert} \\sum_{x_i \\in M} y_i(w \\cdot x + b)−∣∣w∣∣1​xi​∈M∑​yi​(w⋅x+b)不考虑 ∣∣w∣∣\\vert\\vert w \\vert\\vert∣∣w∣∣，就得到感知机学习的损失函数。感知机 sign(w⋅x+b)sign(w \\cdot x + b)sign(w⋅x+b) 学习的损失函数定义为：L(w,b)=−∑xi∈Myi(w⋅xi+b)L(w, b) = -\\sum_{x_i \\in M} y_i(w \\cdot x_i + b)L(w,b)=−xi​∈M∑​yi​(w⋅xi​+b)其中 MMM 为误分类点的集合。这个损失函数就是感知机学习的经验风险函数。显然，损失函数 L(w,b)L(w, b)L(w,b) 是非负的。如果没有误分类点，损失函数值是0。而且，误分类点越少，误分类点离超平面越近，损失函数值就越小。 感知机学习算法感知机学习问题转化为求解损失函数的最优化问题，最优化的方法是随机梯度下降法。 感知机学习算法的原始形式求解参数 www,bbb，使其为以下损失函数极小化问题的解：minw,bL(w,b)=−∑xi∈Myi(w⋅xi+b)\\underset{w,b}{min} L(w, b) = -\\sum_{x_i \\in M} y_i (w \\cdot x_i + b)w,bmin​L(w,b)=−xi​∈M∑​yi​(w⋅xi​+b)感知机学习算法是误分类驱动的，具体采用随机梯度下降法（stochastic gradient descent）。首先，任意选取一个超平面 w0w_0w0​,b0b_0b0​，然后用梯度下降法不断地极小化目标函数。极小化过程中不是一次使 MMM 中所有误分类点的梯度下降，而是一次随机选取一个误分类点使其梯度下降。假设误分类点集合 MMM 是固定的，那么损失函数 L(w,b)L(w, b)L(w,b) 的梯度由下面的公式给出：∇wL(w,b)=−∑xi∈Myixi\\nabla_{w} L(w, b) = -\\sum_{x_i \\in M}y_ix_i∇w​L(w,b)=−xi​∈M∑​yi​xi​∇bL(w,b)=−∑xi∈Myixi\\nabla_{b} L(w, b) = -\\sum_{x_i \\in M}y_ix_i∇b​L(w,b)=−xi​∈M∑​yi​xi​随机选取一个误分类点 (xi,yi)(x_i, y_i)(xi​,yi​)，对 www,bbb 进行更新：w←w+ηyixiw \\leftarrow w + \\eta y_i x_iw←w+ηyi​xi​b←b+ηyib \\leftarrow b + \\eta y_ib←b+ηyi​η(0&lt;η≤1)\\eta (0 \\lt \\eta \\leq 1)η(0&lt;η≤1) 是步长，在统计学习中又称为学习率（learning rate）。这样，通过迭代可以期待损失函数 L(w,b)L(w,b)L(w,b) 不断减小，直到为0。感知机学习算法的原始形式：输入：训练数据集 T={(x1,y1),(x2,y2),...,(xN,yN)}T = \\{ (x_1,y_1),(x_2,y_2),...,(x_N,y_N) \\}T={(x1​,y1​),(x2​,y2​),...,(xN​,yN​)}；学习率 η(0&lt;η≤1)\\eta (0 \\lt \\eta \\leq 1)η(0&lt;η≤1)。输出：w,bw,bw,b；感知机模型 f(x)=sign(w⋅x+b)f(x)=sign(w \\cdot x + b)f(x)=sign(w⋅x+b)选取初始值 w0,b0w_0,b_0w0​,b0​在训练集中选取数据 (xi,yi)(x_i, y_i)(xi​,yi​)如果 yi(w⋅xi+b)≤0y_i(w \\cdot x_i + b) \\leq 0yi​(w⋅xi​+b)≤0: $$w \\leftarrow w + \\eta y_i x_i \\ b \\leftarrow b + \\eta y_i$$转至第二步，直至训练集中没有误分类点注意：感知机学习算法由于采用不同的初值或选取不同的误分类点，解可以不同。 算法的收敛性对于线性可分数据集，感知机学习算法原始形式收敛，即经过有限次迭代可以得到一个将训练集完全正确划分的分离超平面及感知机模型。 感知机学习算法的对偶形式对偶形式的基本想法是，将 www 和 bbb 表示为实例 xix_ixi​ 和标记 yiy_iyi​ 的线性组合的形式，通过求解其系数而求得 www 和 bbb。不失一般性，可假设初始值 w0,b0w_0,b_0w0​,b0​ 均为0.对于误分类点 (xi,yi)(x_i, y_i)(xi​,yi​) 通过w←w+ηyixiw \\leftarrow w + \\eta y_i x_iw←w+ηyi​xi​b←b+ηyib \\leftarrow b + \\eta y_ib←b+ηyi​逐步修改 w,bw,bw,b，设修改 nnn 此，则 w,bw,bw,b 关于 (xi,yi)(x_i, y_i)(xi​,yi​) 的增量分别是 αiyixi\\alpha_i y_i x_iαi​yi​xi​ 和 αiyi\\alpha_i y_iαi​yi​，这里 αi=niη\\alpha_i = n_i \\etaαi​=ni​η。这样，从学习过程不难看出，最后学习到的 w,bw,bw,b 可分别表示为：w=∑i=1Nαiyixiw = \\sum_{i=1}^{N}\\alpha_i y_i x_iw=i=1∑N​αi​yi​xi​b=∑i=1Nαiyib = \\sum_{i=1}^{N}\\alpha_i y_ib=i=1∑N​αi​yi​实例点更新次数越多，意味着它距离分离超平面越近，也就越难正确分离。换句话说，这样的实例对学习结果影响最大。感知机学习算法的对偶形式：输入：训练数据集 T={(x1,y1),(x2,y2),...,(xN,yN)}T = \\{ (x_1,y_1),(x_2,y_2),...,(x_N,y_N) \\}T={(x1​,y1​),(x2​,y2​),...,(xN​,yN​)}；学习率 η(0&lt;η≤1)\\eta (0 \\lt \\eta \\leq 1)η(0&lt;η≤1)。输出：α,b\\alpha, bα,b；感知机模型 f(x)=sign(∑j=1Nαjyjxj⋅x+b)f(x)=sign(\\sum_{j=1}^{N} \\alpha_j y_j x_j \\cdot x + b)f(x)=sign(∑j=1N​αj​yj​xj​⋅x+b)其中 α=(α1,α2,...,αN)T\\alpha = (\\alpha_1, \\alpha_2,...,\\alpha_N)^{T}α=(α1​,α2​,...,αN​)Tα←0,b←0\\alpha \\leftarrow 0, b \\leftarrow 0α←0,b←0在训练集中选取数据 (xi,yi)(x_i, y_i)(xi​,yi​)如果 yi(∑j=1Nαjyjxj⋅xj+b)≤0y_i(\\sum_{j=1}^{N} \\alpha_j y_j x_j \\cdot x_j +b) \\leq 0yi​(∑j=1N​αj​yj​xj​⋅xj​+b)≤0，$$\\alpha_i \\leftarrow \\alpha_i + \\eta \\ b \\leftarrow b + \\eta y_i$$转至第二步直到没有误分类数据。对偶形式中训练实例仅以内积的形式出现。为了方便，可以预先将训练集中实例键的内积计算出来并以矩阵的形式存储，这个矩阵就是所有的Gram矩阵：G=[xi⋅xj]N×NG = [x_i \\cdot x_j]_{N \\times N}G=[xi​⋅xj​]N×N​ 代码实现感知机代码实现","categories":[{"name":"统计机器学习","slug":"统计机器学习","permalink":"https://hengxincheung.github.io/categories/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"01-统计学习方法概论","slug":"统计机器学习/01-统计学习方法概论","date":"2020-07-05T14:20:01.000Z","updated":"2020-07-05T14:20:49.130Z","comments":true,"path":"统计机器学习/01-统计学习方法概论/","link":"","permalink":"https://hengxincheung.github.io/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/","excerpt":"","text":"统计学习 统计学习的特点统计学习（statistical learning）是关于计算机基于数据构建概率统计模型并运行模型对数据进行预测和分析的一门学科，也称为统计机器学习（statistical machine learning）。统计学习的主要特点是：统计学习以计算机及网络为平台，是建立在这两者之上的；统计学习以数据为研究对象，是数据驱动的学科；统计学习的目的是对数据进行预测和分析；统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析；统计学习是概率论、统计学、信息论、计算理论、最优化理论以及计算机科学等多个领域的交叉学科。 统计学习的对象统计学习的对象是数据（data）。它从数据除法，抽取数据的特征，抽象出数据的模型，发现数据中的值是，又回到对数据的分析与预测中去。统计学习关于数据的基本假设是同类数据具有一定的统计规律性，这是统计学习的前提。 统计学习的目的统计学习用于对数据进行预测与分析，特别是对未知新数据进行预测与分析。对数据的预测与分析是通过构建概率统计模型实现的。 统计学习的方法统计学习由监督学习（supervised learning）、非监督学习（unsupervised learning）、半监督学习（semi-supervised learning）和强化学习（reinforcement learning）等组成。监督学习的方法可以概括如下：从给定的、有限的、用于学习的训练数据（training data）集合出发，假定数据是独立同分布产生的；并且假定要学习的模型属于某个函数的集合，称为假设空间（hypothesis space）；应用某个评价准则（evaluation criterion），从假设空间中选取一个最优的模块，使它对已知训练数据及未知测试数据（test data）在给定的评价准则下由最优的预测；最有模型的选取由算法实现。这样，统计学习方法包括模型的假设空间、模型选择的准则以及模型学习的算法，称为统计学习方法的三要素，简称为模型（model）、策略（strategy）和算法（algorithm）。实现统计学习方法的步骤如下：得到一个有限的训练数据集合；确定包含所有可能的模型的假设空间，即学习模型的集合；确定模型选择的准则，即学习的策略；实现求解最优模型的算法，即学习的算法；通过学习方法选择最优模型；利用学习的最优模型对新数据进行预测或分析。 监督学习监督学习（supervised learning）的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出作出一个好的预测（注意，这里的输入、输出是指某个系统的输入与输出，与学习的输入与输出不同）。 基本概念 输入空间、特征空间与输出空间在监督学习中，将输入与输出所有可能取值的集合分别称为输入空间（input space）与输出空间（output space）。输入与输出空间可以是有限元素的集合，也可以是整个欧式空间。输入空间与输出空间可以是同一个空间，也可以是不同的空间，但通常输出空间远小于输入空间。每个具体的输入是一个实例（instance），通常由特征向量(feature vector)表示。这时，所有特征向量存在的空间称为特征空间（feature space）。特征空间的每一维对应于一个特征。模型实际上都是定义在特征空间上的。在监督学习过程中，将输入与输出看作是定义在输入（特征）空间与输出空间上的随机变量的取值。输入、输出变量用大写字母表示。输入、输出变量所取的值用小写字母表示。输入实例 xxx 的特征向量记作：x=(x(1),x(2),...,x(n),)Tx = (x^{(1)},x^{(2)},...,x^{(n)},)^{T}x=(x(1),x(2),...,x(n),)T注意：x(i)x^{(i)}x(i) 表示第 iii 个特征。监督学习从训练数据（training data）集合中学习模型，对测试数据（test data）进行预测。训练数据由输入（或特征向量）与输出对组成，训练集通常表示为：T={(x1,y1),(x2,y2),...,(xN,yN)}T = \\{(x_1,y_1), (x_2,y_2),..., (x_N,y_N)\\}T={(x1​,y1​),(x2​,y2​),...,(xN​,yN​)}测试数据也由相应的输入与输出对组成。输入与输出对又称为样本（sample）或样本点。输入变量 XXX 与输出变量 YYY 由不同的类型，可以是连续的也可以是离散的。如果输入变量与输出变量均为连续变量的预测问题称为回归问题；输出变量为有限个离散变量的预测问题称为分类问题；输入变量与输出变量均为变量序列的预测问题称为标注问题。 联合概率分布监督学习假设输入与输出的随机变量 XXX 和 YYY 遵循联合概率分布 P(X,Y)P(X,Y)P(X,Y)。P(X,Y)P(X,Y)P(X,Y) 表示分布函数，或分布密度函数。注意，在学习过程中，假定这一联合概率分布存在。训练数据与测试数据被看作是依照联合概率分布 P(X,Y)P(X,Y)P(X,Y) 独立同分布产生的。 假设空间监督学习的目的在与学习一个由输入到输出的映射，这一映射由模型来表示。模型属于由输入空间到输出空间的映射的集合。这个集合就是假设空间（hypothesis space）。假设空间的确定意味着学习范围的确定。监督学习的模型可以是概率模型或非概率模型，由条件概率分布 P(Y∣X)P(Y|X)P(Y∣X) 或决策函数（decision function）Y=f(X)Y=f(X)Y=f(X) 表示。 统计学习三要素统计学习方法都是由模型、策略和算法构成的，即统计学习方法由三要素构成：方法=模型+策略+算法方法 = 模型 + 策略 + 算法方法=模型+策略+算法 模型在监督学习中，模型就是锁妖学习的条件概率分布或决策函数。模型的假设空间（hypothesis space）包括所有可能的条件概率分布或决策函数。假设空间用 FFF 表示。假设空间可以定义为决策函数的集合：F={f∣Y=f(X)}F = \\{f|Y=f(X)\\}F={f∣Y=f(X)}其中，XXX 和 YYY 是定义在输入空间 χ\\chiχ 和输出空间 ψ\\psiψ 上的随机变量。这时 FFF 通常是由一个参数向量决定的函数族：F={f∣Y=fθ(X),θ∈Rn}F = \\{ f | Y=f_{\\theta}(X),\\theta \\in R^{n} \\}F={f∣Y=fθ​(X),θ∈Rn}参数向量 θ\\thetaθ 取值于 nnn 维欧式空间 RnR^{n}Rn，称为参数空间(parameter space)。 策略有了模型的假设空间，统计学习接着需要考虑的是按照什么样的准则学习或选择最优的模型。首先引入损失函数与风险函数的概念。损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。 损失函数和风险函数监督学习问题是在假设空间 FFF 中选取模型 fff 作为决策函数，对于给定的输入 XXX，由 f(X)f(X)f(X) 给出相应的输出 YYY,这个输出的预测值 f(X)f(X)f(X) 与真实值 YYY 可能一致也可能不一致，用一个损失函数（loss function）或代价函数（cost function）来度量预测错误的程度。损失函数是 f(X)f(X)f(X) 和 YYY 的非负实值函数，记作 L(Y,f(X))L(Y,f(X))L(Y,f(X))。统计学习常用的损失函数有以下几种：0-1损失函数（0-1 loss function）：$$L(Y,f(X))=\\begin{cases}1&amp; Y \\neq f(X)\\0&amp; Y = f(X)\\end{cases}$$平方损失函数（quadratic loss function）：$$L(Y,f(X)) = (Y-f(X))^{2}$$绝对损失函数（absolute loss function）：$$L(Y,f(X)) = |Y-f(X)|$$对数损失函数（logarithmic loss function）：$$L(Y,f(X)) = -logP(Y|X)$$损失函数值越小，模型就越好。由于模型的输入、输出 (X,Y)(X,Y)(X,Y) 是随机变量，遵循联合分布 P(X,Y)P(X,Y)P(X,Y)，所以损失函数的期望是：Rexp(f)=Ep[L(Y,f(X))]=∫x×yL(y,f(x))P(x,y)dxdyR_{exp}(f) = E_p[L(Y,f(X))] = \\int_{x \\times y}L(y,f(x))P(x,y)dxdyRexp​(f)=Ep​[L(Y,f(X))]=∫x×y​L(y,f(x))P(x,y)dxdy这是理论上模型平均意义上的损失，称为风险函数（risk function）或期望损失（expected loss）。学习的目标是选择期望风险最小的模型，由于联合分布 P(X,Y)P(X,Y)P(X,Y) 是未知的，Rexp(f)R_{exp}(f)Rexp​(f) 不能直接计算。所以监督学习就成为一个病态问题（ill-formed problem）。模型 f(X)f(X)f(X) 关于训练数据集的平均损失称为经验风险（empirical risk）或经验损失（empirical loss），记作 RempR_{emp}Remp​：Remp(f)=1N∑i=1NL(yi,f(xi))R_{emp}(f) = \\frac{1}{N}\\sum_{i=1}^{N}L(y_i,f(x_i))Remp​(f)=N1​i=1∑N​L(yi​,f(xi​))根据大数定律，当样本容量 NNN 趋于无穷时，经验风险趋于期望风险。但是，因为训练样本数目有限，甚至很小，所以用经验风险估计期望风险常常不理想。要对经验风险进行一定的矫正。这就关系到监督学习的两个基本策略：经验风险最小化和结构风险最小化。 经验风险最小化与结构风险最小化经验风险最小化（empirical risk minimization，ERM）策略认为，经验风险最小的模型是最优的模型。根据这一策略，按照经验风险最小化求最优模型就是求解最优化问题：minf∈F1N∑i=1NL(yi,f(xi))\\underset{f \\in F}{min}\\frac{1}{N}\\sum_{i=1}^{N}L(y_i,f(x_i))f∈Fmin​N1​i=1∑N​L(yi​,f(xi​))当样本容量足够大时，经验风险最小化能保证由很好的学习效果，在现实中被广泛使用。比如，极大似然估计（maximum likelihood estimation）就是经验风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。但是，当样本容量很小时，经验风险最小化学习的效果未必很好，会产生“过拟合”（over-fitting）现象。结构风险最小化（structural risk minimization，SRM）是为了防止过拟合而提出来的策略。结构风险最小化等价于正则化（regularization）。结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term）。在假设空间、损失函数以及训练数据集确定的情况下，结构风险的定义是：Rsrm(f)=1N∑i=1NL(yi,f(xi))+λJ(f)R_{srm}(f)=\\frac{1}{N}\\sum_{i=1}^{N}L(y_i,f(x_i)) + \\lambda J(f)Rsrm​(f)=N1​i=1∑N​L(yi​,f(xi​))+λJ(f)其中 J(f)J(f)J(f) 为模型的复杂度，是定义在假设空间 FFF 上的泛函。模型 fff 越复杂，复杂度 J(f)J(f)J(f) 就越大。也就是说，复杂度表示了对复杂模型的惩罚，λ≥0\\lambda \\ge 0λ≥0 是系数，用以权衡经验风险和模型复杂度。结构风险小需要经验风险与模型复杂度同时小。结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。比如，贝叶斯估计中的最后后验概率估计（maximum posterior probability estimation，MAP）就是结构风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数，模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。结构风险最小化的策略认为结构风险最小的模型是最优模型。所以求最优模型，就是求解最优化问题：minf∈F1N∑i=1NL(yi,f(xi))+λJ(f)\\underset{f \\in F}{min}\\frac{1}{N} \\sum_{i=1}^{N} L(y_i,f(x_i)) + \\lambda J(f)f∈Fmin​N1​i=1∑N​L(yi​,f(xi​))+λJ(f)这样，监督学习问题就变成了经验风险或结构风险函数的最优化问题。这时，经验或结构风险函数是最优化的目标函数。 算法算法指学习模型的具体计算方法。统计学习问题归结为最优化问题，统计学习的算法称为求解最优化问题的算法。如果最优化问题又显式的解析解，这个最优化问题比较简单，但通常解析解不存在，这就需要用数值计算的方法求解。如何保证找到全局最优解，并使求解的过程非常高效，就成为一个重要问题。 模型评估与模型选择 训练误差与测试误差当损失函数给定时，基于损失函数的模型的训练误差（training error）和模型的测试误差（test error）就自然成为学习方法的评估的标准。假设学习到的模型是 Y=f^(x)Y=\\hat{f}(x)Y=f^​(x),训练误差是模型关于训练数据集的平均损失：Reinp(f^)=1N∑i=1NL(yi,f^xi)R_{einp}(\\hat{f}) = \\frac{1}{N} \\sum_{i=1}^{N} L(y_i,\\hat{f}{x_i})Reinp​(f^​)=N1​i=1∑N​L(yi​,f^​xi​)测试误差是模型关于测试数据集的平均损失：etest(f^)=1N∑i=1NL(yi,f^xi)e_{test}(\\hat{f}) = \\frac{1}{N} \\sum_{i=1}^{N} L(y_i,\\hat{f}{x_i})etest​(f^​)=N1​i=1∑N​L(yi​,f^​xi​)例如，当损失函数是0-1损失时，测试误差就变成了常见的测试数据集上的误差率（error rate）：e_{test}(\\hat{f}) = \\frac{1}{N^&#039;} \\sum_{i=1}^{N^&#039;} I(y_i \\neq \\hat{f}{x_i})这里的 III 是指示函数（indicator function），即 y≠f^(x)y \\neq \\hat{f}(x)y​=f^​(x) 时为1，否则为0。相应地，常见的测试数据集上的准确率（accuracy）为：r_{test}(\\hat{f}) = \\frac{1}{N^&#039;} \\sum_{i=1}^{N^&#039;} I(y_i \\eq \\hat{f}{x_i})显然，rtest+etest=1r_{test} + e_{test} = 1rtest​+etest​=1。测试误差反映了学习方法对未知的测试数据集的预测能力。测试误差小的方法具有更好的预测能力，是更有效的方法。通常将学习方法对未知数据的预测能力称为泛化能力(generalization ability)。 过拟合与模型选择当假设空间含有不同的复杂度的模型时候，就要面临模型选择（model selection）的问题。如果意味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高，这种现象称为过拟合（over-fitting）。过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但对未知数据预测很差的现象。考虑对多项式函数拟合问题，用0-9次多项式函数对数据进行拟合。设 MMM 次多项式为：fM(x,w)=w0+w1x+w2x2+...+wMxM=∑j=0Mwjxjf_M(x,w) = w_0 + w_1x + w_2x^2 + ... + w_Mx^M = \\sum_{j=0}^{M}w_jx_jfM​(x,w)=w0​+w1​x+w2​x2+...+wM​xM=j=0∑M​wj​xj​使用平方损失损失函数，求以下经验风险最小化：L(w)=1N∑i=1N(f(xi,w)−yi)2L(w) = \\frac{1}{N} \\sum_{i=1}^{N}(f(x_i, w) - y_i)^2L(w)=N1​i=1∑N​(f(xi​,w)−yi​)2为了运算方便，我们系数使用 12\\frac{1}{2}21​。这是一个简单的最优化问题，将模型与训练数据带入：L(w)=12∑Ni=1(∑j=0Mwjxij−yi)2L(w) = \\frac{1}{2} \\sum_{N}^{i=1} (\\sum_{j=0}^{M} w_j x_i^j - y_i)^2L(w)=21​N∑i=1​(j=0∑M​wj​xij​−yi​)2对 wjw_jwj​ 求偏导数并令其为0，可得：wj=∑i=1Nxiyi∑i=1Nxij+1w_j = \\frac{\\sum_{i=1}^{N} x_i y_i}{\\sum_{i=1}^{N} x_i^{j+1}}wj​=∑i=1N​xij+1​∑i=1N​xi​yi​​如果 M=0M=0M=0，多项式曲线是一个常数，数据拟合效果很差；如果 M=1M=1M=1，多项式曲线是一条直线，数据拟合效果也很差；相反，如果 M=9M=9M=9，多项式曲线通过每个数据点，训练误差为0.从给定训练数据拟合的角度来说，效果是最好的。但是，因为训练数据本身存在噪声，这种拟合曲线对未知数据的预测能力往往不是最好的，这时候过拟合现象就会发生。当 M=3M=3M=3，多项式曲线对训练数据拟合效果足够好，模型也比较简单，是一个较好的选择。当模型复杂度增大时，训练误差会逐渐减小并趋向于0；而测试误差会先减小，达到最小值后又增大。当选择的模型复杂度，过拟合现象就会发生。两种常用的模型选择方法是：正则化和交叉验证。 正则化与交叉验证 正则化模型选择的典型方法是正则化（regularization）。正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项（regularizer）或罚项（penalty term）。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。比如，正则化项可以是模型参数向量的范数。正则化一般具有如下形式：minf∈F1N∑i=1NL(yi,f(xi))+λJ(f)\\underset{f \\in F}{min} \\frac{1}{N} \\sum_{i=1}^{N} L(y_i, f(x_i)) + \\lambda J(f)f∈Fmin​N1​i=1∑N​L(yi​,f(xi​))+λJ(f)正则化项可以取不同的形式。例如，回归问题中，损失函数是平方损失，正则化项可以是参数向量的 L2L_2L2​ 范数：L(w)=1N∑i=1N(f(xi;w)−yi)2+λ2∣∣w∣∣2L(w) = \\frac{1}{N} \\sum_{i=1}^{N} (f(x_i;w) - y_i)^2 + \\frac{\\lambda}{2} \\vert\\vert w \\vert\\vert^2L(w)=N1​i=1∑N​(f(xi​;w)−yi​)2+2λ​∣∣w∣∣2正则化的作用是选择经验风险与模型复杂度同时较小的模型。正则化符合奥卡姆剃刀（Occam‘s razor）原。奥卡姆剃刀原理应用于模型选择时：在所有可能选择的模型中，能够很好地解释已知数据并且十分简单才是最好的模型，也是应该选择的模型。从贝叶斯估计角度来看，正则化项对应于模型的先验概率，可以假设复杂的模型有较大的先验概率，简单的模型有较小的先验概率。 交叉验证令中常用的模型选择方法是交叉验证（cross validation）。如果给定的样本数据充足，进行模型选择的一种简单方法是随机地将数据集切分成三部分，分别为训练集（training set），验证集（validation set）和测试集（test set）。训练集用来训练模型，验证集用于模型的选择，而测试集用于最终对学习方法的评估。在学习到的不同复杂度的模型中，选择对验证集有最小预测误差的模型。由于验证集有足够多的数据，用它对模型进行选择也是有效的。但是，许多情况下数据是不充足的。为了选择好的模型，可以采用交叉验证的方法。交叉验证的基本想法是重复地利用数据：把给定的数据进行切分，将切分的数据集组合成训练集与测试集，在此基础上反复地进行训练、测试以及模型选择。 简单交叉验证首先随机地将已给数据分成两部分，一部分作为训练集，另一部分作为测试集（例如，70%数据作为训练集，30%数据作为测试集）。然后利用训练集在各种条件下（例如，不同的参数个数）训练模型，从而得到不同的模型。在测试集上评价各个模型的测试误差，选出测试误差最小的模型。 S折交叉验证应用最多的是S折交叉验证（S-fold cross validation），方法如下：首先随机地将已给的数据切分为S个互不相交大小相同的子集。然后利用S-1个子集的数据训练模型，利用余下的子集测试模型。将这一过程对可能的S种选择重复进行。最后选出S此评测中平均测试误差最小的模型。 留-交叉验证S折交叉验证的特殊情形是 S=NS = NS=N，称为留-交叉验证（leave-one-out cross validation），往往在数据缺乏的情况下使用。这里，N是给定数据集的容量。 泛化能力 泛化误差学习方法的泛化能力（generalization ability）是指由该方法学习到的模型对未知数据的预测能力，是学习方法本质上重要的性能。现实中采用最多的方法是通过测试误差来评价学习方法的泛化能力。因为测试数据集是有限的，很有可能由此得到的评价结果是可靠的。如果学习的模型是 f^\\hat{f}f^​，那么用这个模型对未知数据预测的误差即为泛化误差（generalization error）：Rexp(f^)=Ep[L(Y,f^(X))]=∫x×yL(y,f^(x))P(x,y)dxdyR_{exp}(\\hat{f}) = E_p[L(Y,\\hat{f}(X))] = \\int_{x \\times y} L(y,\\hat{f}(x))P(x,y)dxdyRexp​(f^​)=Ep​[L(Y,f^​(X))]=∫x×y​L(y,f^​(x))P(x,y)dxdy事实上，泛化误差就是锁学习到的模型的期望风险。 泛化误差上界学习方法的泛化能力分析往往是通过研究泛化误差的概率上界进行的，简称为泛化误差上界（generalization error bound）。泛化上界误差通常具有以下性质：它是样本容量的函数，当样本容量增加时，泛化上界趋于0；它是假设空间容量（capacity）的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大。 生成模型与判别模型监督学习方法可以分成生成方法（generative approach）和判别方法（discriminative approach）。生成方法由数据学习联合概率分布 P(X,Y)P(X, Y)P(X,Y)，然后求出条件概率分布 P(Y∣X)P(Y | X)P(Y∣X) 作为预测的模型，即生成模型：P(Y∣X)=P(X,Y)P(X)P(Y|X) = \\frac{P(X, Y)}{P(X)}P(Y∣X)=P(X)P(X,Y)​这种方法之所以称为生成方法，是因为模型表示了给定输入 XXX 产生输出 YYY 的生成关系。典型的生成模型由：朴素贝叶斯法和隐马尔科夫模型。判断方法由数据直接学习决策函数 f(x)f(x)f(x) 或者条件概率分布 P(Y∣X)P(Y|X)P(Y∣X) 作为预测的模型，即判别模型。判别方法关心的是对给定的输入 XXX，应该预测什么样的输出 YYY。典型的判别模型包括：K近邻法，感知机，决策数，逻辑斯地回归模型，最大熵模型，支持向量机，提升方法和条件随机场等。生成方法可以还原出联合概率分布 P(X,Y)P(X,Y)P(X,Y)，而判别方法则不能。生成方法的学习收敛速度更快，即当样本容量则加的时候，学到的模型和可以更快地收敛于真实的模型。当存在隐变量时，仍可以用生成方法学习。判别方法直接学习的是条件概率 P(Y∣X)P(Y|X)P(Y∣X) 或决策函数 f(X)f(X)f(X)，直接面对预测，往往学习的准确率更高。由于直接学习 P(Y∣X)P(Y|X)P(Y∣X) 或 f(X)f(X)f(X)，可以对数据进行各种程度上的抽象，定义特征并使用特征，因此可以简化学习问题。 分类问题分类是监督学习的一个核心问题。在监督学习中，当输出变量 YYY 取有限个离散值时，预测问题便成为分类问题。监督学习从数据中学习一个分类模型或分类决策函数，称为分类器（classifier）。分类器对新的输入进行输出的预测（prediction），称为分类（classification），可能的输出称为类（class）。分类问题包括学习和分类两个过程。在学习过程中，根据已知的训练数据集利用有效的学习方法学习一个分类器；在分类过程共，利用学习的分类器对新的输入实例进行分类。评价分类器性能的指标一般是分类准确率（accuracy），其定义是：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。对于二分类问题常用的评价指标是精确率（precesion）与召回率（recall）。通常以关注的类i为正类，其他类为负类，分类器在测试数据集上的预测或正确或不正确，4种情况出现的总数分别记作：TPTPTP:将正类预测为正类数FNFNFN:将正类预测为负类数FPFPFP:将负类预测为正类数TNTNTN:将负类预测为负类数精确率的定义为：P=TPTP+FPP = \\frac{TP}{TP+FP}P=TP+FPTP​召回率定义为：R=TPTP+FNR = \\frac{TP}{TP+FN}R=TP+FNTP​此外还有 F1F_1F1​ 值，是精确率和召回率的调和均值，即：2F1=1P+1R\\frac{2}{F_1} = \\frac{1}{P} + \\frac{1}{R}F1​2​=P1​+R1​F1=2TP2TP+FP+FNF_1 = \\frac{2TP}{2TP+FP+FN}F1​=2TP+FP+FN2TP​精确率和召回率都高时，F1F_1F1​ 值也会高。 标注问题标注（tagging）也是一个监督学习问题。可以认为标注问题是分类问题的一个推广，标注问题又是更复杂的结构预测（structure prediction）问题的简单形式。标注问题的输入是一个观测序列，输出是一个标记序列或状态序列。标注问题的目标在与学习一个模型，使它能够对观测序列给出标记序列作为预测。学习系统基于训练数据集构建一个模型，表示为条件概率分布：P(Y(1),Y(2),...,Y(n)∣X(1),X(2),...,X(n))P(Y^{(1)},Y^{(2)},...,Y^{(n)} | X^{(1)},X^{(2)},...,X^{(n)})P(Y(1),Y(2),...,Y(n)∣X(1),X(2),...,X(n))这里，每一个 X(i)X^{(i)}X(i) 取值为所有可能的观测，每一个 Y(i)Y^{(i)}Y(i) 取值为所有可能的标记，一般 n&lt;&lt;Nn &lt;&lt; Nn&lt;&lt;N。标注系统按照学习得到的条件概率分布模型，对新的输入观测序列找到相应的输出标记序列。标记常用的统计学习方法有：隐马尔科夫模型，条件随机场。标注问题在信息抽取，自然语言处理等领域被广泛应用，是这些领域的基本问题。例如，自然语言处理中的词性标注（part of speech tagging）就是一个典型的标注问题：给定一个由单词组成的句子，对这句子中的每一个单词进行词性标注。 回归问题回归（regression）是监督学习的一个重要问题。回归用于预测输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。回归模型正是表示从输入变量到输出变量之间映射的函数。回归问题的学习等价于函数拟合：选择一条函数曲线使其很好地拟合已知数据且很好地预测未知数据。回归问题按照输入变量的个数，分为一元回归和多元回归。按照输入变量和输出变量之间关系的类型即模型的类型，分为线性回归和非线性回归。回归学习最常用的损失函数是平方损失函数，在此情况下，回归问题可以由著名的最小二乘法（least squares）求解。","categories":[{"name":"统计机器学习","slug":"统计机器学习","permalink":"https://hengxincheung.github.io/categories/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"21-并发","slug":"Java编程思想/21-并发","date":"2020-07-03T13:31:04.000Z","updated":"2020-07-03T13:31:40.550Z","comments":true,"path":"Java编程思想/21-并发/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/21-%E5%B9%B6%E5%8F%91/","excerpt":"","text":"编程问题相当打的一部分都可以通过使用 顺序编程 来解决。然而，如果能够并行地执行程序中的多个部分，则会变得非常方便甚至非常必要，因为这些部分要么看起来在并发地执行，要么在多处理器环境下可以同时执行。并行编程 可以使程序执行速度得到极大提高，或者为设计某些类型的程序提供更易用的模式，或者两者皆有。 并发的多面性用并发解决的问题大体可以分为“速度”和“设计可管理性”两种。 更快的执行并发是用于多处理器编程的基本工具。当前，Moore（摩尔）定律已经有些过时，速度提高是以多核处理器的形式而不是更快的芯片形式出现。为了使得程序运行得更快，你必须学习如何利用这些额外的处理器，而这正是并发赋予你的能力。并发通常是提高运行在 单处理器 上的程序的性能。虽然，并发程序开销确实比顺序程序的开销大，因为增加了 上下文切换 （从一个任务切换到另一个任务）的代价。但是 阻塞 使得这个问题变得不同。如果程序中的某个任务因为该程序控制范围之外的某些条件（通常是IO）而导致不能继续执行，那么就说这个任务或线程阻塞了。如果没有并发，则整个程序都将停下来，直至外部条件发生变化。但是，如果使用并发来编写程序，那么当一个任务阻塞时，程序中的其他任务还可以继续执行，因此这个程序可以保持继续向前执行。当然，如果没有任务会阻塞，那么在单处理器上使用并发就没有任何意义。在单处理器系统的性能提高的常见示例是 事件驱动 的编程。实际上，使用并发最吸引人的一个原因就是产生具有可响应的用户界面。通过创建单独的执行线程来响应用户的输入，即使这个线程在大多数时间里都是阻塞的，但是程序可以保证具有一定程度的可响应性。实现 并发 最直接的方式是在操作系统级别使用 进程。进程是运行在它自己的地址空间自包容的程序。多任务操作系统可以通过周期性地将CPU从一个进程切换到另一个进程，来实现同时运行多个进程（程序）。进程总是很吸引人的，因为操作系统通常会将进程互相隔离开，这使得用进程编程相对容易。与此相反，像Java所使用的这种并发系统会共享内存和IO这样的资源，因此编写多线程程序最基本的困难在于协调不同线程驱动的任务之间对这些资源的使用，以使得这些资源不会同时被多个任务访问。某些编程语言被设计为可以将并发任务彼此隔离，这些语言通常被称为 函数型语言，其中每个函数调用都不会产生任何副作用。如Erlang，它包含针对任务之间彼此通信的安全机制。Java采取更加传统的方式，在顺序型语言的基础上提供对线程的支持。线程机制是在执行程序表示的单一进程中创建任务。Java的线程机制是抢占式的，这表示调度机制会周期性地终端线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。并发需要符出代价，包含复杂性代价。但是这些代价与在程序设计，资源负载均衡以及用户方便使用方面的改进相比，就显得微不足道。通常，线程使得你能够创建更加松散耦合的设计。 基本的线程机制并发编程使我们可以将程序划分为多个分离，独立运行的任务。通过使用多线程机制，这些独立任务（子任务）中的每一个都将由 执行线程 来驱动。一个线程就是在进程中的一个单一的顺序控制流。因此，单个进程可以拥有多个并发执行的任务。线程模型简化了在单一程序中同时交织在一起的多个操作的处理。使用线程机制是一种建立透明的，可扩展的程序的方法。多任务和多线程往往是使用多处理器系统的最合理方式。 定义任务线程可以驱动任务，因此你需要一种描述任务的方式，这可以由 Runnable 接口来提供。只需要实现 Runnable 接口并编写 run() 方法，就可使得该任务可以执行你的命令。1234567891011121314151617181920public class LiftOff implements Runnable &#123; protected int countDown = 10; private static int taskCount = 0; private final int id = taskCount++; public LiftOff() &#123;&#125; public LiftOff(int countDown) &#123; this.countDown = countDown; &#125; public String status() &#123; return \"#\" + id + \"(\" + (countDown &gt; 0 ? countDown : \"Liftoff!\") +\")\"; &#125; public void run() &#123; while(countDown -- &gt; 0) &#123; System.out.pritnln(status()); Thread.yield(); // 放弃剩余的时间片，等待下一次调度 &#125; &#125;&#125;任务的 run() 方法通常总会有某种形式的循环，使得任务一直运行下去直到不再需要。通常，run() 被写成无限循环的形式。静态方法 Thread.yield() 方法是对 线程调度器 （Java线程机制的一部分，可以将CPU从一个线程转移给零一线程）的一种建议：我已经执行完生命周期中最重要的部分，此刻正是切换给其他任务执行一段时间的大好时机。 Thread 类将 Runnable 对象转变为工作任务的传统法师是把它提交给一个 Thread 构造器：123456public class BasicThreads &#123; public static void main(String[] args) &#123; Thread t = new Thread(new LiftOff()); t.start(); &#125;&#125;Thread 构造器只需要一个 Runnable 对象。调用 Thread 对象的 start() 方法为该线程执行必须的初始化操作，然后调用 Runnable 的 run() 方法以便在这个新线程中启动该任务。在这里，程序会同时运行两个方法，main() 和 LiftOff.run() 是程序中与其他线程“同时”执行的代码。如果在你的机器上有多个处理器，线程调度器将会在这些处理器之间默默地分发线程。线程调度机制是非确定性的，不同版本的JDK之间也有较大的差异。例如，较早的JDK不会频繁对时间切片，较晚的JDK看起来会产生更好的时间切片行为。 使用 ExecutorJava SE5的 java.util.concurrent 包中的 执行器（Executor） 将为你管理 Thread 对象，从而简化了并发编程。 Executor 在客户端和任务执行之间提供了一个间接层。与客户端直接执行任务不同，这个中介对象将执行任务。``Executor允许你管理异步任务的执行，而无需显式地管理线程的生命周期。Executor` 在Java SE5/6中是启动任务的优选方法。ExecutorService (具有服务生命周期的 Executor，例如关闭)知道如何构建恰当的上下文来执行 Runnable 对象。注意：ExecutorService 对象是使用静态的 Executor 方法创建的。123456789public class CachedThreadPool &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); for(int i=0;i&lt;5;i++) &#123; exec.execute(new LiftOff()); &#125; exec.shutdown(); &#125;&#125;非常常见的情况是，单个的 Executor 被用来创建和管理系统中的所有任务。对 shutdown() 方法的调用可以防止新任务被提交给这个 Executor，当前线程将继续运行在 shutdown() 被调用之前提交的所有任务。当然，还有很多不同类型的 Executor。如 FixedThreadPool 使用了有限的线程集来执行所提交的任务：123456789public class FixedThreadPool &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newFixedThreadPool(5); for(int i=0;i&lt;5;i++) &#123; exec.execute(new LiftOff()); &#125; exec.shutdown(); &#125;&#125;有了 FixedThreadPool，你就可以一次性预先执行代价高昂的线程分配，因而也可以有限制线程的数量。这可以节省时间，因为你不用为每个任务都固定地付出创建线程的开销。在事件驱动的系统中，需要线程的事件处理器，通过直接从池中获取线程，也可以如你所愿地尽快得到服务。你不会滥用可获得的资源，因为线程对象的数量是有限的。注意，在任何线程中，现有线程在可能的情况下，都会被自动的复用。一般情况下，我们都会选用 CachedThreadPool，它在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因为它是合理的 Executor 的首选。SingleThreadExecutor 就像是线程数量为1的 FixedThreadPool。这对于你希望在另一个线程中连续运行的任何事物（长期存活的任务）来说，都是很有用的。例如监听进入的套接字连接的任务。如果向 SingleThreadExecutor 提交了多个任务，那么这些任务将排队，每个任务都会在下一个任务开始之前运行结束，所有的任务将使用相同的线程。123456789public class SingleThreadExecutor &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newSingleThreadExecutor(); for(int i=0;i&lt;5;i++) &#123; exec.execute(new LiftOff()); &#125; exec.shutdown(); &#125;&#125;假设你有大量运行的任务将使用文件系统，可以使用 SIngleThreadExecutor 来运行这些线程，以确保任意时刻在任何线程中都只有唯一的任务在运行。在这种方式中，你不需要在共享资源上处理同步，同时不会过度使用文件系统。 从任务中产生返回值Runnable 是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成时能够返回一个值，那么可以实现 Callable 接口。在Java SE5中引入的 Callable 是一种具有类型参数的泛型，它的类型参数表示的是从方法 call() 中返回的值，并且必须使用 ExecutorService.submit() 方法调用它。1234567891011121314151617181920212223242526272829303132class TaskWithResult implements Callable&lt;String&gt; &#123; private int id; public TaskWithResult(int id) &#123; this.id = id; &#125; public String call() &#123; return \"result of TaskWithResult \" + i; &#125;&#125;public class CallableDemo &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); List&lt;Future&lt;String&gt;&gt; results = new ArrayList&lt;&gt;(); for(int i=0;i&lt;5;i++) &#123; result.add(exec.submit(new TaskWithResult(i))); &#125; for(Future&lt;String&gt; fs : results) &#123; try &#123; // get() 方法会阻塞直至任务返回结果 System.out.println(fs.get()); &#125; catch(InterruptedException e) &#123; System.out.println(e); &#125; catch(ExecutionException e) &#123; System.out.println(e); &#125; finally &#123; exec.shutdown(); &#125; &#125; &#125;&#125;submit() 方法会产生 Future 对象，它用 Callable 返回结果的特定类型进行了参数化。你可以用 isDone() 方法来查询 Future 是否已经完成。当任务完成时，它具有一个结果，你可以调用 get() 方法来获取该结果。你也可以不检查直接调用 get() 方法，在这种情况下，将阻塞直至结果准备就绪。你还可以调用具有超时的 get() 方法。 休眠影响任务行为的一种方法是调用 sleep()，这将使任务中止执行给定的时间。1234// 旧的方式Thread.sleep(100); // 单位:ms// Java SE5/6 的方式TimeUnit.MILLISECONDS.sleep(100);对 sleep() 的调用可以调用 InterruptedException，因为异常不能跨线程传播，所以你必须在本地处理所有在任务内部产生的异常。Java SE5引入了更加显式的 sleep() 版本，作为 TimeUnit 类的一部分。这个方法允许你指定 sleep() 延迟的时间单元，因此可以提供更好的可阅读性。TimeUnit 还可以被用来执行转换。 优先级线程的 优先级 将该线程的重要性传递给了调度器。调度器倾向于让优先权最高的线程先执行。然而，这不是意味着优先权较低的线程将得不到执行，也就是说，优先权不会导致死锁。在绝大多数时间里，所有线程都应该以默认的优先级运行。试图操作线程优先级通常是一种错误。你可以使用 getPriority() 来读取现有线程的优先级，并且在任何时刻都可以通过 setPrority() 来修改它。你也可以在一个任务内部，通过调用 Thread.currentThread() 来获得驱动该任务的 Thread 对象的引用。尽管JDK有10个优先级，但它与多数操作系统都不能映射得很好。唯一可移植的方法是当调整优先级的时候，只使用 MAX_PRIORITY, NORM_PRIORITY, MIN_PRIORITY 三种级别。 让步如果知道已经完成了在 run() 方法的循环的一次迭代过程中所需的工作，就可以给线程调度机制一个暗示：可以让别的线程使用CPIU了。这个暗示将通过调用 yield() 方法来作出（这仅仅是一个暗示，没有任何机制保证它一定会被采纳）。当调用 yield() 时，你也是在建具有 相同优先级 的其他线程可以运行。 后台线程所谓 后台（daemon）线程，是指程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台进程。反过来说，只要有任何非后台线程在运行，程序就不会终止。比如，执行 main() 就是一个非后台线程。12345678910111213141516171819202122public class SimpleDaemons implements Runnable &#123; public void run() &#123; try &#123; while(true) &#123; TimeUnit.MILLISECONDS.sleep(100); System.out.println(Thread.currentThread() + \" \" + this); &#125; &#125; catch(InterruptedException e) &#123; System.out.println(\"Interupted!\") &#125; &#125; public static void main(String[] args) throws Exception&#123; for(int i=0;i&lt;10;i++) &#123; Thread daemon = new Thread(new SimpleDaemons()); daemon.setDarmon(True); // 必须在start()方法前调用 daemon.start(); &#125; System.out.println(\"All daemons started!\") TimeUnit.MILLISECONDS.sleep(200); &#125;&#125;通过编写定制的 ThreadFactory 可以定制由 Executor 创建的线程的属性（后台，优先级，名称）:1234567public class DaemonThreadFactory implements ThreadFactory &#123; public Thread newThread(Runnable r) &#123; Thread t = new Thread(r); t.setDaemon(true); return t; &#125;&#125;现在你可以使用一个新的定制的 ThreadFactory 作为参数传递给 Executor。每个静态的 ExecutorService 创建方法都被重载为接受一个 ThreadFacotry 对象，而这个对象将被用来创建新的线程。还有一点值的注意，如果是一个后台线程，那么它创建的任何线程都将会被自动设置成后台线程。你可以使用 isDaemon() 方法来确定一个线程是否后台线程。 加入一个线程一个线程可以在其他线程只上调用 join() 方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程 t 上调用了 join()，此线程将会被挂起，直到目标线程 t 结束才恢复（即 t.isAlive() 返回为假）。也可以在调用 join() 时带上一个超时参数（单位可以是毫秒或者毫秒和纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join() 方法总能返回。对 join() 方法的调用可以被中断，做法是在调用线程上调用 interrupt() 方法。 捕获异常由于线程的本质特性，使得你不能捕获从线程中逃逸的异常。一旦异常逃出任务的 run() 方法，它就会向外传播到控制台。在Java SE5中你可以使用 Executor 来解决这个问题。Thread.UncaughtExceptionHandler 是Java SE5中的新接口，它允许你在每个 Thread 对象上都附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException() 会在线程因未捕获的异常而临近死亡时被调用。123456789101112131415class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123; public void uncaughtException(Thread t, Throwable e) &#123; System.out.println(\"caught: \" + e); &#125;&#125;class HandlerThreadFactory implements ThreadFactory &#123; public Thread newThread(Runnable r) &#123; System.out.println(this + \" creating new Thread!\"); Thread t = new Thread(); System.out.println(\"created \" + t); t.setUncaughtExceptionHandler(new MyUNcaughtExceptionHandler()); return t; &#125;&#125; 共享受限资源有了并发就可以同时做多件事，两个或多个线程彼此互相干涉的问题也就出现了。 不正确地访问资源考虑下面的例子，其中一个任务产生偶数，而其他任务消费这些数字。这里，消费者任务的为一工作就是检查偶数的有效性。123456public abstract class IntGenerator &#123; private volatile boolean canceled = false; public abstract int next(); public void cancel() &#123;canceled = true;&#125; public boolean isCanceled() &#123;return canceled;&#125;&#125;canceled 标志是 boolean 类型的，所以它是原子性的，即诸如赋值和返回值这样的简单操作在发生时没有中断的可能。为了保证可视性，canceled 标志还是 volatile 的。123456789101112131415161718192021222324252627public class EvenChecker implements Runnable &#123; private IntGenerator generator; private final int id; public EvenChecker(IntGenerator g, int ident) &#123; generator = g; id = ident; &#125; public void run() &#123; while(!generator.isCanceled()) &#123; int val = generator.next(); if(val % 2 != 0) &#123; System.out.println(val + \" not even!\"); generator.cancel(); &#125; &#125; &#125; public static void test(IntGenerator gp, int count) &#123; System.out.println(\"Press Control-C to exit!\"); ExecutorService exec = Executors.newCachedThreadPool(); for(int i=0;i&lt;count;i++) &#123; exec.execute(new EvenChecker(gp, i)); &#125; exec.shutdown(); &#125;&#125;通过这种方式，共享公共资源（IntGenerator）的任务可以观察该资源的终止信号。这可以消除所谓竞争条件，即两个或更多的任务竞争响应某个条件，因此产生冲突或不一致结果的情况。下面编写可以产生一系列偶数值的具体类：12345678public class EvenGenerator extends IntGenerator &#123; private int currentEvenValue = 0; public int next() &#123; ++currentEvenValue; // 这里是危险的地方 ++currentEvenValue; return currentEventValue; &#125;&#125;递增程序自身需要多个步骤，并且在递增过程中任务可能会被线程机制挂起–也就是说，在Java中，递增不是 原子性 的操作。因此，如果不保护任务，即使单一的递增也不是安全的。 解决共享资源竞争防止冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被届锁之前，就无法访问它。而在其被解锁时，另一个任务就可以锁定并使用它，以此类推。基本上所有的并发模式在解决线程冲突问题的时候，都是采用 序列化访问共享资源 的方案。这意味着在给定时刻只允许一个任务访问共享资源。通常这是通过在代码前面加上一条锁语句来实现的。因为锁语句产生了一种互相排斥的效果，所以这种机制常常称为 互斥量（mutex）。Java以提供关键字 synchronized 的形式，为防止资源冲突提供了内置支持。当任务要执行被 synchronized 关键字保护的代码片段的时候，它将检查锁是否可用，然后获取锁，执行代码，释放锁。共享资源一般是以对象形式存在的内存片段，但也可以是文件，输入/输出端口，或者是打印机。要控制对共享资源的访问，得先把它包装进一个对象。然后把所有要访问这个资源的方法标记为 synchronized。所有对象都自动含有单一的锁(也成为监视器)。当在对象上调用其任意 synchronized 方法的时候，此对象都被加锁，这时该对象上其他的 synchronized 方法只有等到前一个方法调用完毕并释放了锁之后才能被调用。所以，对于某个特定对象来说，其所有 synchronized 方法共享同一个锁，这可以被用来防止多个任务同时访问被编码为对象内存。注意，在使用并发时，将域设置为 private 非常重要，否则，synchronized 关键字就不能防止其他任务直接访问域，这样就会产生冲突。一个任务可以多次获得对象的锁。JVM负责跟踪对象被加锁的次数。如果一个对象被解锁（即锁被完全释放），其计数变为0。每当任务离开一个 synchronized 方法，计数递减，当计数为零的时候，锁被完全释放，此时别的任务就可以使用此资源。针对每个类，也有一个锁（作为类的 Class 对象的一部分），所以 synchronized static 方法可以在类的范围内防止对 static 数据的并发访问。123456789public class SynchronizedEvenGenerator extends IntGenerator &#123; private int currentEvenValue = 0; public synchronized int next() &#123; ++currentEvenValue; Thread.yield(); ++currentEvenValue; return currentEvenValue; &#125;&#125;因为互斥可以防止多个任务同时进入临界区，所以这不会产生任何失败。Java SE5的 java.util.concurrent 类库还包含由定义在 java.util.concurrent.locks 中的显式的互斥机制。Lock 对象必须被显式地创建、锁定和释放。因此，它与内建的锁形式相比，代码缺乏优雅性。但是，对于解决某些类型的问题来说，它更灵活。123456789101112131415public class MutexEvenGenerator extends IntGenerator &#123; private int currentEvenValue = 0; private Lock lock = new ReentrantLock(); public int next() &#123; lock.lock(); try &#123; ++currentEventValue; Thread.yield(); ++currentEvenValue; return currentEvenValue; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;使用 lock() 和 unlock() 方法创建了临界资源。当你在使用 Lock 对象时，你必须防止在 finally 子句中带有 unlock() 以确保锁一定会被释放，否则有可能造成死锁。同时，return 语句必须在 try 子句中出现，以确保 unlock() 不会过早的发生。显式的 Lock 对象可以使用 finally 子句将系统维护在正确的状态。而 synchronized 关键字，某些事物失败了，就会抛出一个异常，但是你没有机会区做任何清理工作。大体上，当你使用 synchronized 关键字时，需要写的代码量更少，并且用户错误出现的可能性也会降低，因此通常只有在解决特殊问题时，才使用显式的 Lock 对象。例如，用 synchronized 关键字不能尝试着获取锁且最终获取锁会失败，或者尝试获取锁一段时间，然后放弃它，要实现这些，你必须使用 concurrent 类库：12345678910111213141516171819202122232425262728public class AttemptLocking &#123; private ReentrantLock lock = new ReentrantLock(); public void untimed() &#123; boolean captured = lock.tryLock(); try &#123; System.out.println(\"tryLock(): \" + captured); &#125; finally &#123; if(captured) &#123; lock.unlock(); &#125; &#125; &#125; public void timed() &#123; boolean captured = false; try &#123; captured = lock.tryLock(2, TimeUnit.SECONDS); System.out.println(\"tryLock(2, TimeUnit.SECONDS): \" + captured); &#125; catch(InterruptedException e) &#123; throw new RuntimeException(e); &#125; finally &#123; if(captured) &#123; lock.unlock(); &#125; &#125; &#125; &#125;ReentrantLock 允许你尝试着获取但最终未获取锁。显式的 Lock 对象在加锁和释放锁方面，相对于内建的 synchronized 锁来说，还赋予了你更细粒度的控制力。这对于实现专有同步结构是很有用的，例如用于遍历链接列表中的节点的 节节传递的加锁机制（也称为锁耦合），这种遍历代码必须在释放当前节点的锁之前捕获下一个节点的锁。 原子性与易变性一个常不正确的知识是“原子操作不需要进行同步控制”。原子操作 是不能被线程调度机制中断的操作，一旦操作开始，那么它一定可以在可能发生的“上下文切换”之前执行完毕。依赖于原子性是很棘手而且很危险的。原子性可以应用于除 long 和 double 之外的所有基本类型之上的“简单操作”。JVM将64位（long 和 double 变量）的读取和写入当作两个分离的32位操作来执行，这就产生了在一个读取和写入操作中间发生上下文切换的可能性。但是，当你定义 long 或 double 变量时，如果使用 volatile 关键字，就会获得原子性。因此，原子操作可由线程机制来保证其不可中断。专家级程序员可以利用这一点来编写 无锁 的代码，这些代码不需要同步。在多处理器系统上，可视性 问题远比原子性问题多得多。volatile 关键字还确保了应用中的可视性。如果你将一个域声明为 volatile 的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。即便使用了本地缓存，volatile 域会立即被写入到主存中，而读操作就发生在主存中。在非 volatile 域上的原子操作不必刷新到主存中区，因此其他读取该域的任务也不必看到这个新值。如果多个任务在同时访问某个域，那么这个域就应该是 volatile 的。否则，这个域就应该只能经由同步来访问。同步也会导致向主存中刷新。使用 volatile 而不是 synchronized 的唯一安全的情况是类中只有一个可变的域。再次提醒，你的第一选择应该是使用 synchronized 关键字，这是最安全的方式。 原子类Java SE5引入了诸如 AtomicInteger, AtomicLong, AtomicReference 等特殊的原子性变量类，它们提供下面形式的原子性条件更新操作。1boolean compareAndSet(expectedValue, updateValue);这些类被调整为可以使用在某些现代处理器上的可获得的，并且是在机器级别上的原子性。对于常规编程，它们很少会派上用场，但是在涉及性能调优时，它们就大有用武之地。12345678910public class AtomicIntegerTest implements Runnable &#123; private AtomicInteger i = new AtomicInteger(0); public int getValue() &#123;return i.get();&#125; private void evenIncrement() &#123;i.addAndGet(2);&#125; public void run() &#123; while(true) &#123; evenIncrement(); &#125; &#125;&#125;应该强调的是，Atomic 类被设计用于构建 java.util.concurrent 中的类，因此只有在特殊情况下才在自己的代码中使用它们。通常依赖于锁要更安全一些，要么是 synchronized 关键字，要么是显式的 Lock 对象。 临界区有时，你希望防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。通过这种方式分离出来的代码被称为 临界区（critical section），它也使用 synchronized 关键字建立。123synchronized(syncObject) &#123; // 这里的代码同一时间只能被一个任务所访问&#125;这被称为 同步控制块。在进入此段代码前，必须得到 syncObject 对象的锁。如果其他线程已经得到这个锁，那么就得等到锁被释放后，才能进入临界区。通过使用同步控制块，而不是对整个方法进行同步控制，可以使多个任务访问对象的时间性能得到显著提高。 在其他对象上同步synchronized 块必须给定一个在其上进行同步的对象，并且最合理的方式是，使用其方法正在被调用的当前对象：synchronized(this)。在这种方式中，如果获得了 synchronized 块上的锁，那么该对象其他的 synchronized 方法和临界区就不能被调用。因此，如果在 this 上同步，临界区的效果就会直接缩小在同步的范围内。有时必须在另一个对象上同步，如果你要这么做，就必须确保所有相关任务都是在同一个对象上同步的。1234567891011121314class DualSynch &#123; private Object syncObject = new Object(); public synchronized void f() &#123; System.out.println(\"f()\"); TimeUnit.SECONDS.sleep(1); &#125; public void g() &#123; synchronized(syncObject) &#123; System.out.println(\"g()\"); TimeUNit.SECONDS.sleep(1); &#125; &#125;&#125;DualSync.f() （通过同步整个方法）在 this 同步，而 g() 有一个在 syncObject 上同步的 synchronized 块。因此，这两个同步是互相独立的。 线程本地存储防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享。线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。创建和管理线程本地存储可以由 java.lang.ThreadLocal 类来实现：12345678910111213141516171819202122232425262728293031323334353637383940class Accessor implements RUnnable &#123; private final int id; public Accessor(int id) &#123;this.id = id;&#125; public void run() &#123; while(!Thread.currentThread().isInterrupted()) &#123; ThreadLocalVariableHolder.increment(); System.out.println(this); Thread.yield(); &#125; &#125; public String toString() &#123; return \"#\" + id + \": \" + ThreadLocalVariableHolder.get(); &#125;&#125;public class ThreadLocalVariableHolder &#123; private static ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;&gt;() &#123; private Random rand = new Random(47); protected synchronized Integer initialValue() &#123; return rand.nextInt(10000); &#125; &#125;; public static void increment() &#123; value.set(value.get() + 1); &#125; public static int get() &#123;return value.get();&#125; public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); for(int i=0;i&lt;5;i++) &#123; exec.execute(new Accessor(i)); &#125; TimeUnit.SECONDS.sleep(10); exec.shutdown(); &#125;&#125;当运行这个程序时，你会看到每个单独的线程都会被分配了自己的存储，即便只有一个 ThreadLocalVariableHolder 对象。其实，你可以认为 ThreadLocal 就是一个 Map()，key是当前线程id，value就是你设置的值。然后每次你进行 get() 和 set() 操作时候都会使用 Thread.currentThread() 作为key去设置正确位置的值。 终止任务在某些情况下，任务必须更加突然地终止。 在阻塞时中终结一个线程可以处于以下四种状态之一：新建（new）：当线程被创建时，它只会短暂地处于这种状态。此时它已经分配必须的系统资源，并执行了初始化。此时线程已经由资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。就绪（Runnable）：在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。也就是说，在任意时刻，线程可以运行也可以不运行。只要调度器能分配时间片给线程，它就可以运行。阻塞（Block）：线程能够运行，但是某个条件阻止了它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会分配给线程任何CPU时间。直到线程重新进入了就绪状态，它才有可能执行操作。死亡（Dead）：处于死亡或终止状态的线程不再是可调度的，并且再也不会得到CPU时间。它的任务已结束，或不再是可运行的。任务死亡通常方式是从 run() 方法返回。但是任务的线程还可以被中断。一个任务进入阻塞状态，可能由如下原因：调用 sleep(milliseconds) 使任务进入休眠状态。在这种情况下，任务在指定的时间内不会运行。你通过调用 wait() 使线程挂起，直到线程得到 notify() 或 notifyAll() 消息，或者在Java SE5的 java.util.concurrent 类库中等价的 signal() 或 signalAll() 消息，线程才会进入就绪状态。任务在等待某个输入/输出完成。任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。 中断Thread 类包含 interrupt() 方法，因此你可以终止被阻塞的任务，这个方法将设置线程的中断状态。如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出 InterruptedException。当抛出该异常或者该任务调用 Thread.interrupted() 时，中断状态将被复位。为了调用 interrupt()，你必须持有 Thread 对象。但新的 concurrent 类库似乎在避免对 Thread 对象的直接操作，转而尽量通过 Executor 来执行所有操作。如果你在 Executor 上调用 shutdownNow()，那么它将发送一个 interrupt() 调用给它启动的所有线程。然而，你有时也会希望只中断某个单一任务。如果使用 Executor，那么通过调用 submit() 而不是 executor() 来启动任务，就可以持有该任务的上下文。submit() 将返回一个泛型 Future&lt;?&gt;。持有这种 Future 的关键在与你可以在其上调用 cancel()，并因此可以使用它来中断某个特定任务。如果你将 treu 传递给 cancel()，那么它就会拥有在该线程上调用 interrupt() 以停止这个线程的权限。因此，cancel() 是一种中断由 Executor 启动的单个线程的方式。 检查中断注意，当你在线程上调用 interrupt() 时，中断发生的唯一时刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部时（除了不可中断的I/O或被阻塞的 synchronized 方法之外）。如果你只能通过在阻塞调用上抛出异常来退出，那么你就无法总是可以离开 run() 循环。因此，如果你调用 interrupt() 以停止某个任务，那么在 run() 循环碰巧没有产生任何阻塞调用的情况下，你的任务将需要第二种方式来推出。这种机会是由中断状态来表示的，其状态可以通过调用 interrupt() 来设置。你可以通过调用 interrupted() 来检查中断状态。这不仅可以告诉你 interrupt() 是否被调用过，而且还可以清除中断状态。清除中断状态可以确保并发结果不会就某个任务被中断这个问题通知你两次，你可以经由单一的 InterruptedException 或单一的成功 Thread.interrupted() 测试来得到这种同志。12345678910111213class Blocked implements Runnable &#123; public void run() &#123; try &#123; while(!Thread.interrupted()) &#123; // do your job &#125; &#125; cathch(InterruptedException e) &#123; // handle exception &#125; finally &#123; // clean up &#125; &#125;&#125; 线程之间的协作当你使用线程来同时运行多个任务时，可以通过使用锁（互斥）来同步两个任务的行为，从而使得一个任务不会干涉另一个任务的资源。也就是说，如果两个任务交替着步入某项共享资源（通常是内存），你可以使用互斥来使得任何时刻只有一个任务可以访问这项资源。当任务协作时，关键问题是这些任务之间的握手。为了实现这种握手，我们使用了相同的基础特性：互斥。在这种情况下，互斥能够确保只有一个任务可以响应某个信号。在互斥之上，我们为任务添加了一种途径，可以将其自身挂起，直至某些外部条件发生变化。任务间的握手可以通过 Object 方法的 wait() 和 notify() 来安全实现。Java SE5的并发类库还提供了具有 await() 和 signal() 方法的 Condition 对象。 wait() 与 notifyAll()wait() 方法使你可以等待某个条件发生变化，而改变这个条件超出了当前方法的控制能力。通常，这种条件将由另一个任务来改变。你肯定不想你的任务测试这个条件的同时，不断地进行空循环，这被称为 忙等待，这是一种不良的CPU周期使用方式。因此 wait() 会在等待外部世界产生变化的时候将任务挂起，并且只有在 notify() 或 notifyAll() 发生时，这个任务才会被唤醒并去检查所产生的变化。因此，wait() 提供了一种在任务之间对活动同步的方式。调用 sleep() 和 yield() 的时候锁并没有被释放。当一个任务在方法里遇到了对 wait() 方法调用的时候，线程的执行被挂起，对象上的锁被释放。有两种形式的 wait()，第一种版本接受毫秒数作为参数，含义为在此期间等待。与 sleep() 不同的是：在 wait() 期间对象锁是释放的；可以通过 notify(), notifyAll(), 或者令时间到期，从 wait() 中恢复执行。第二种，也是更常用的 wait() 不接受任何参数。这种 wait() 将无限等待下去，直到线程接收到 notify() 或者 notifyAll() 的消息。这些方法是基类 Object 的一部分，而不是属于 Thread 的一部分。事实上，只能在同步控制方法或者同步控制块调用 wait(),notify(),notifyAll()。如果在非同步控制方法里调用这些方法，程序能通过编译，但运行的时候将会得到 IllegalMonitorStateException 异常，并伴随一些含糊的信息。 notify() 与 notifyAll()一般会有多个任务在单个对象上处于 wait() 状态，因此调用 notifyAll() 比只调用 notify() 要更安全。使用 notify() 而不是 notifyAll() 是一种优化。使用 notify() 时，在众多的等待同一个锁的任务中，只有一个会被唤醒。因此，如果你希望使用 notify(),就必须保证被唤醒的是恰当的任务。而 notifyAll() 会将等待这个锁的所有唤醒，并让它们去竞争。 生产者与消费者考虑以下场景：一个饭店有一个厨师和一个服务员，这个服务员必须等待厨师准备好膳食，当厨师准备好时，他会通知服务员上菜，然后返回继续等待。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Class Meal &#123; /* 膳食 */ private final int orderNum; public Meal(int orderNum) &#123;this.orderNum = orderNum;&#125; public String toString() &#123;return \"Meal \" + orderNum;&#125;&#125;class WaitPerson implements Runnable &#123; private Restaurant restaurant; public WaitPerson(Restaurant r) &#123;restaurant = r;&#125; public void run() &#123; try &#123; while(!Thread.interrupted()) &#123; synchronized(this) &#123; while(restaurant.meal == null) &#123; wait()l; // 等待厨师生产膳食 &#125; &#125; System.out.println(\"WaitPerson got \" + restaurant.meal); synchronized(restaurant.chef) &#123; restaurant.meal = null; restaurant.chef.notifyAll(); &#125; &#125; &#125; catch(InterruptedException e) &#123; System.out.println(\"WaitPerson interrupted!\"); &#125; &#125;&#125;class Chef implements Runnable &#123; private Restaurant restaurant; private int count = 0; public Chef(Restaurant r) &#123;restaurant = r;&#125; public void run() &#123; try &#123; while(!Thread.interrupted()) &#123; synchronized(this) &#123; while(restaurant.meal != null) &#123; wait(); // 等待膳食被拿走 &#125; if(++count == 10) &#123; System.out.println(\"Out of food, closing!\"); restaurant.exec.shutdownNow(); &#125; synchronized(restaurant.waitPerson) &#123; restaurant.meal = new Meal(count); restaurant.waitPerson.notifyAll(); &#125; TimeUnit.MILLISECONDS.sleep(100); &#125; &#125; &#125; catch(InterruptedException e) &#123; System.out.println(\"Chef interrupted\"); &#125; &#125;&#125;public class Restaurant &#123; Meal meal; ExecutorService exec = Executors.newCachedThreadPool(); WaitPerson waitPerson = new WaitPerson(this); Chef chef = new Chef(this); public Restaurant() &#123; exec.execute(chef); exec.execute(waitPerson); &#125; public static void main(String[] args) &#123; new Restaurant(); &#125;&#125; 使用显式的 Lock 和 Condition 对象在Java SE5中的 java.util.concurrent 类库中还有额外的显式工具实现任务协同工作。使用互斥并允许任务挂起的基本类是 Condition，你可以通过在 Condition 上调用 await() 来挂起一个任务。当外部条件发生变化，意味着某个任务应该继续执行时，你可以调用 signal() 来同志这个任务，从而唤醒一个任务，或者调用 signalAll() 来唤醒所有在这个 Condition 上被其自身挂起的任务。与 notifyAll() 相比，signalAll() 是更安全的方式。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485Class Car &#123; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); private boolean waxOn = false; public void waxed() &#123; lock.lock(); try &#123; waxOn = true; condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void buffed() &#123; lock.lock(); try &#123; waxOn = false; condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void waitForWaxing() throws InterrutpedException &#123; lock.lock(); try &#123; while(waxOn == false) &#123; condition.await(); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; public void waitForBuffing() throws InterruptedException &#123; lock.lock(); try &#123; while(waxOn == true) &#123; condition.await(); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;class WaxOn implements Runnable &#123; private Car car; public WaxOn(Car c) &#123;car = c;&#125; public void run() &#123; try &#123; while(!Thread.interrupted()) &#123; System.out.println(\"Wax On!\"); TimeUnit.MILLISECONDS.sleep(200); car.waxed(); car.waitForBuffing(); &#125; &#125; catch(InterruptedException e) &#123; System.out.println(\"Exiting via interrupt\"); &#125; System.out.println(\"Ending Wax On task!\"); &#125;&#125;class WaxOff implements Runnable &#123; private Car car; public WaxOn(Car c) &#123;car = c;&#125; public void run() &#123; try &#123; while(!Thread.interrupted()) &#123; car.waitForWaxing(); System.out.println(\"Wax Off!\"); TimeUnit.MILLISECONDS.sleep(200); car.buffed(); &#125; &#125; catch(InterruptedException e) &#123; System.out.println(\"Exiting via interrupt\"); &#125; System.out.println(\"Ending Wax Off task!\"); &#125;&#125;Lock 对象可以产生 Condition 对象，这个对象被用来管理任务间的通信。但是这个 Condition 对象不包含任何有关处理状态的信息，因此你需要管理额外的表示状态的信息。 生产者-消费者与队列wait() 和 notifyAll() 方法以一种非常地级的方式解决了任务互操作问题，即每次交互时都握手。在许多情况下，你可以使用 同步队列 来解决任务协作问题。同步队列在任何时刻都只允许一个任务插入或移除元素。在 java.util.concurrent.BlockQueue 接口中提供了这个队列，这个接口有大量的标准实现。你通常可以使用 LinkedBlockingQueue它是一个无界队列，还可以使用 ArrayBlockingQueue，它具有固定的尺寸，因此你可以在它被阻塞之前，向其中放置有限数量的元素。如果消费者任务试图从队列获取对象，而该队列此时为空，那么这些队列还可以挂起消费者任务，并且当有更多元素可用时恢复消费者任务。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Product &#123; private final int id; public Product(id) &#123;this.id = id;&#125; public String toString() &#123;return \"Product #\" + id;&#125;&#125;class ProductQueue extends LinkedBlockingQueue&lt;Product&gt;();class Producer &#123; private ProductQueue queue; private int count = 0; public Producer(ProductQueue queue) &#123; this.queue = queue; &#125; public void run() &#123; try &#123; while(!Thread.interrupted()) &#123; Product product = new Product(count++); queue.put(product); System.out.println(\"Produce \" + product); TimeUnit.SECONDS.sleep(1); &#125; &#125; catch(InterruptedException e) &#123; System.out.println(\"Producer interrupted!\") &#125; &#125;&#125;class Consumer &#123; private ProductQueue queue; public Producer(ProductQueue queue) &#123; this.queue = queue; &#125; public void run() &#123; try &#123; while(!Thread.interrupted()) &#123; Product product = queue.take(); System.out.println(\"Consume \" + product); TimeUnit.SECONDS.sleep(1); &#125; &#125; catch(InterruptedException e) &#123; System.out.println(\"Producer interrupted!\") &#125; &#125;&#125;public class BlockQueue &#123; public static void main(String[] args) &#123; ProductQueue queue = new ProductQueue(); ExecutorService exec = new Executors.newCachedThreadPool(); exec.execute(new Producer(queue)); exec.execute(new Cosumer(queue)); TimeUnit.SECONDS.sleep(10); exec.shutdownNow(); &#125;&#125; 任务间使用管道进行输入/输出通过输入/输出在线程间进行通信很有用。对应的事物是 PipedWriter（允许任务向管道写）和 PipedReader 类（允许不同任务从同一个管道中读取）。这个模型可以看成是“生产者-消费者”的变体。管道基本上是一个阻塞队列，存在于多个引入 BlockingQueue 之前的Java版本中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Sender implements Runnable &#123; private Random rand = new Random(47); private PipedWriter out = new PipedWriter(); public PipedWriter getPipedWriter(return out;) public void run() &#123; try &#123; while(true) &#123; for(char c = 'A';c &lt;= 'z';c++) &#123; out.write(c); TimeUnit.MILLISECONDS.sleep(200); &#125; &#125; &#125; cathc(InterruptedException e) &#123; System.out.println(\"sender interrupted!\"); &#125; catch(IOException e) &#123; System.out.println(\"sender write exception!\"); &#125; &#125;&#125;class Receiver implements Runnable &#123; private PipedReader in; public REceiver(Sender sender) throws IOException&#123; in = new PipedReader(sender.getPipedWriter()); &#125; public void run() &#123; try &#123; while(true) &#123; System.out.println(\"Read: \" + (char)in.read()); &#125; &#125; cathc(InterruptedException e) &#123; System.out.println(\"receiver interrupted!\"); &#125; catch(IOException e) &#123; System.out.println(\"receiver read exception!\"); &#125; &#125;&#125;public class PipedIO &#123; public static void main(String[] args) throws Exception &#123; Sender sender = new Sender(); Receiver receiver = new Receiver(sender); ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(sender); exec.execute(receiver); TimeUnit.SECONDS.sleep(5); exec.shutdownNow(); &#125;&#125; 死锁任务可以变成阻塞状态，所以就可能出现这种情况：某个任务在等待另一个任务，而后者又等待别的任务，这样一直下去，直到这个链条上的任务又在等待等一个任务释放锁。这被称为 死锁。考虑经典的哲学家就餐问题：作为哲学家，他们很穷，所以他们只能买五根筷子。他们围坐在桌子周面，每人之间放一根筷子。当一个哲学家就餐的时候，这个哲学家必须同时得到左边和右边的筷子。如果一个哲学家左边或右边已经有人使用筷子，那么这个哲学家就必须等待，直到可得到必须的筷子。这个是一个容易产生死锁的问题，可以尝试编程实现并观察。当以下四个条件同时满足时，就会发生死锁：互斥条件。任务使用的资源至少有一个是不能共享的。至少有一个任务它必须持有一个资源且在等待获取一个当前被别的任务持有的资源。资源不能被任务抢占，任务必须把资源释放当作普通事件。必须有循环等待，这时，一个任务等待其他任务所持有的资源，后者又在等待另一个任务持有的资源，这样一直下去，使得大家都被锁住。要发生思索，所有这些条件必须全部满足，所以要防止死锁的话，只需破坏其中一个即可。在程序中，防止死锁最容易的方法是破坏第四个条件。 新类库中的构件Java SE5的 java.util.concurrent 引入了大量设计用来解决并发问题的新类。 CountDownLatch它被用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。你可以向 CountDownLatch 对象设置一个初始计数值，任何在这个对象上调用 wait() 的方法都将阻塞，直至这个计数值到达0。其他任务在结束其工作时，可以在该对象上调用 countDown() 来减小计数值。CountDownLatch 被设计为只触发一次，计数值不能被重置。如果你需要能够重置计数值的版本，则可以使用 CyclicBarrier。CountDownLatch 的典型用法是将一个程序分为n个互相独立的可解决任务，并创建值为0的 CountDownLatch。当每个任务完成时，都会在这个锁存器上调用 countDown()。等待问题被解决的任务在这个锁存器上调用 await()，将它们自己拦住，直至锁存器计数结束。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class TaskPortion implements Runnable &#123; private static int counter = 0; private final int id = count++; private static Random rand = new Random(47); private final CountDownLatch latch; TaskPortion(CountDownLatch latch) &#123; this.latch = latch; &#125; public void run() &#123; try &#123; doWork(); latch.countDown(); &#125; catch(InterruptedException e) &#123; // Acceptable way to exit &#125; &#125; public void doWork() throws InterruptedException &#123; TimeUnit.MILLISECONDS.sleep(rand.nextInt(2000)); System.out.println(this + \" completed!\"); &#125; public String toString() &#123; return String.format(\"%1$-3d\", id); &#125;&#125;class WaitingTask implements Runnable &#123; private static int count = 0; private final int id = counter++; private final CountDownLatch latch; WaitingTask(CountDownLatch latch) &#123; this.latch = latch; &#125; public void run() &#123; try &#123; latch.await(); System.out.println(\"Latch barrier passed for \" + this); &#125; cathc(InterruptedException e) &#123; System.out.println(this + \" interrupted!\"); &#125; &#125; public String toString() &#123; return String.format(\"WaitingTask %1$-3d \", id); &#125;&#125;public class CountDownLatchDemo &#123; static final int SIZE = 100; public static void main(String[] args) throws Exception &#123; ExecutorService exec = Executors.newCachedThreadPool(); CountDownLatch latch = new CountDownLatch(SIZE); for(int i=0;i&lt;10;i++) &#123; exec.execute(new WaitingTask(latch)); &#125; for(int i=0;i&lt;SIZE;i++) &#123; exec.execute(new TaskPortion(latch)); &#125; // 当所有任务完成时结束 exec.shutdown(); &#125;&#125; CyclicBarrierCyclicBarrier 适用于这样的情况：你希望创建一组任务，它们并发地执行工作，然后在进行下一个步骤前等待，直至所有任务都完成。它使得所有的并行任务都将在栅栏处列队，因此可以一致地向前移动。这非常像 CountDownLatch，只是 CountDownLatch 是只除法一次的事件，但 CyclicBarrier 可以多次重用。 DelayQueue这是一个无界的 BlockingQueue，用于放置实现了 Delayed 接口的对象，其中的对象只能在其到期才能从队列中取走。这种队列是有序的，即队头对象的延迟到期的时间最长。如果没有任何延迟到期，那么就不会有任何头元素，并且 poll() 将返回 null（正因为这样，不能将 null 放置到这种队列中）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class DelayedTask implements Runnable, Delayed &#123; private static int counter = 0; private final int id = counter++; private final int delta; private final long trigger; protected static List&lt;DelayedTask&gt; sequence = new ArrayList&lt;&gt;(); public DelayedTask(int delayInMilliseconds) &#123; delta = delayInMilliseconds; trigger = System.nanoTime() + NANOSECONDS.convert(delta, MILLISECONDS); sequence.add(this); &#125; public long getDelay(TimeUnit unit) &#123; return unit.conver(trigger - System.nanoTime(), NANOSECONDS); &#125; public int compareTo(Delayed arg) &#123; DelayedTask that = (DelayedTask)arg; if(trigger &lt; that.trigger) return -1; else if(trigger &gt; that.trigger) return 1; else return 0; &#125; public void run() &#123; System.out.println(this + \" \"); &#125; public String toString() &#123; return String.format(\"[%1$-4d]\", delta) + \" Task \" + id; &#125; public String summary() &#123; return \"(\" + id + \":\" + delta + \")\"; &#125; public static class EndSentinel extends DelayedTask &#123; private ExecutorService exec; public EndSentinel(int delay, ExecutorService e) &#123; super(delay); exec = e; &#125; public void run() &#123; for(DelayedTask pt : sequence) &#123; System.out.println(pt.summary()); &#125; System.out.println(this + \" Calling shutdownNow()\"); exec.shutdownNow(); &#125; &#125;&#125;class DelayedTaskConsumer implements Runnable &#123; private DelayQueue&lt;DelayedTask&gt; q; public DelayedTaskConsumer(DelayQueue&lt;DelayedTask&gt; q) &#123; this.q = q; &#125; public void run() &#123; try &#123; while(!Thread.interrupted()) &#123; q.take().run(); &#125; &#125; catch(InterruptedException e) &#123; // Acceptable way to exit &#125; System.out.println(\"FInished DelayedTaskConsumer!\"); &#125;&#125;public class DelayQueueDemo &#123; public static void main(String[] args) &#123; Random random = new Random(47); ExecutorService exec = Executors.newCachedThreadPool(); DelayQueue&lt;DelayedTask&gt; queue = new DelayQueue&lt;DelayedTask&gt;(); for(int i=0;i&lt;20;i++) &#123; queue.put(new DelayedTask(rand.nextInt(5000))); &#125; queue.add(new DelayedTask.EndSentinel(5000, exec)); exec.execute(new DelayedTaskCOnsumer(queue)); &#125;&#125; PriorityBlockingQueue这是一个很基础的优先级队列，它具有可阻塞的读取操作。但是你需要为你的任务实现 Comparable 接口，以实现优先级的判断。 ScheduledExecutorScheduledThreadPoolExecutor 提供了以下方法：使用 schedule() 方法可以在指定时间后运行一次任务；scheduleAtFixedRate() 方法允许你每隔规则的事件重复执行任务。1234567// 创建定时线程池ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(10);// 参数1是任务(Runnable)，参数2是延迟时间数值(int)，参数3是延迟时间单位(TimeUnit)scheduler.schdule(event, delay, unit);scheduler.scheduleAtFixedRate(event, initialDelay, period, unit); Semaphore正常的锁（concurrent.lock 或内建的 synchronized 锁）在任何时刻都只允许一个任务访问一项资源，而 计数信号量 允许n个任务同时访问这个资源。作为一个示例，请考虑 对象池 的概念，它管理着数量有限的对象，当要使用对象时可以签出它们，而在用户使用完毕时，可以将它们签回。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Pool&lt;T&gt; &#123; private int size; private List&lt;T&gt; items = new ArrayList&lt;&gt;(); private volatile boolean[] checkedOut; private Semaphore available; public Pool(Class&lt;T&gt; cls, int size) &#123; this.size = size; checkedOut = new boolean[size]; available = new Semaphore(size, true); for(int i=0;i&lt;size;++i) &#123; try &#123; items.add(cls.newInstance()); &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; public T checkOut() throws InterruptedException &#123; available.acquire(); return getItem(); &#125; public void checkIn(T x) &#123; if(releaseItem(x)) &#123; available.release(); &#125; &#125; private synchronized T getItem() &#123; for(int i=0;i&lt;size;i++) &#123; if(!checkedOut[i]) &#123; checkedOut[i] = true; return item.get(i); &#125; &#125; return null; &#125; private synchronized boolean releaseItem(T item) &#123; int index = items.indexOf(item); if(index == -1) return false; if(checkedOut[index) &#123; checkedOut[index] = false; return true; &#125; return false; &#125;&#125; ExchangerExchanger 是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，它们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象。典型应用场景是：一个任务在创建对象，这些对象的生产代价很高昂，而另一个任务在消费这些对象。通过这种方式，可以有更多的对象在创建的同时被消费。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class ExchangerProducer&lt;T&gt; implements Runnable &#123; private Generator&lt;T&gt; generator; private Exchanger&lt;List&lt;T&gt;&gt; exchanger; private List&lt;T&gt; holder; ExchangerProducer(Exchanger&lt;List&lt;T&gt;&gt; exchanger, Generator&lt;T&gt; generator, List&lt;T&gt; holder) &#123; this.exchanger = exchanger; this.generator = generator; this.holder = holder; &#125; public void run() &#123; try &#123; while(!Thread.interrutped()) &#123; for(int i=0;i&lt;ExchangerDemo.size;i++) &#123; holder.add(generator.next()); &#125; holder = exchanger.exchange(holder); &#125; &#125; catch(InterruptedException e) &#123; // OK to terminate this way &#125; &#125;&#125;class ExchangeConsumer&lt;T&gt; implements Runnable &#123; private Exchange&lt;List&lt;T&gt;&gt; exchanger; private List&lt;T&gt; holder; private volatile T value; ExchangerConsumer(Exchanger&lt;List&lt;T&gt;&gt; exchanger, List&lt;T&gt; holder) &#123; this.exchanger = exchanger; this.holder = holder; &#125; public void run() &#123; try &#123; while(!Thread.interrupted()) &#123; holder = exchanger.exchange(holder); for(T x : holder) &#123; value = x; // Fetch out value holder.remove(x); // OK for CopyONWriteArrayList &#125; &#125; &#125; catch(InterruptedException e) &#123; // OK to terminate this way &#125; System.out.println(\"Final value: \" + value); &#125;&#125;public class ExchangeDemo &#123; static int size = 10; static int delay = 5; public static void main(String[] args) &#123; if(args.length &gt; 0) &#123; size = new Integer(args[0]); &#125; if(args.length &gt; 1) &#123; delay = new Integer(args[1]); &#125; ExecutorService exec = Executors.newCachedThreadPool(); Exchanger&lt;List&lt;Fat&gt;&gt; xc = new Exchanger&lt;List&lt;Fat&gt;&gt;(); List&lt;Fat&gt; producerList = new CopyOnWriteArrayList&lt;&gt;(), consumerList = new CopyOnWriteArrayList&lt;&gt;(); exec.execute(new ExchangerProducer&lt;Fat&gt;(xc, BasicGenerator.create(Fat.class), producerList)); exec.execute(new ExchangerConsumer&lt;Fat&gt;(xc, consumerList)); TimeUnit.SECONDS.sleep(delay); exec.shutdownNow(); &#125;&#125; 性能调优 比较各类互斥技术Java包含老式的 synchronized 关键字和Java SE5中新的 Lock 类和 Atomic 类。在一定阈值内，synchronized 关键字会比使用 Lock 或 Atomic 更高效，这可能得益于编译器的优化或者提前计算。但越过阈值，synchronized 关键字会变得十分低效，而 Lock 和 Atomic 则显得大体维持，因此也要变得比 synchronized 关键字高效得多。如何使用正确的互斥技术呢？如果你互斥的方法体是非常之小，请优先选用 synchronized 关键字，这让代码会有更好的可读性。因此可以这么总结，以 synchronized 关键字入手，只有在性能调优时才替换为 Lock 对象这种做法，是具有实际意义的。 免锁容器容器是所有编程中的基础工具。像 Vecotr 和 Hashtable 这种早期容器具有需要 synchronized 方法，当它们用于非多线程的应用程序时，便会导致不可接收的开销。在Java 1.2中，新的容器类库是不同不的。Java SE5添加了新的容器，通过使用更灵巧的技术来消除加锁，从而提高线程安全的性能。这些免锁容器背后的通用策略是：对容器的修改可以与读操作同时发生，只要读取者只能看到完成修改的结果即可。修改是在容器数据结构的某个部分的一个单独的副本（有时是整个数据结构的副本）上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的数据结构才会自动地与主数据结构进行交换，之后读取者就可以看到这个修改了。在 CopyOnWriteArrayList 中，写入将导致创建整个底层数据的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。当修改完成时，一个原子性的操作将把新的数组换入，使得新的读取操作可以看到这个新的修改。CopyOnWriteArrayList 的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificaitonException。ConpyOnWriteArraySet 将使用 CopyOnWriteArrayList 来实现其无锁行为。ConcurrentHashMap 和 ConcurrentLinkedQueue 使用了类似的技术，允许并发的读取和写入。但是容器中只有部分内容而不是整个容器可以被复制和修改。然而，任何修改在完成之前，读取者仍旧不能看到它们。 乐观锁只要你主要是从免锁容器中读取，那么它就会比其 synchronized 对应物快许多，因为获取和释放锁的开销被省掉了。某些 Atomic 类还允许你执行所谓的“乐观加锁”。这意味着当你执行某项计算时，实际上没有使用互斥，但是在这项计算完成时，并且你准备更新这个 Atomic 对象时，你需要使用一个称为 compareAndSet() 的方法，你将旧值和新值以其提交给这个方法，如果旧值与它在 Atomic 对象中发现的值不一致，那么这个操作就失败了–意味着其他的任务已经于此操作执行期间修改了这个对象。但我们是乐观的，因为我门保持数据为未锁定状态，并希望没有任何其他任务插入修改它。这时你需要考虑，如果 compareAndSet() 操作失败了，你该怎么办？ ReadWriteLockReadWriteLock 对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock 使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。123456789101112131415161718// 创建读写锁ReentrantReadWriteLock lock = new ReentrantReadWriterLock(true);// 获取读锁Lock readLock = lock.readLock();readLock.lock();try &#123; // read data&#125; finally &#123; readLock.unlock();&#125;// 获取写锁Lock writeLock = lock.writeLock();writeLock.lock();try &#123; // write data&#125; finally &#123; writeLock.unlock();&#125; 活动对象有一种可替换的方式被称为 活动对象 或 行动者。之所以称这些对象是活动的，是因为每个对象都维护着它自己的工作线程和消息队列，并且所有对这种对象的请求都将进入队列排队，任何时刻都只能运行其中一个。因此，有了活动对象，我们就可以串行化消息而不是方法。当你向一个活动对象发送消息时，这条消息会转变为一个任务，该任务会被插入到这个对象的队列中，等待在以后的某个时刻运行。Java SE5的 Future 在实现这种模式时派上了用场。123456789101112131415161718192021222324252627282930313233343536373839404142public class ActiveObjectDemo &#123; private ExecutorService ex = Executors.newSingleThreadExecutor(); private Random random = new Random(47); private void pause(int factor) &#123; try &#123; TimeUnit.MILLISECONDS.sleep(100 + rand.nextInt(factor)); &#125; catch(InterruptedException e) &#123; System.out.println(\"pause() interrupted!\"); &#125; &#125; public Future&lt;Integer&gt; calculateInt(final int x, final int y) &#123; return ex.submit(new Callable&lt;Integer&gt;() &#123; public Integer call() &#123; pause(500); return x + y; &#125; &#125;); &#125; public void shutdown() &#123; ex.shutdown(); &#125; public static void main(String[] args) &#123; ActiveObjectDemo dl = new ActiveObjectDemo(); List&lt;Future&lt;?&gt;&gt; results = new CopyOnWriteArrayList&lt;&gt;(); for(int i=0;i&lt;5;i++) &#123; results.add(dl.calculateInt(i, i)); &#125; while(results.size() &gt; 0) &#123; for(Future&lt;?&gt; f : results) &#123; if(f.isDone()) &#123; System.out.println(f.get()); results.remove(f); &#125; &#125; &#125; &#125; dl.shutdown();&#125;这些活动对象或者行动者领域，或者更有趣的被称为 基于代理 的编程领域，确实产生了进步。代理实际上就是活动对象，但是代理系统还支持跨网络和机器的透明性。如果代理编程最终成为了面向对象编程的继任者，你不必感到吃惊，因为它把对象和相对容易的并发解决方案结合了起来。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"20-注解","slug":"Java编程思想/20-注解","date":"2020-07-03T13:30:32.000Z","updated":"2020-07-03T13:31:34.942Z","comments":true,"path":"Java编程思想/20-注解/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/20-%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便使用这些数据。注解在一定程度上是在把元数据与源代码文件结合在一起，而不是保存在外部文档中。注解可以提供用来完整地描述程序所需的信息，而这些信息是无法用Java来表达。因此，注解使得我们能够以将由编译器来测试和验证的格式，存储有关程序的额外信息。注解可以用来生成描述符文件，甚至或是新的类定义，并且有助于减轻编写“样板”代码的负担。同时，注解的优点还包括：更加干净易读的代码以及编译期类型检查等。注解的语法比较简单，除了 @ 符号的使用之外，它基本与Java固有的语法一致。Java SE5内置了三种，定义在 java.lang 中的注解：@Override，表示当前的方法定义将覆盖超类中的方法。如果你不小心拼写错误，或者方法签名对不上被覆盖的方法，编译器就会发出提示信息。@Deprecated，如果程序员使用了注解为它的元素，那么编译器发出警告信息。@SuppressWarnings，关闭不当的编译器警告信息。Java还另外提供了四种注解，专门负责新注解的创建。每当你创建描述符性质的类或接口时，一旦其中包含了重复性工作，那么就可以考虑使用注解来简化与自动化该过程。注解(annotation)是在实际的源代码级别保存所有的信息，而不是某种注释性的文字（comment），这使得代码更加整洁，且便于维护。 基本语法 定义注解123@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test &#123;&#125;定义注解时，会需要一些 元注解（meta-annotation），如 @Target 和 @Retention。@Target 用来定义你的注解将应用于什么地方（例如是一个方法或者一个域）。@Retention 用来定义该注解在哪一个级别可用，在源代码中(SOURCE),类文件中(CLASS)或运行时(RUNTIME)。在注解中，一般都会包含一些元素以表示某些值。当分析处理注解时，程序或工具可以利用这些值。注解的元素看起来就像接口的方法，唯一的区别是你可以为其指定默认值。没有元素的注解称为 标记注解（mark annotation）。123456789101112131415161718@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UseCase &#123; public int id(); public String description() default \"null\";&#125;public class PasswordUtils &#123; @UseCase(id=47, description=\"Password must contain at least one numeric\") public boolean validatePassword(String password) &#123; return (password.matches(\"\\\\w*\\\\d\\\\w*\")); &#125; @UseCase(id=48) public String encryptPassword(String password) &#123; return new StringBuilder(password).reverse().toString(); &#125;&#125; 元注解Java目前只内置了三种标准注解，以及四种元注解。元注解专职负责注解其他注解：@Target表示该注解可以用于什么地方。可能的 ElementType 参数包括:CONSTRUCTOR: 构造器声明FIELD: 域声明（包括 enum 实例）LOCAL_VARIABLE: 局部变量声明METHOD: 方法声明PACKAGE: 包声明PARAMETER: 参数声明TYPE: 类、接口（包括注解类型）或 enum 声明@Retention表示需要在什么级别保存该注解信息。可选的 RetentionPolicy 参数包括:SOURCE:注解将被编译器丢弃。CLASS: 注解在class文件中可用，但会被VM丢弃。RUNTIME: VM将在运行期间也保留注解，因此可以通过反射机制读取注解的信息。@Documented将此注解包含在Javadoc中。@Inherited允许子类继承父类中的注解。 编写注解处理器使用注解的过程中，很重要的一个部分就是创建与使用 注解处理器。Java SE5扩展了反射机制的API，以帮助程序员构造这类工具。同时，它还提供了一个外部工具 apt 帮助程序员解析带有注解的Java源代码。1234567891011121314151617public class UseCaseTracker &#123; public static void trackUseCases(List&lt;Integer&gt; useCases, CLass&lt;?&gt; cls) &#123; for(Method m : cls.getDeclaredMethods()) &#123; UseCase uc = m.getAnnotation(UseCase.class); if(uc != null) &#123; System.out.println(uc.id()); System.out.println(uc.description()); useCases.remove(new Integer(uc.id())); &#125; &#125; for(int i : useCases) &#123; System.out.println(\"Warning: Missing use case - \" + i); &#125; &#125;&#125;getAnnotation() 方法返回指定类型的注解对象，如果没有该类型的注解，则返回 null。 注解元素注解元素可用的类型如下：所有的基本类型StringClassenumAnnotation以上类型的数组如果你使用了其他类型，那么编译器就会报错。注意，也不允许使用任何包装类型，注解也可以作为元素的类型，也就是说注解可以嵌套。 默认值限制编译器对元素的默认值有些过分挑剔。首先，元素不能由不确定的值。也就是说，元素必须要么具有默认值，要么在使用注解时提供元素的值。其次，对于非基本类型的元素，无论是在源代码中声明，或是在注解接口中定义默认值时，都不能以 null 作为其值。这个约束使得很难表现一个元素的存在或缺失的状态。因此，只能自己定义一些特殊的值，例如空字符串或负数。 生成外部文件有些framework需要一些额外的信息才能与你的源代码协同工作。假如你希望提供一些皆不能的对象/关系映射功能，能够自动生成数据库表，用以存储JavaBean对象。以下是一个注解的定义，它告诉注解处理器，你需要为我生成一个数据库表：12345@Target(ElementType.TYPE) // 仅仅应用在class上@Retention(RetentionPolicy.RUNTIME)public @interface DBTable &#123; public String name() default \"\"; // 表名字&#125;接下来是为修饰JavaBean域准备的注解：12345678910111213141516171819202122@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Constraints &#123; boolean primaryKey() default false; boolean allowNull() default true; boolean unique() default false;&#125;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface SQLString &#123; int value() default 0; String name() default \"\"; Constraints constraints() default @Constraints;&#125;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface SQLInteger &#123; String name() default \"\"; Constraints constraints() default @Constraints;&#125;注解处理器通过 @Constraints 注解提取出数据库表的元数据，虽然它值表示了数据库所能提供约束的一个很小的子集。另外两个 @interface 定义的是SQL类型。这些SQL类型具有 name() 元素和 constraints() 元素。后者利用了嵌套注解的功能，将 column 类型的数据库约束信息潜入其中。注意，constraints() 元素的默认值是 @Constraints。由于在 @Constraints 注解类型之后，没有在括号中指明 @COnstraints 中的元素的值，因此，constraints() 元素的默认值实际上就是一个所有元素都为默认值 @Constraints 注解。下面是一个简单的Bean的定义，我们在其中应用以上这些注解：123456789@DBTable(name=\"MEMBER\")public class Member &#123; @SQLString(30) String firstName; @SQLString(50) String lastName; @SQLInteger Integer age;&#125;如果程序员在注解中定义了名为 value 的元素，并且在应用该注解的是户，如果该元素是唯一需要赋值的一个元素，那么此时无需使用名-值对的这种语法，而只需要在括号内给出 value 元素所需的值即可。 使用apt处理注解注解处理工具apt，这是Sun为了帮助注解得处理过程而提供得工具。与javac一样，apt被设计为操作Java源文件，而不是编译后的类。默认情况下，apt会在处理完源文件之后编译它们。如果在系统的构建过程中会自动创建一些新的源文件，这个特性非常有用。事实上，apt会检查新生成的源文件中的注解，然后将所有文件一同编译。当注解处理器生成一个新的源文件时，该文件会在新的一轮（round）的注解处理中接收检查。该工具会一轮一轮地处理，直至不再有新的源文件产生为止。然后它再编译所有的源文件。程序员自定义的每一个注解都需要自己的注解器，而apt工具能够很容易地将多个注解处理器组合在一起。有了它，程序员就可以指定多个要处理的类。此外还可以添加监听器，并在一轮注解处理过程结束的时候收到通知信息。要想编译这一节中出现的注解处理器，你必须将 tools.jar 设置在你的classpath中，这个工具类库同时还包含了 com.sun.mirror.* 接口。通过使用 AnnotationProcessorFactory，apt能够为每一个它发现的注解生成一个正确的注解处理器。当你使用apt的时候，必须指明一个工具类，或者指明能找到apt所需的工具类的路径。使用apt生成注解处理器时，我们无法利用Java的反射机制，因为我们操作的是源代码，而不是编译后的类。使用mirror API能够解决这个问题，它使我们能够在未经编译的源代码中查看方法，域以及类型。下面是一个自定义的注解，使用它可以把一个类中的 public 方法提取出来，构造成一个新的接口：12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.SOURCE)public @interface ExtractInterface &#123; public String value();&#125;下面的类有一个公共方法，我们将会把它抽取到一个有用接口中：123456@ExtractInterface(\"IMultiplier\")public class Multiplier &#123; public int multiply(int x, int y) &#123; return x * y; &#125;&#125;下面编写这个注解的处理器：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class InterfaceExtractorProcessor implements AnnotationProcessor &#123; private final AnnotationProcessorEnvironment env; pprivate ArrayList&lt;MethodDeclaration&gt; interfaceMethods = new ArrayList&lt;&gt;(); public InterfaceExtractorProcessor(AnntationProcessorEnvironment env) &#123; this.env = env; &#125; public void process() &#123; for(TypeDeclaration typeDecl : env.getSpecifiedTypeDeclarations()) &#123; // 获取类上的注解 ExtractInterface annot = typeDecl.getAnnotation(ExtractInterface.class); // 如果类上没有这个注解 if(annot == null) &#123; break; &#125; // 获取类中声明的方法 for(MethodDeclaration m : typeDecl.getMethods()) &#123; // 如果方法是公开非静态的 if(m.getModifiers().contains(Modifier.PUBLIC) &amp;&amp; !(m.getModifiers().contains(Modifier.STATIC))) &#123; interfaceMethods.add(m); &#125; &#125; if(interfaceMethods.size() &gt; 0) &#123; try &#123; // 创建Java源代码文件 PrintWriter writer = env.getFiler().createSourceFile(annot.value()); // 写入包名 writer.println(\"package\" + typeDecl.getPackage().getQualifiedName() + \";\"); // 写入类名 writer.println(\"public interface \" + annot.value() + \"&#123;\"); // 遍历写入各接口方法 for(MethodDeclaration m : interfaceMethods) &#123; writer.print(\" public \"); writer.print(m.getReturnType() + \" \"); writer.print(m.getSimpleName() + \"(\"); int i=0; for(ParameterDeclaration parm : m.getParameters()) &#123; writer.print(parm.getType() + \" \" + parm.getSimpleName()); if(++i &lt; m.getParameters().size()) &#123; writer.println(\");\"); &#125; &#125; writer.println(\");\"); &#125; writer.println(\"&#125;\"); writer.close(); &#125; catch(IOException ioe) &#123; throw new RuntimeException(ioe); &#125; &#125; &#125; &#125;&#125;注意，处理器类的构造器以 AnnotationProcessorEnvironment 对象为参数。通过该参数，我们就能知道apt正在处理的所有类型（类定义），并且可以通过它获得 Messager 对象和 Filer 对象。Message 对象可以用来向用户报告信息，比如处理过程中发生的任何错误，以及错误在源代码中出现的位置等。Filer 是一种 PrintWriter，我们可以通过它创建新的文件。使用 Filer 对象apt才能知道我们创建的新文件，从而对新文件进行注解处理，并且在需要的时候编译它们。apt工具需要一个工厂类来为其指明正确的处理器，然后它才能调用处理器上的 process() 方法：12345678910111213public class InterfaceExtractorProcessorFactory implements AnnotationProcessorFactory &#123; public AnnotationProcessor getProcessorFor(Set&lt;AnnotationTypeDeclaration&gt; atds, AnnotationProcessorEnvironment env) &#123; return new InterfaceExtractorProcessor(env); &#125; public Collection&lt;String&gt; supportedAnnotationTypes() &#123; return Collections.singleton(\"anntations.ExtractInterface\"); &#125; public Collection&lt;String&gt; supportedOptions() &#123; return Collections.emptySet(); &#125;&#125;AnnotationProcessorFactory 接口只有三个方法。getProcessorFor() 方法返回注解处理器，该方法以包含类型声明的 Set 以及 AnnotationProcessorEnvironment 对象。另外两个方法是 supportedAnnotationTypes() 和 supportedOptions()，程序员可以通过它们检查一下，是否apt工具发现的所有注解都有相应的处理器，是否所有控制台输入的参数都是你提供支持的选项。其中，supportedAnnotationTypes() 方法尤其重要，因为一旦在返回的 String 集合中没有你的注解的完整类名，apt就会抱怨没有找到相应的处理器。 将观察者模式用于apt处理注解的真实过程可能会非常复杂。mirror API提供了对 访问者 设计模式的支持。一个访问者会遍历某个数据结构或一个对象的集合，对其中的每一个对象执行一个操作。该数据结构无需有序，而你对每个对象执行的操作，都是特定于此对象的类型。这就将操作与对象解耦，也就是说，你可以添加新的操作，而无需向类的定义中添加方法。一个Java类可以看作一系列对象的集合，例如 TypeDeclaration 对象,FieldDeclaration 对象以及 ethodDeclaration 对象等。当你配合访问者模式使用apt工具时，需要提供一个 Visitor 类，它具有一个能够处理你要访问的各种声明的方法。然后，你就可以为方法，类以及域上的注解实现相应的处理行为。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"19-枚举类型","slug":"Java编程思想/19-枚举类型","date":"2020-07-03T13:29:52.000Z","updated":"2020-07-03T13:31:30.708Z","comments":true,"path":"Java编程思想/19-枚举类型/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/19-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"关键字 enum 可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。 基本 enum 特性调用 enum 的 values() 方法，可以遍历 enum 实例。values() 方法返回 enum 实例的数组，而且该数组中的元素严格保持其在 enum 中声明的顺序，因此你可以在循环中使用返回的数组。创建 enum 时，编译器会为你生成一个相关的类，这个类继承自 java.lang.Enum。123456789101112131415161718192021enum Shrubbery &#123; GROUND, CRAWLING, HANGING&#125;public class EnumClass &#123; public static void main(String[] args) &#123; for(Shrubbery s : Shrubbery.values()) &#123; System.out.println(s.ordinal()); System.out.println(s.compareTo(Shrubbery.CRAWLING)); System.out.println(s.getDeclaringClass()); System.out.println(s.name()); &#125; for(String s : \"HANGING CRAWLING GROUND\".split(\" \")) &#123; Shrubbery shrub = Enum.valueOf(SHrubbery.class, s); System.out.println(shrub); &#125; &#125;&#125;使用 ordinal() 方法会返回一个 int 值，这是每个 enum 实例在声明时的次序，从0开始。可以使用 == 来比较 enum 实例，编译器会自动为你提供 equals() 和 hashCode() 方法。同时，Enum 类实现了 Comparable 接口，所以它具有 compareTo 方法。更多的，它还实现了 Serializable 接口。如果在 enum 实例上调用 getDeclaringClass() 方法，就能知道其所属的 enum 类。name() 方法返回 enum 实例声明时的名字，这与使用 toString() 方法效果小桶。valueOf() 是在 Enum 中定义的 static 方法，它根据给定的名字返回相应的 enum 实例，如果不存在给定名字的实例，将会抛出异常。 向 enum 中添加新方法除了不能继承自一个 enum 之外，我们基本上可以将 enum 看作一个常规的类。也就是说，可以向 enum 中添加方法，enum 甚至可以有 main() 方法。一般来说，我们希望每个枚举实例都能够返回对自身的描述。为此，你可以提供一个构造器，专门负责处理这个额外的信息，然后添加一个方法返回这个描述信息。12345678910111213141516public enum OzWitch &#123; // 枚举实例必须定义在任何方法之前 WEST(\"west\"), NORTH(\"north\"), EAST(\"east\"), SOUTH(\"south\"); private String description; private String OzWitch(String description) &#123; this.description = description; &#125; public String getDescription() &#123; return this.description; &#125;&#125;注意，如果你打算定义方法，那么必须在 enum 实例序列的最后添加一个分号。同时，Java要求你必须先定义 enum 实例。如果在定义 enum 实例之前定义了任何方法或属性，那么在编译时就会得到错误信息。在上面的例子中，我们有意识地将 enum 构造器声明为 private，但对于它的可访问性而言，其实没有变化。一旦 enum 的定义结束，编译器就不允许我们再使用其构造器来创建任何实例了。 switch 语句中的 enum在 switch 中使用 enum，是 enum 提供的一项非常遍历的功能。一般来说，switch 中只能使用整数值，而枚举实例天生就具备整数值的次序，并且可以通过 ordinal() 方法取得其次序。虽然一般情况下必须使用 enum 类型来修饰一个 enum 实例，但是在 case 语句中却不必如此。123456789101112enum Signal&#123;GREEN, YELLOW, RED, &#125;public class TrafficLight &#123; Signal color = Signal.RED; public void change() &#123; switch(color) &#123; case RED: color = Signal.GREEN; break; case GREEN: color = Signal.YELLOW; break; case YELLOW: color = Signal.RED; break; &#125; &#125;&#125; values() 的神秘之处Enum 类并没有 values() 方法。该方法是编译器添加的 static 方法。同时，在创建过程中，编译器还会添加 valueOf() 方法，该方法与 Enum 类的 valueOf() 方法区别在于，后者需要两个参数，而新增的方法只需一个参数。同时编译器会将 enum 类型标记为 final 类，所以无法继承自 enum。所以，如果你将 enum 实例向上转型为 Enum，那么 values() 方法就不可访问了。不过在 Class 中有一个 getEnumConstants() 方法，可以通过 Class 对象取得所有 enum 实例。 实现，而非继承所有的 enum 都继承自 java.lang.Enum 类。由于Java不支持多重继承，所以你的 enum 不能再继承其他类。然而，在创建一个新的 enum 时，可以同时实现一个或多个接口。 使用 EnumSet 替代标志Java SE5引入了 EnumSet，是为了通过 enum 创建一种替代品，以替代传统基于 int 的“位标志”。这种标志可以用来表示某种“开/关”信息。EnumSet 的设计充分考虑到了速度因素，因为它必须与非常高效的 bit 标志相竞争。就其内部而言，它（可能）是将一个 long 值作为比特向量，所以非常快速高效。12345678910enum AlarmPoints&#123;BEDROOM, BATHROOM, LIVINGROOM&#125;public class EnumSets &#123; public static void main(String[] args) &#123; // 创建一个空集合 EnumSet&lt;AlarmPoints&gt; points = EnumSet.noneOf(AlarmPoints.class); // 添加一个元素 points.add(AlarmPoints.BEDROOM); &#125;&#125;EnumSet 的基础是 long，一个 long 值有64位，而一个 enum 实例只需一位bit表示是否存在。但是, EnumSet 可以应用于多个64位元素的 enum，这表示其会自动扩容。 使用 EnumMapEnumMap 是一种特殊的 Map，它要求其中的键（key）必须来自一个 enum。由于 enum 本身的限制，所以 EnumMap 在内部可由数组实现，因此速度很快。1234567public class EnumMaps &#123; public static void main(String[] args) &#123; EnumMap&lt;AlarmPoint&gt; em = new EnumMap&lt;AlarmMap&gt;(AlarmPoint.class); em.put(AlarmPoint.LIVINGROOM, \"living room\"); em.get(AlarmPoint.LIVINGROOM); &#125;&#125;注意：enum 的每个实例作为一个键，总是存在的。如果你没有为这个键调用 put() 方法来存入相应的值的话，其对应的值就是 null。 常量相关的方法Java的enum有一个非常有趣的特性，即它允许程序员为 enum 实例编写方法，从而为每个 enum 实例赋予不同的行为。要实现常量相关的方法，你需要为 enum 定义一个或多个 abstract 方法，然后为每个 enum 实例实现抽象方法。12345678910111213public enum ConstantSpecificMethod &#123; DATE_TIME &#123; String getInfo() &#123; return DateFormat.getDateInstance().format(new Date()); &#125; &#125; CLASSPATH &#123; String getInfo() &#123; return System.getenv(\"CLASSPATH\"); &#125; &#125; abstract String getInfo();&#125;通过相应的 enum 实例，可以调用其上的方法。这通常也称为 表驱动的代码（table-drive code）。 使用 enum 的状态机枚举类型非常适合用来创建 状态机。一个状态机可以具有有限个限定的状态，它通常根据输入，从一个状态转移到下一个状态，不过也可能存在 瞬时状态（transient states），而一旦任务执行结束，状态机及iuhui立刻离开瞬时状态。每个状态都具有某些可接受的输入，不同输入会使状态机从当前状态转移到不同的新状态。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"18-IO系统","slug":"Java编程思想/18-IO系统","date":"2020-07-03T13:29:07.000Z","updated":"2020-07-03T13:31:24.106Z","comments":true,"path":"Java编程思想/18-IO系统/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/18-IO%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"对程序语言的设计者来说，创建一个好的输入/输出（I/O）系统是一项艰难的任务。挑战来自于要涵盖所有的可能性。不仅存在各种IO源和想要与之通信的接收端（文件、控制台、网络链接等），而且还需要以多种的方式与它们进行通信（顺序、随机存取、缓冲、二进制、按字符、按行、按字等）。Java类库的设计者通过创建大量的类来解决这个问题（讽刺的是，Java IO设计初衷是为了避免过多的类）。自从Java 1.0版本以来，在原来面向字节的类中添加了面向字符和基于Unicode的类。在JDK 1.4中，添加了 nio 类，为了改进性能和功能。 File 类File （文件）类这个名字有一定的误导性。我们可能认为它指代的是文件，实际上却并非如此。它既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。如果它指的是一个文件集，我们可以对此集合调用 list() 方法，这个方法会返回一个字符数组。所以如果我们想取得不同的目录列表，只需要再创建一个不同的 File 对象就可以了。实际上，FilePath(文件路径)对这个类来说是个更好的名字。 目录列表器假设想查看一个目录列表，可以用两种方法来使用 File 对象。如果调用不带参数的 list() 方法，便可以获得此 File 对象包含的全部列表。然而，如果我们想获得一个受限列表，例如，得到所有扩展名为 .java 的文件。我们就要用到 “目录过滤器”，这个类会告诉我们怎样显示符合条件的 File 对象。下面是一个示例，通过使用 java.utils.Arrays.sort() 和 String.CASE_INSENSITIVE.ORDERComparator，可以很容易地对结果进行排序（按字母排序）。12345678910111213141516171819202122232425public class DirList &#123; public static void main(String[] args) &#123; File path = new File(\".\"); String[] list; if(args.length == 0) &#123; list = path.list(); &#125; else &#123; list = path.list(new DirFilter(args[0])); &#125; Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); for(String dirItem : list) &#123; System.out.println(dirItem); &#125; &#125; class DirFilter implements FilenameFilter &#123; private Pattern pattern; public DirFilter(String regex) &#123; pattern = Pattern.compile(regex); &#125; public boolean accept(File dir, String name) &#123; return pattern.matcher(name).matches(); &#125; &#125;&#125;在这里，DirFilter 类实现了 FilenameFilter 接口，这个接口十分简单：123public interface FilenameFilter &#123; boolean accept(File dir, String name);&#125;创建这个类的目的在于把 accept() 方法提供给 list() 使用，使 list() 可以回调 accept()，进而决定哪些文件包含在列表中。因此，这种结构也常常称为 回调。accept() 方法必须接收一个代表某个特定文件所在目录的 File 对象，以及包含了特定文件名的一个 String。记住一点，list() 方法会为此目录对象下的每个文件名调用 accept()，来判断该文件是否包含在内，判断结果由 accept() 返回的布尔值表示。这个例子很适合用一个匿名内部类进行改写。首先创建一个 filter() 方法，它会返回一个指向 FilenameFilter 的引用：12345678910111213141516171819202122232425public class DirList &#123; public static FilenameFilter filter(final String regex) &#123; // 创建一个匿名内部类 return new FilenameFilter() &#123; private Pattern pattern = Pattern.compile(regex); public boolean accept(File dir, String name) &#123; return pattern.matcher(name).matches(); &#125; &#125; &#125; public static void main(String[] args) &#123; File path = new File(\".\"); String[] list; if(args.length == 0) &#123; list = path.list(); &#125; else &#123; list = path.list(filter(args[0])); &#125; Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); for(String dirItem : list) &#123; System.out.println(dirItem); &#125; &#125;&#125;注意：传向 filter() 的参数必须是 final 的。这在匿名内部类中是必须的，这样它才能够使用该类范围之外的对象。 目录实用工具程序设计中一项常见的任务就是在文件集上执行操作，这些文件要么在本地目录中，要么遍布于整个目录树。下面的实用工具类就可以通过实用 local() 方法产生由本地目录中的文件构成的 File 对象数组，或者通过使用 find() 方法产生给定目录下的由整个目录树中所有文件构成的 List&lt;File&gt;。File 对象比文件名更有用，因为包含更多的信息。1234567891011121314151617181920212223242526272829303132333435363738394041public class Directory &#123; /* * local() 方法用以寻找当前文件夹内所有的符合规则的文件对象 * find() 方法用以寻找当前文件夹下(包括子文件夹内)所有符合规则的文件对象 */ public static File[] local(File dir, Pattern pattern) &#123; return dir.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; return pattern.matcher(new File(name).getName()).matches(); &#125; &#125;); &#125; public static File[] local(String path, String regex) &#123; return local(new File(path), Pattern.compile(regex)); &#125; public static List&lt;File&gt; find(String start, String regex) &#123; return find(new File(start), Pattern.compile(regex)); &#125; public static List&lt;File&gt; find(File start, Pattern pattern) &#123; List&lt;File&gt; files = new ArrayList&lt;File&gt;(); for(File file: local(start, pattern)) &#123; files.add(file); if(file.isDirectory()) &#123; files.addAll(find(file, pattern)); &#125; &#125; return files; &#125; public static void main(String[] args) &#123; List&lt;File&gt; files = Directory.find(\".\", \".*\"); for(File file : files) &#123; System.out.println(file.getAbsolutePath()); &#125; &#125;&#125;local() 方法实用被称为 listFile() 的 File.list() 的变体来产生文件对象数组。如果需要 List 而不是数组，你可以使用 Arrays.asList() 自己对结果进行转换。find() 方法递归地遍历目录，并在每次递归中都收集更多的信息。 目录的检查及创建File 类不仅仅值代表存在的文件或目录。也可以用 File 对象来创建新的目录或尚不存在的整个目录路径。还可以查看文件的特性，如大小，最后修改日期，读写等，检查该对象对应是一个文件还是一个目录，并可以删除文件。1234567891011121314151617181920212223File file = new File(\".\");// 文件是否存在file.exists();// 获取绝对路径file.getAbsolutePath();// 是否可读file.canRead();// 是否可写file.canWrite();// 文件名file.getName();// 文件的父目录file.getParent();// 文件的相对路径file.getPath();// 文件的大小file.length();// 文件上次修改的日期file.lastModified();// 文件是否为一个目录file.isDirectory();// 删除文件file.delete(); 输入和输出编程语言的IO类库中常实用 流 这个抽象概念，它代表任何有能力产出数据的数据源对象或者是有能力接收数据的接收端对象。“流” 这个概念屏蔽了实际的IO设备中处理数据的细节。Java类库中的IO类分成输入和输出两部分。通过继承，任何自 InputStream 或 Reader 派生而来的类都有名为 read() 的基本方法，用于读取单个字节或字节数组。同样，任何自 OutputStream 或 Writer 派生而来的类都含有 write() 基本方法，用于写单个字节或者字节数组。但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以实用它们，以便提供更有用的接口。因此，我们很少实用单一的类来创建流对象，而是通过 叠加多个对象 来提供所期望的功能（这是装饰器设计模式，也叫包装模式）。实际上，Java中“流”类库让人迷惑的主要原因就在于：创建单一的结果流，却需要创建多个对象。 InputStream 类型InputStream 的作用是用来表示那些从不同数据源产生输入的类，这些数据源包括：字节数组；String 对象；文件；管道：从一端输入，从另一端输出；一个由其他种类的流组成的序列，以便我们可以将它们收集合并到一个流内；其他数据源，如Internet连接等。每一种数据源都有相应的 InputStream 子类。另外，FilterInputStream 也属于一种 InputStream，为“装饰器”（decorator）类提供基类。其中，“装饰器”类可以把属性或有用的接口与输入流连接在一起。类功能参数与如何实用ByteArrayInputStream允许将内存的缓冲区当作 InputStream 使用缓冲区，字节将从中取出。作为一种数据源：将其与 FilterInputStream 对象相连以提供有用接口StringBufferInputStream将 String 转为 InputStream字符串。底层实现实际使用 StringBuffer 作为一种数据源：将其与 FilterInputStream 对象相连以提供有用接口FileInputStream用于从文件中读取信息字符串，表示文件名、文件或 FileDescriptor 对象。作为一种数据源：将其与 FilterInputStream 对象相连以提供有用的接口。PipedInputStream产生用于写入相关 PipedOutputStream 的数据。实现“管道化”概念。PipedOutputStream。作为多线程中数据源：将其与 FilterInputStream 对象相连以提供有用的接口。SequenceInputStream将两个或多个 InputStream 对象转换成单一 InputStream两个 InputStream 对象或一个容纳 InputStream 对象的容器 Enumeration。作为一种数据源：将其与 FilterInputStream 对象相连以提供有用的接口。FilterInputStream抽象类，作为“装饰器”的接口。其中，“装饰器”类为其他 InputStream 类提供有用功能。 OutputStream 类型该类别的类决定了输出所要去往的目标：字节数组（但不是 String，不过你可以由此产生字节数组），文件或管道。另外，FilterOutputStream 为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来。类功能参数与如何使用ByteArrayOutputStream在内存中创建缓冲区。所有送往“流”的数据都要放置在此缓冲区。缓冲区初始化尺寸（可选的）。用于指定数据的目的地：将其与 FilterOutputStream 对象相连以提供有用接口。FileOutputStream用于将信息写至文件。字符串，表示文件名、文件或 FileDescriptor。指定数据的目的地：将其与 FilterOutputStream 对象相连以提供有用接口。PipedOutputStream任何写入其中的信息都会自动作为相关 PipedInputStream 的输出。实现“管道化”概念。PipedInputStream。指定用于多线程的数据的目的地：将其与 FilterOutputStream 对象相连以提供有用接口。FilterOutputStream抽象类，作为“装饰器”接口。其中，“装饰器”为其他 OutputStream 提供有用功能。 添加属性和有用的接口Java IO类库需要多种不同功能的组合，这正是使用装饰器模式的理由所在。这也是存在 filter （过滤器）类的原因所在，抽象类 filter 是所有装饰器类的基类。装饰器类必须具有和它所装饰的对象相同的接口，但它也可以扩展接口，而这种情况是少数。装饰器模式也有一个缺点：在编写程序时，它给我们提供了相当多的灵活性（因为我们可以很容易地混合和匹配属性），但是它同时也增加了代码的复杂性。Java IO类库操作不便的原因在于：我们必须创建许多类–核心IO类型加上所有的装饰器，才能得到我们所希望的单个IO对象。FilterInputStream 和 FilterOutputStream 是用来提供装饰器类接口以控制特定输入流（InputStream）和输出流（OutputStream）的两个类。它们的名字不是很直观。这两个类分别自IO类库的基类 InputStream 和 OutputStream 派生而来。这两个类是装饰器的必要条件（以便能为所有正在被修饰的对象提供通用接口）。 通过 FilterInputStream 从 InputStream 中读取数据FilterInputStream 类能够完成两件完全不同的事情。其中，DataInputStream 允许我们读取不同的基本类型以及 String 对象，所有的方法都以 read 开头，例如：readByte(), readFloat() 等等。搭配相应的 DataOutputStream，我们就可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方。其他 FilterInputStream 类则在内部修改 InputStream 的行为方式：是否缓冲，是否保留它所读过的行（允许我们查询行数或设置行数），以及是否把单一字符推回输入流等等。最后两个类看起来更像是为了创建一个编译器，因此我们在一般编程不会使用它们。我们几乎每次都要对输入进行缓冲，不管我们连接的是什么IO设备。所以，IO类库把无缓冲输入（而不是缓冲输入）作为特殊情况。FilterInputStream 的类型及功能如下表所示：类功能参数以及如何使用DataInputStream与 DataOutputStream 搭配使用，因此我们可以按照可移植方式从流读取基本类型。InputStream。包含用于读取基本类型的所有接口。BufferedInputStream使用它可以防止每次读取都进行实际的写操作。代表“使用缓冲区”。InputStream，可以指定缓冲区大小（可选）。本质上不提供接口，只不过是向进程中添加缓冲区必须的。与接口对象搭配。LineNumberInputStream跟踪输入流中的行号；可调用 getLineNumber() 和 setLineNumber。InputStream。仅仅增加了行号，因此可能要与接口对象搭配使用。PushbackInputStream具有能弹出一个字节的缓冲区。因此可以将读到的最后一个字符返回退。InputStream。通常作为编译器的扫描器，之所以包含在内是因为Java编译器的需要，我们可能永远不会用到。 通过 FilterOutputStream 向 OutputStream 写入与 DataInputStream 对应的是 DataOutputStream，它可以将各种基本类型和 String 对象格式化输入到“流”中。这样一来，任何机器上的任何 DataInputStream 能够读取它们。所有的方法都以 write 开头，例如 writeByte(), writeFloat() 等等。PrintStream 最初的目的便是为了以可视化格式打印所有的基本数据类型以及 String 对象。这和 DataOutputStream 不同，后者的目的是为了将数据置入“流”中，使 DataInputStream 可移植地重构它们。PrintStream 内有两个重要方法：print() 和 println()。对它们进行重载，以便可以打印出各种数据类型。它们之间的差异是，后者在操作完毕后添加一个换行符。PrintStream 可能有些问题，因为它捕捉了所有的 IOException。另外，PrintStream 也未完全国际化，不能以平台无关的方式处理换行动作。BufferedOutputStream 是一个修改过的 OutputStream，它对数据流使用缓冲技术。因此当每次向流写入时，不必每次都进行实际的物理写动作。所以在输出时，我们可能更经常使用它。类功能参数以及如何使用DataOutputStream与 DataInputStream 搭配使用，因此我们可以按照可移植方式向流写入基本类型。OutputStream。包含用于写入基本类型的所有接口。PrintStream用于产生格式化输出。其中 DataOutputStream 处理数据的存储，PrintStream 处理数据的显示。OutputStream，可以用 boolean 值指示是否在每次换行时清空缓冲区。应该是对 OutputStream 对象的 final 封装，可能会经常用到它。BufferedOutputStream使用它以避免每次发送数据时都要进行实际的写操作，代表“使用缓冲区”。可以调用 flush() 方法清空缓冲区。OutputStream,可以指定缓冲区大小（可选）。本质上不提供接口，只不过是向进程中添加缓冲区必须的。与接口对象搭配。 Reader 和 WriterJava 1.1对基本类型的IO流类库进行了重大的修改。Reader 和 Writer 不是用以替代 InputStream 和 OutputStream 的类。尽管一些原始的“流”类库不再被使用，但是 InputStream 和 OutputStream 在以面向字节形式的IO中仍可提供极有价值的功能。Reader 和 Writer 则提供兼容 Unicode 与面向字符的IO功能。另外：Java 1.1向 InputStream 和 OutputStream 的继承层次结构中添加了一些新类，所以显然这两个类是不会取代的。有时我们必须把来自于“字节”层次结构中的类与“字符”层次结构中的类结合起来使用。为了实现这个目的，要用到 “适配器”（adapter） 类：InputStreamReader 可以把 InputStream 转换为 Reader，而 OutputStreamWriter 可以把 OutputStream 转换为 Writer。设计 Reader 和 Writer 继承层次结构主要为了国际化。老的IO流继承层次结构仅支持8位字节流，并不能很好的处理16位的 Unicode 字符。由于 Unicode 用于字符国际化（Java本身的 char 也是16位的 Unicode），所以添加 Reader 和 Writer 继承层次结构就是为了所有的IO操作中都支持 Unicode。另外，新类库的设计使得它的操作比旧类库要快。 数据的来源与去处几乎所有原始的Java IO流类都有相应的 Reader 和 Writer 类来提供天然的 Unicode 操作。然而在某些场合，面向字节的流类库才是正确的解决方案。特别是，java.util.zip 类库就是面向字节的而不是面向字符的。因此，最明智的做法就是尽量使用 Reader 和 Writer，一旦程序无法编译，就转使用流类库。下面展示两个继承层次结构中，信息的来源和去处。来源于去处：Java 1.0类相应的Java 1.1类InputStreamReader：适配器 InputStreamReaderOutputStreamWriter：适配器 OutputStreamWriterFileInputStreamFileReaderFileOutputStraemFileWriterStringBufferInputStream（已弃用）StringReader无相应的类StringWriterByteArrayInputStreamCharArrayReaderByteArrayOutputStramCharArrayWriterPipedInputStreamPipedReaderPipedOutputStreamPipedWriter 更改流的行为对于 InputStream 和 OutputStream 来说，我们会使用 FilterInputStream 和 FilterOutputStream 的装饰器子类来修改“流”以满足特殊需要。Reader 和 Writer 的类继承层次结构继续沿用相同的思想，但是并不完全相同。过滤器：Java 1.0类相应的Java 1.1类FilterInputStreamFilterReaderFilterOutputStreamFilterWriter（抽象类，没有子类）BufferedInputStreamBufferedReader（也有 readLine()）BufferedOutputStreamBufferedWriterDataInputStream使用 DataInputStreamPrintStreamPrintWriterLineNumberInputStream（已弃用）LineNumberReaderStreamTokenizerStreamTokenizer(使用接受 Reader 的构造器)PushbackInputStreamPushbackReader有一点很清楚：无论何时使用 readLine()，都不应该使用 DataInputStream，而应该使用 BufferedReader。除了这一点，DataInputStream 仍是IO类库的首选成员。为了更容易地过渡到使用 PrintWriter，它提供了一个既能接受 Writer 对象有能接受任何 OutputStream 对象的构造器。PrintWriter 的格式化接口实际上与 PrintStream 相同。 未发生变化的类有一些类在Java 1.0和Java 1.1之间则未做改变：DataOutputStreamFileRandomAccessFileSequenceInputStream特别是 DataOutputStream，在使用时没任何变化。因此如果想以“可传输的”格式存储和检索数据，可以使用IO流继承层次结构。 自我独立的类：RandomAccessFileRandomAccessFile 适用于大小已知的记录组成的文件，所以我们可以使用 seek() 将记录从一处转移到另一处，然后读取或修改记录。文件中记录的大小不一定都相同，只要我们能够确定那些记录有多大以及它们在文件中的位置即可。它是一个完全独立的类，从头开始编写其所有的方法。这么做是因为其拥有和别的IO类型本质不同的行为，因为我们可以在一个文件内向前或向后移动。在任何情况下，它都是自我独立的，直接从 Object 派生而来。其中方法 getFilePointer() 用于查找当前所处的文件位置，seek() 用于在文件内移至新的位置，length() 用于判断文件的最大尺寸。另外，其构造器还需要第二个参数（和C中的 fopen() 一样）用来指示我们只是“随机读”（r）还是“既读又写”（rw）。它并不支持只写文件。只有 RandomAccessFile 支持搜寻方法，并且只适用于文件。BufferedInputStream 却能允许标注（mark()）位置（其值存储与内部某个简单变量）和重新设定位置（reset()），但这些功能都不是非常有用。 IO流的典型使用方式尽管可以通过不同的方式组合IO流类，但我们可能也只用到其中的几种组合。下面的例子可以作为典型的IO用法的基本参考。 缓冲输入文件如果想要打开一个文件用于字符输入，可以使用以 String 对象或 File 对象作为文件名的 FileInputReader。为了提供速度，我们希望对那个文件进行缓冲，那么我们将所产生的引用传给一个 BufferedREader 构造器。由于 BufferedREader 也提供 readLine() 方法，所以这是我们最终对象和进行读取的接口。当 readLine() 返回 null 时，就到达了文件的末尾。12345678910111213141516public class BufferedInputFile &#123; public static String read(String filename) throws IOException &#123; BufferedReader in = new BufferedReader(new FileReader(filename)); String s; StringBuilder sb = new StringBuilder(); while((s = in.readLine()) != null) &#123; sb.append(s + \"\\n\"); &#125; in.close(); return sb.toString(); &#125; public static void main(String[] args) throws IOException&#123; System.out.println(read(\"BufferedInputFIle.java\")); &#125;&#125;字符串 sb 用来累积文件的全部内容（包括必须添加的换行符，因为 readLine()已将它们删掉 ）。最后，调用 close() 关闭文件。 从内存输入下面的示例中，从 BufferedInputFile.read() 读如的 String 结果被用来创一个 StringReader。然后调用 read() 每次读取一个字符，并把它发送到控制台。12345678910public class MemoryInput &#123; public static void main(String[] args) throws IOException&#123; StringReader in = new StringReaer(BufferedInputFile.read( \"MemoryInput.java\")); int c; while((c = in.read()) != -1) &#123; System.out.println((char)c); &#125; &#125;&#125;注意：read() 是以 int 形式返回下一字节，因此必须类型转换为 char 才能正确打印。 格式化的内存输入要读取格式化数据，可以使用 DataInputStream，它是一个面向字节的IO类。因此我们必须使用 InputStream 而不是 Reader 类。12345678910111213public class FormattedMemoryInput &#123; public static void main(String[] args) throws IOException &#123; try&#123; DataInputStream in = new DataInputStream( new BufferedInputStream(new FileInputStream(\"TestEOF.java\"))); while(in.available() != 0) &#123; System.out.println((char)in.readByte()); &#125; &#125; catch(EOFException e) &#123; System.out.println(\"End of stream\"); &#125; &#125;&#125;注意：available() 的工作方式会随着所读取的媒介类型的不同而有所不同：字面意思就是在没有阻塞的情况下所能读取的字节数。对于文件，这意味着整个文件。但是对于不同类型的流，可能就不是这样的，因此要谨慎使用。我们也可以通过捕获异常来检测输入的末尾。 基本的文件输出FileWriter 对象可以向文件写入数据。首先，创建一个与指定文件连接的 FileWriter。实际上，我们通常会用 BufferedWriter 将其包装起来用以缓冲输出。在本例中，它被装饰成了 PrintWriter，以提供格式化机制：123456789101112131415public class BasicFileOutput &#123; static String file = \"BasicFileOutput.out\"; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader( new StringReader(BufferedInputFile.read(\"BasicFIleOutput.java\"))); PrintWriter pw = new PrintWriter( new BufferedWriter(new FileWriter(file))); int lineCount = 1; String s; while((s = in.readLine()) != null) &#123; pw.println(lineCount++ + \": \" + s); &#125; pw.close(); &#125;&#125;如果我们不显式调用 close()，就会发现缓冲区内容不会被刷新清空，那么文本也就不完整。Java SE5在 PrintWriter 中添加了一个辅助构造器，使得你不必在每次希望创建文本文件并向其中写入时，都去执行所有的装饰工作。12String filename = \"test.java\"PrintWriter pw = new PrintWriter(filename); 存储和恢复数据PrintWriter 可以对数据进行格式化，以便人们的阅读。但是为了输出可供另一个“流”恢复的数据，我们需要用 DataOutputStream 写入数据，并用 DataInputStream 恢复数据。当然，这些流可以是任何形式。1234567891011121314151617public class StoringAndRecoveringData &#123; public static void main(String[] args) throws IOException &#123; DataOutputStream out = new DataOutputStream( new BufferedOutputStream( new FileOutputStream(\"Data.txt\"))); out.writeDouble(3.14159); out.writeUTF(\"That was pi!\"); out.close(); DataInputStream in = new DataInputStream( new BufferedInputStream( new FileInputStream(\"Data.txt\"))); System.out.println(in.readDouble()); System.out.println(in.readUTF()); in.close(); &#125;&#125;如果我们使用 DataOutputStream 写入数据，Java保证我们可以使用 DataInputStream 准确地读取数据，无论读和写的数据的平台多么的不同。当我们使用 DataOutputStream 时，写字符串并且让 DataInputStream 能够恢复它的唯一可靠的做法就是使用 UTF-8 编码。UTF-8 是一种多字节格式，其编码长度根据实际使用的字符集会有所变化。UTF-8 将 ASCII 字符白鞍马成单一字节的形式，而非 ASCII 字符则编码成两到三个字节的形式。另外，字符串的长度存储在 UTF-8 字符串的前两个字节中。但是 writeUTF() 和 readUTF() 使用的是适合于Java的UTF-8变体，因此我们用一个非Java程序读取用 writeUTF() 所写的字符串，编序编写一些特殊代码才能正确读取字符串。注意，对象序列化和XML可能是更容易的存储和读取复杂数据结构的方式。 读写随机访问文件使用 RandomAccessFile 时，你必须知道文件排版，这样才能正确操作它。其拥有读取基本类型和UTF-8字符串的各种具体方法：1234567891011121314151617181920212223242526public class UsingRandomAccessFile &#123; static String file = \"rtest.dat\"; static void display() throws IOException &#123; RandomAccessFile rf = new RandomAccessFile(file, \"r\"); for(int i=0;i&lt;7;i++) &#123; System.out.println(\"Value\" + i + \": \" + rf.readDouble()); &#125; System.out.println(rf.readUTF()); rf.close(); &#125; public static void main(String[] args) throws IOException &#123; RandomAccessFile rf = new RandomAccessFile(file, \"rw\"); for(int i=0;i&lt;7;i++) &#123; rf.writeDouble(i*1.414); &#125; rf.writeUTF(\"End of file!\"); rf.close(); display(); rf = new RandomAccessFile(file, \"rw\"); rf.seek(5*8); System.out.println(rf.readDouble()); rf.close(); &#125;&#125;因为 double 总是8字节长，所以使用 seek(5*8) 查找第5个双精度值。 文件读写的实用工具一个常见的程序化人物就是读取文件到内存，修改，然后再写出。12345678910111213141516171819202122232425262728293031323334353637public class TextFile &#123; // 读取文件内的内容 public static String read(String filename) &#123; StringBuilder sb = new StringBuilder(); try &#123; BufferedReader br = new BufferedReader(new FileReader( new File(filename).getAbsoluteFile())); try &#123; String s; while((s = br.readLine()) != null) &#123; sb.append(s); sb.append(\"\\n\"); &#125; &#125; finally &#123; br.close(); &#125; &#125; catch(IOException e) &#123; throw new RuntimeException(e); &#125; return sb.toString(); &#125; // 向文件写入内容 public static void write(String filename, String text) &#123; try &#123; PrintWriter pw = new PrintWriter( new File(filename).getAbsoluteFile()); try &#123; pw.print(text); &#125; finally &#123; pw.close(); &#125; &#125; catch(IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 读取二进制文件12345678910111213public class BinaryFile &#123; public static byte[] read(File bFile) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream( new FileInputStream(bFile)); try &#123; byte[] data = new byte[bis.available()]; bis.read(data); return data; &#125; finally &#123; bis.close(); &#125; &#125;&#125;available() 方法被用来产生恰当的数组尺寸，并且 read() 方法的特定的重载版本填充了这个数组。 标准IO标准IO这个术语参考的是Unix中“程序所使用的单一信息流”这个概念。程序的所有输入都可以来自于 标准输入，它的所有输出也都可以发送到 标准输出，以及所有的错误信息都可以发送到 标准错误。标准IO的意义在于：我们可以很容易地把程序串联起来，一个程序的标准输出可以称为另一程序的标准输入。 从标准输入中读取按照标准IO模型，Java提供了 System.in，System.out 和 System.err。System.out 已经实现被包装成了 PrintStream 对象。System.err 同样也是 PrintStream，但 System.in 却是一个没有被包装国的未经加工的 InputStream。这意味着我们可以立即实用 System.out 和 System.err，但是在读取 System.in 之前必须对其进行包装。通常我们会用 readLine() 一次一行地读取输入，为此，我们将 System.in 包装成 BufferedReader 来使用。123456789public class Echo &#123; public static void main(String[] args) throws IOException &#123; BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in)); String s; while((s = stdin.readLine()) != null &amp;&amp; s.length() != 0) &#123; System.out.println(s); &#125; &#125;&#125; 将 System.out 转换成 PrintWriterSystem.out 是一个 PrintStream，而 PrintStream 是一个 OutputStream。PrintWriter 有一个可以接受 OutputStream 作为参数的构造器：12PrintWriter pw = new PrintWriter(System.out, true);pw.println(\"Hello world!\");将第二个参数设为 true，以便开启自动清空功能。否则，你可能看不到输出。 标准IO重定向Java的 System 类提供了一简单的静态方法调用，以允许我们对标准输入，输出和错误IO流进行重定向：setIn(InputStream)setOut(PrintStream)setErr(printStream)如果我们突然开始在显示器创建大量输出，而这些输出滚动太快以至于无法阅读时，重定向输出就显得极为有用。1234567891011121314151617public class Redirecting &#123; public static void main(String[] args) throws IOException &#123; PrintStream console = System.out; BufferedInputStream in new BufferedInputStream(new FileInputStream(\"Redirecting.java\")); PrintStream out = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"test.out\"))); System.setIn(in); System.setOut(out); System.setErr(out); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String s; while((s = br.readLine()) != null) &#123; System.out.println(s); &#125; out.close(); SYstem.setOut(console); &#125;&#125;这个程序将标准输入附接到文件上，并将标准输出和标准错误重定向到另一个文件。注意，它在程序开头存储了对最初的 System.in 对象的引用，并且在结尾处将系统输出恢复到了该对象上。IO重定向操纵的是字节流，而不是字符流。 进程控制你经常会需要在Java内部执行其他操作系统的程序，并且要控制这些程序的输入和输出。一项常见的人物是运行程序，并将产生的输出发送到控制台。12345678910111213141516public class OSExecute &#123; public static void command(String command) &#123; boolean err = false; Process process = new ProcessBuilder(command.split(\" \")).start(); BufferedReader results = new BufferedReader(new InputStreamReader(process.getInputStream())); String s; while((s = results.readLine()) != null) &#123; System.out.println(s); &#125; BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream())); while((s = errors.readLine()) != null) &#123; System.err.println(s); err = true; &#125; &#125;&#125;java.lang.ProcessBuilder 构造器要求命令作为一个 String 对象序列而被传递，然后所产生的 ProcessBuilder 对象被启动。 新IOJDK 1.4的 java.nio.* 包中引入了新的Java IO类库，其目的在于提高速度。实际上，旧的IO包已经使用 nio 重新实现国，以便充分利用这种速度提高。因此，即使我们不显式地用 nio 编写代码，也能从中收益。速度的提高来自于所使用的结构更接近于操作系统执行IO的方式：通道 和 缓冲器。我们并不直接和通道交互，我们只是和缓冲器交互，并把缓冲器派送到通道。通道要么从缓冲器获得数据，要么向缓冲器发送数据。唯一直接与通道交互的缓冲器是 ByteBuffer，这是可以存储未加工字节的缓冲器。java.nio.ByteBuffer 是相当基础的类：通过告知分配多少存储空间来创建一个 ByteBuffer 对象，并且还有一个方法选择集，用于以原始的字节形式或基本数据类型输出和读取数据。但是，没办法输出或读取对象，即使是字符串对象也不行。旧IO类库有三个类被修改了，用以产生 FileChannel。这三个被修改的类是 FileInputStream,FileOutputStream以及用于读写的 RandomAccessFile。注意这些是字节操纵流，与低层的 nio 性质一致。Reader 和 Writer 这种字符模式类不能用于产生通道，但是 java.nio.channels.Channels 类提供了实用方法，用以在通道中产生 Reader 和 Writer。1234567891011121314151617181920212223public class GetChannel &#123; private static final int BSIZE = 1024; public static void main(String[] args) throws Exception &#123; // 写文件 FileChannel fc = new FileOutputStream(\"data.txt\").getChannel(); fc.write(ByteBuffer.wrap(Some text).getBytes()); fc.close(); fc = new RandomAccessFile(\"data.txt\", \"rw\").getChannel(); fc.position(fc.size()); // 移动到末尾 fc.write(ByteBuffer.wrap(\"Some more\".getBytes())); fc.close(); // 读文件 fc = new FileInputStream(\"data.txt\").getChannel(); ByteBuffer buff = ByteBuffer.allocate(BSIZE); fc.read(buff); buff.flip(); while(buff.hasRemaining()) &#123; System.out.println((char)buff.get()); &#125; &#125;&#125;getChannel() 将会产生一个 FileChannel。通道是一种相当基础的东西：可以向它传送用于读写的 ByteBuffer，并且可以锁定文件的某些区域用于独占式访问。将字节存放于 ByteBuffer 的方法之一是：实用一个 put 方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值。也可以实用 wrap() 方法将已存在的字节数组包装到 ByteBuffer 中。一旦如此，就不再复制底层的数组，而是把它作为所产生的 ByteBuffer 的存储器，称之为数组支持的 ByteBuffer。对于只读访问，我们必须显示地实用静态的 allocate() 方法来分配 ByteBuffer。nio 的目标是快速移动大量数据，因此 ByteBuffer 的大小就显得尤为重要。通常需要实际运行应用程序来找到最佳尺寸。为了达到更高的速度，方法就是实用 allocateDirect() 而不是 allocate()，以产生一个与操作系统有更高耦合性的“直接”缓冲器。但是，这种分配的开支会更大。一旦调用 read() 来告知 FileChannel 向 ByteBuffer 存储字节，就必须调用缓冲器上的 flip()，让它做好让别人读取字节的准备。如果我们打算使用缓冲器执行进一步的 read() 操作，也必须地调用 clear() 来为每个 read() 做好准备。1234567891011121314public class ChannelCopy &#123; private static final int BSIZE = 1024; public static void main(String[] args) throws Exception &#123; if(args.length != 2) System.exit(1); FileChannel in = new FileInputStream(args[0]).getChannel(); FileChannel out = new FileOutputStream(args[1]).getChannel(); ByteBuffer buffer = ByteBuffer.allocate(BSIZE); while(in.read(buffer) != -1) &#123; buffer.flip(); // 准备好写 out.write(buffer); buffer.clear(); // 准备好读 &#125; &#125;&#125;每次 read() 操作之后，就会将数据输入到缓冲器中，flip() 则是准备缓冲器以便它的信息可以由 write() 提取。write() 操作之后，信息仍在缓冲器中，接着 clear() 操作则对所有的内部指针重新安排，以便缓冲器在另一个 read() 操作期间能够做好接受数据的准备。特殊方法 transferTo() 和 transferFrom() 允许我们将一个通道和另一个通道直接相连：12345678910public class TransferTo &#123; public static void main(String[] args) throws Exception &#123; if(args.length != 2) System.exit(1); FileChannel in = new FileInputStream(args[0]).getChannel(); FileChannel out = new FileInputStream(args[1]).getChannel(); in.transferTo(0, in.size(), out); // or // out.transferFrom(in, 0, in.size()); &#125;&#125; 转换数据java.nio.CharBuffer 这个类的 toString() 方法是这样定义的：返回一个包含缓冲器中所有字符的字符串。ByteBuffer 可以看作是具有 asCharBuffer() 方法的 CharBuffer。12345678910public class BufferToText &#123; public static void main(Stringp[] args) &#123; FileChannel fc = new FileInputStream(\"data2.txt\").getChannel(); ByteBuffer buff = ByteBuffer.allocate(1024); fc.read(buff); fc.flip(); // 对字节数组解码 System.out.println(Charset.forName(\"UTF-8\").decode(buff)); &#125;&#125; 获取基本类型尽管 ByteBuffer 只能保存字节类型的数据，但是它具有可以从其所容纳的字节中产生出各种不同基本类型值的方法。插入基本类型数据的最简单的方式是：利用 asCharBuffer()，asShortBuffer() 等获得该缓冲器上的视图，然后使用试图的 put() 方法。注意，使用 ShortBuffer 时候需要进行类型转换。 视图缓冲器视图缓冲器（view buffer） 可以让我们通过某个特定的基本数据类型的视窗查看其底层的 ByteBuffer。ByteBuffer 依然是实际存储数据的地方，支持着前面的视图，因此，对视图的任何修改都会映射成为对 ByteBuffer中数据的修改。视图还允许我们从 ByteBuffer 一次一个地或者成批地读取基本类型值。123456789101112131415public class IntBufferDemo &#123; private static final int BSIZE = 1024; public static void main(String[] args) &#123; ByteBuffer buffer = ByteBuffer.allocate(BSIZE); IntBuffer ib = buffer.asIntBuffer(); ib.put(new int[]&#123;11, 42, 47, 99, 143, 811, 1016&#125;); System.out.println(ib.get(3)); ib.put(3, 1811); ib.flip(); while(ib.hasRemaining()) &#123; int i = ib.get(); System.out.println(i); &#125; &#125;&#125;一旦底层的 ByteBuffer 通过视图缓冲器填满了整数或其他基本类型时，就可以直接被写到通道中。不同的机器可能会使用不同的字节排序方法来存储数据。“big endian”(高位优先) 将最重要的字节存放在地址最低的存储单元。而 “little endian”(低位优先) 则是将最终要的字节放在地址最高的存储单元。当存储量大于一个字节时，像 int, float 等，就要考虑字节的顺序问题。ByteBuffer 是以高位优先的形式存储数据的，并且数据在网上传送时也常常使用高位优先的形式。我们可以使用带有参数 ByteOrder.BIG_ENDIAN 或 ByteOrder.LITTLE_ENDIAN 的 order() 方法改变 ByteBuffer 的字节排序方式。如果我们以 short 形式读取数据，得到的数字是97(二进制形式为：00000000 01100001)。但是如果更改为低位优先的形式，得到数字却是24832(二进制形式为：01100001 00000000)。ByteBuffer 有足够的空间，以存储作为外部缓冲器的 charArray 中所有的字节，因此可以调用 array() 方法显示视图底层的字节。array() 方法是可选的，并且我们只能对由数组支持的缓冲器调用此方法。否则，将会抛出 UnsupportedOperationException。 用缓冲器操纵数据如果想把一个字节数组写到文件中去，那么就应该使用 ByteBuffer.wrap() 方法把字节数组包装起来，然后用 getChannel() 方法在 FileOutputStream 上打开一个他哦哦那个到，接着将来自于 ByteBuffer 的数据写到通道中。注意：ByteBuffer 是将数据移进移出通道的唯一方式，并且我们只能创建一个独立的基本类型缓冲器，或者使用 as 方法从其获得。 缓冲器的细节Buffer 由数据和可以高效地访问及操作这些数据的四个索引组成：mark，标记position，位置limit，界限capacity，容量capacity()返回缓冲区容量clear()清空缓冲区，将position设置为0，limit设置为容量flip()将limit设置为position，position设置为0.此方方用于准备从缓冲区读取已经写入的数据limit()返回limit值litmit(int lim)设置limit值mark()将makr设置为positionposition()返回position值position(int pos)设置position值remaining()返回（limit - position）hasRemaining()若有介于position和limit之间的元素，则返回 true在缓冲器中插入和提取数据的方法会更新这些索引，用于反映所发生的变化。 内存映射文件内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件。有了内存映射文件，我们就可以假定整个文件都放在内存中，而且可以完全把它当作非常大的数组来访问。12345678910111213public class LargeMappedFiles &#123; static int length = 0x8FFFFFF; // 128MB public static void main(String[] args) &#123; MappedByteBuffer out = new RandomAccessFIle(\"test.data\", \"rw\").getChannel() .map(FIleChannel.MapMode.READ_WRITE, 0, length); for(int i=0;i&lt;length;i++) &#123; out.put((byte)'x'); &#125; for(int i=length/2;i&lt;length/2+6;i++) &#123; System.out.println((char)out.get(i)); &#125; &#125;&#125;获得该文件上的通道后，然后调用 map() 方法以产生 MappedByteBuffer，这是一种特殊类型的直接缓冲器。注意我们必须指定映射文件的初始文值和映射区域的长度，这意味着我们可以映射某个大文件的较小的部分。MappedByteBuffer 由 ByteBuffer 继承而来，因此它具有 ByteBuffer 的所有方法。映射文件访问往往可以更加显著地加快速度，但是建立映射文件的花费很大，这个需要根据具体的场景选择使用。 文件加锁JDK 1.4引入了文件加锁机制，它允许我们同步访问某个作为共享资源的文件。文件锁对其他的操作系统进程是可见的，因为Java的文件加锁直接映射到了本地操作系统的加锁工具。1234567891011public class FileLocking &#123; public static void main(String[] args) throws Exception &#123; FileOutputStream fos = new FileOutputStream(\"file.txt\"); FileLock fileLock = fos.getChannel().tryLock(); // 尝试对文件上锁 if(fileLock != null) &#123; System.out.println(\"locked file\"); fileLock.release(); // 释放文件锁 &#125; fos.close(); &#125;&#125;通过对 FileChannel 调用 tryLock() 或 lock() 方法就可以获得整个文件的 FileLock。SocketChannel, DatagramChannel 和 ServerSocketChannel 不需要加锁，因为它们是从单进程实体继承而来，我们通常不在两个进程之间共享socket。tryLock() 方法是非阻塞式的，它设法获取锁，但是如果不能获得，它将直接从方法调用返回。lock() 则是阻塞式的，它要阻塞进程直至锁可以获得，或调用 lock() 的线程中断，或调用 lock() 的通道关闭。使用 FileLock.release() 可以释放锁。也可以使用下面的方法对文件的一部分上锁：123tryLock(long position, long size, boolean shared);// 或者lock(long position, long size, booean shared);其中，加锁的区域由size-position决定。第三个参数指定是否是共享锁。例如，可以在数据库的数据文件中使用这种技术，只对需要影响的地方加锁，因此多个用户可以同时访问到它。对独占锁或者共享锁的支持必须由底层的操作系统提供。如果操作系统不支持共享锁并为每一个请求都创建一个锁，那么它就会使用独占锁。锁的类型（共享或独占）可以通过 FileLock.isShared() 进行查询。 压缩Java IO类库中的类支持读写压缩格式的数据流。这些类属于 InputStream 和 OutputStream 继承层次结构的一部分。这样做是因为压缩类库按字节方式而不是按字符方式处理。压缩类功能CheckedInputStreamGetCheckSum() 为任何 InputStream 产生校验和（不仅是解压缩）CheckedOutputStreamGetCheckSum() 为任何 OutputStream 产生校验和（不仅是压缩）DeflaterOutputStream压缩类的基类ZipOutputStream用于将数据压缩成Zip文件格式GZIPOutputStream用于将数据压缩成GZIP文件格式InflaterInputStream解压缩类的基类ZipInputStream用于解压缩Zip文件格式的数据GZIPInputStream用于解压缩GZIP文件格式的数据 用GZIP进行简单压缩GZIP接口非常简单，因此如果我门只想对单个数据流（而不是一系列互异数据）进行压缩，那么它可能是比较适合的选择。12345678910111213public class GZIPcompress &#123; public static void main(String[] args) throws IOException &#123; BufferedReader in = new BufferedReader(new FileReader(\"data.txt\")); BufferedOutputStream out = new BufferedOutputStream( new GZIPOutputStream(new FileOutputStream(\"data.gz\"))); int c; while((c = in.read()) != -1) &#123; out.write(c); &#125; in.close(); out.close(); &#125;&#125;压缩类的使用非常直观，直接将输出流封装成 GZIPOutputStream 或 ZipOutputStream，并将输入流封装成 GZIPInputStream 或 ZipInputStream 即可。其他全部操作就是通常的IO读写。 用Zip进行多文件保存支持Zip格式的Java库更加全面。利用该库可以方便地保存多个文件，它甚至有一个独立的类，使得读取Zip文件更加方便。这个类库使用的是标准Zip格式，所以能于当前那些可通过因特网下载的压缩工具很好地写作。使用 Checksum 类来计算和校验文件的校验和的方法。一共有两种 Checksum 类型：Adler32 （快一些）和 CRC32 (慢一些，但更准确)。1234567891011121314151617181920public class ZipCompress &#123; public static void main(String[] args) throws IOException &#123; FileOutputStream f = new FileOutputStream(\"test.zip\"); CheckedOutputStream csum = new CheckedOutputStream(f, new Adler32()); ZipOutputStream zos = new ZipOutputStream(csum); BufferedOutputStream out = new BufferedOutputStream(zos); zos.setComment(\"A test of Java Zipping\"); for(String arg: args) &#123; BufferedReader in = new BufferedReader(new FileReader(arg)); zos.putNextEntry(new ZipEntry(arg)); int c; while((c = in.read()) != -1) &#123; out.write(c); &#125; in.close(); out.flush(); &#125; out.close(); &#125;&#125;对于每一个要加入压缩档案的文件，都必须调用 putNextEntry()，并将其传递给一个 ZipEntry 对象。ZipEntry 对象包含了一个功能很广泛的接口，允许你获取和设置Zip文件内该特定项上所有可利用的数据：名字、压缩的和未压缩的文件大小、日期、CRC校验和、额外字段数据、注释、压缩方法以及它是否是一个目录入口等等。然而，尽管Zip格式提供了设置密码的方法，但Java的Zip类库并不提供这方面的支持。为了解压缩文件，ZipInputStream 提供一个 getNextEntry() 方法返回下一个 ZipEntry（如果存在的话）。解压缩文件有一个更简便的方法，利用 ZipFile 对象读取文件。该对象有一个 entries() 方法用来向 ZipEntries 返回一个 Enumeration （枚举）。 对象序列化当你创建对象，只要你需要，它就会一直存在，但是程序终止时，它不会继续存在。如果对象能够在程序不运行的情况下仍能存在并保存其信息，那将非常有用。这样，在下次运行程序时，该对象将被重建，并且拥有的信息与程序上次运行时所有的信息相同。当然，你可以通过将信息写入文件或数据库来达到相同的效果。但如如果能够将一个对象声明为“持久性”的，并为我们处理掉所有细节，那将会非常方便。Java的对象序列化将那些实现了 Serializable 接口的对象转换为一个字节序列，并能够在以后将这个字节序列完全恢复为原有的对象。这一过程甚至可通过网络进行，这意味着序列化机制能够自动弥补不同操作系统之间的差异。对象的序列化非常有趣，因为利用它可以实现 轻量级持久性（lightweight persistence）。通过将一个序列化对象写入磁盘，然后在重新调用程序时恢复该对象，就能够实现持久性的效果。对象序列化主要为了支持两种主要特性。一是Java的 远程方法调用（Remote Method Invocatrion， RMI） ，它使存活于其他计算机上的对象使用起来就像存活于本机上一样。当向远程对象发送信息时，需要通过对象序列化来传输参数和返回值。 再者，对JavaBean来说，对象的序列化也是必须的。只要对象实现了 Serializable 接口（该接口仅是一个标记接口，不包括任何方法），对象的序列化处理就会非常简单。要序列化一个对象，首先要创建某些 OutputStream 对象，然后将其封装在一个 ObjectOutputStream 对象内。这时，只需调用 writeObject() 方法即可将对象序列化，并将其发送给 OutputStream。要恢复一个对象，需要将一个 InputStream 封装在 ObjectInputStream 内，然后调用 readObject()。我们获得的是一个 Object 引用，必须向下转型才能直接设置它们。对象序列化特别聪明的一个地方是它不仅保存了对象的全景图，而且能追踪对象内所包含的所有引用，并保存那些对象；接着又能对对象内包含的每个这样的引用进行追踪；依次类推。这种情况被称为“对象网”，单个对象可与之建立连接。Java的对象序列似乎找不出什么缺点，所以请尽量不要自己动手，让它用优化的算法自动维护整个对象网。123456789101112131415161718192021Class Data implements Serializable &#123; private int n; public Data(int n) &#123;this.n = n&#125;; public String toString() &#123;return \"n: \" + n;&#125; public static void main(String[] args) throws ClassNotFoundException&#123; Data data = new Data(123456); ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(\"data.out\")); out.writeObject(data); out.close(); ObjectInputStream in = new ObjectInputStream( new FileInputStream(\"data.out\")); Data recoverData = (Data)in.readObject(); in.close(); System.out.println(recoverData); &#125;&#125; transient 关键字当我们对序列化进行控制时，可能某个特定子对象不想让Java的序列化机制自动保存与恢复。可以使用 transient (瞬时)关键字逐个字段地关闭序列化。 XML一种更具互操作性的解决方案是将数据转化为XML格式，这可以使其被各种各样的平台和语言使用。因为XML十分流行，所以用它来编程时的各种选择不胜枚举，包括随JDK发布的 javax.xml.* 类库。你也可以使用开源的XOM类库，因为它看起来最简单，同时也是最直观的用Java产生和修改XML的方式。另外XOM还强调了XML正确性。 PerferencesPreferences API与对象序列化相比，前者与对象持久性更密切，因为它可以自动存储和读取信息。不过，它只能用于小的、受限的数据集合–我们只能存储基本类型和字符串，并且每个字符串的存储长度不能超过8K。顾名思义，Preferences API用于存储和读取用户的偏好（preferences）以及程序配置项的设置。Preferences是一个键-值集合（类似映射），存储在一个节点层次结构中。尽管节点层次结构可用来创建更为复杂的结构，但通常是创建以你的类名命名的单一节点，然后将信息存储于其中。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"17-容器深入研究","slug":"Java编程思想/17-容器深入研究","date":"2020-06-21T15:20:01.000Z","updated":"2020-06-21T15:20:14.559Z","comments":true,"path":"Java编程思想/17-容器深入研究/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/17-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/","excerpt":"","text":"完整的容器分类法Java SE5 新添加了：Queue 接口及其实现 PriorityQueue 和各种风格的 BlockingQueueConcurrentMap 接口及其实现 COncurrentHashMap，它们也是用于多线程机制的。CopyOnWriteArrayList 和 CopyOnWriteArraySet，它们也是用于多线程机制的。EnumSet 和 EnumMap，为使用 enum 而设计的 Set 和 Map 的特殊实现。在 Collections 类中的多个便利方法。虚线框表示 abstract 类，你可以看到大量的类的名字都是以 Abstract 开头的。这些抽象类只是部分实现了特定接口的工具。例如，如果你在创建自己的 Set，那么并不用从 Set 接口开始并实现其中的全部方法，只需从 ABstractSet 继承，然后执行一些创建新类必须的工作。 填充容器就像 Arrays 一样，相应的 Collections 类也有一些实用的 static 方法，其中包括 fill()。与 Arrays 版本一样，此 fill() 方法也是只复制同一个对象引用来填充整个容器的，并且只对 List 对象有用，但是所产生的列表可以传递给构造器或 addAll() 方法:12345678910public class FillingLists &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;( Collections.nCopies(5, \"hello\") ); System.out.println(list); Collections.fill(list, \"Halo\"); System.out.println(list); &#125;&#125;fill() 方法的用处有限，因为它只能替换已经在 List 中存在的元素，而不能添加新的元素。 Collection 的功能方法下面表格列出了可以通过 Collection 执行的所有操作（不包括 Object 继承而来的方法）。因此，它们也是可通过 Set 或 List 执行的所有操作（List 还有额外的功能）。Map 不是继承自 Collection 的，下面另行介绍。方法介绍boolean add(T)确保容器持有具有泛型类型的参数。如果没有将此参数添加进容器，则返回 false（这是“可选”的方法）boolean addAll(Collection&lt;? extends T&gt;)添加参数中的所有元素，只要添加任意元素就返回 true（可选的）void clear()移除容器中的所有元素（可选的）boolean contain(T)如果容器已经持有具体泛型类型参数，则返回 trueBoolean containsAll(Collection&lt;?&gt;)如果容器持有此参数中的所有元素，则返回 trueboolean isEmpty()容器中没有元素时返回 trueIterator&lt;T&gt; iterator()返回一个迭代器，可以用来遍历容器中的元素Boolean remove(Object)如果参数在容器中，则移除此元素的一个实例。如果做了移除动作，则返回 true（可选的）boolean removeAll(Collection&lt;?&gt;)移除参数中的所有元素，只要有移除动作发生就返回 true（可选的）Boolean retainAll(Collection&lt;?&gt;)只保存参数中的元素（应用集合论的“交集”概念）。只要Collection 发生了改变就返回 true（可选的）int size()返回容器中元素的数目Object[] toArray()返回一个数组，该数组包含容器中的所有元素&lt;T&gt; T[] toArray(T[] a)返回一个数组，该数组包含容器中的所有元素，返回结果的运行时类型与参数数组的类型相同，而不是单纯的 Object请注意，其中不包括随机访问所选择元素的 get() 方法。因为 Collection 包括 Set，而 Set 是自己维护内部顺序的（这使随即访问变得没有意义）。因此，如果想检查 Collection 中的元素，那就必须使用迭代器。 可选操作执行各种不同的添加和移除的方法在 Collection 接口中都是可选操作。这意味着实现类并不需要为这些方法提供功能定义。这是一种很不寻常的接口定义方式。接口是面向对象设计中的契约，它声明：无论你选择如何实现该接口，我保证你可以向该接口发送这些消息。但是可选操作违反了这个非常基本的原则，它声明调用某些方法将不会执行有意义的行为。相反，它们会抛出异常。这看起来好像是编译期类型安全被抛弃了。为什么会将方法定义为可选的？那时因为这样做可以防止在设计中出现接口爆炸的情况。未获支持的操作是一种特例，可以延迟到需要时再实现。但是为了让这种方式能够工作：UnsupportedOperationException 必须是一种罕见事件。即，对于大多数类来说，所有操作都应该可以工作，只有在特例中才会有未获支持的操作。如果一个操作是未获支持的，那么在实现接口的时候可能就会导致 UnsupportedOperationException 异常，而不是将产品程序交给客户以后才出现此异常。注意：未获支持的操作只有在运行时才能探测到，因此它们表示动态类型检查。 未获支持的操作最常见的未获支持的操作，都来源于背后由固定尺寸的数据结构支持的容器。当你用 Arrays.asList() 将数组转换为 List 时，就会得到这样的容器。你还可以通过使用 Collections 类中“不可修改”的方法，选择创建任何都会抛出 UnsupportedOperationException 的容器（包括 Map）。因为 Arrays.asList() 会生成一个 List，它基于一个固定大小的数组，仅支持那些不会改变数组大小的操作。任何会引起地层数据结构的尺寸进行修改的方法都会产生一个 UnsupportedOperationException 异常，以表示对未获支持操作的调用。注意：应该把 Arrays.asList() 的结果作为构造器的参数传递给任何 Collection 或使用 addAll() 方法或 Collections.addAll() 静态方法。这样可以生成允许使用所有方法的普通容器。Collections 类中的“不可修改”的方法将容器包装到一个代理中，只要你执行任何试图修改容器的操作，这个代理都会产生 UnsupportedOperationException 异常。使用这些方法的目标就是“常量”容器对象。 Set 和存储顺序Set 需要一种方式来维护存储顺序，而存储顺序如何维护，则是在 Set 的不同实现之间会有所变化。类型说明Set(interface)存入 Set 的每个元素都必须是唯一的，因为 Set 不保存重复元素，加入 Set 元素必须定义 equals() 方法以确保对象的唯一性。Set 与 Collection 有完全一样的接口。Set 接口不保证维护元素的次序。HashSet为快速查找而设计的 Set。存入 HashSet 的元素必须定义 hashCode()。TreeSet保持次序的 Set，底层为数结构。使用它可以从 Set 中提取有序的序列。元素必须实现 Comparable 接口LinkedHashSet具有 HashSet 的查询速度，且内部使用链表维护元素的顺序（插入次序）。于是可以在迭代器遍历 Set 时，结果会按元素插入的次序显示。元素也必须定义 hashCode() 方法如果没有其他的限制，HashSet 应该是你默认的选择，因为它对速度进行了优化。 SortedSetSortedSet 中的元素可以保证处于排序状态，TreeSet 是其唯一的实现。这使得它可以通过使用接口下列方法提供附加的功能：Comparator comparator() 返回当前 Set 使用的 Comparator，或者返回 null 表示以自然方式排序。Object first() 返回容器中的第一个元素；Object last() 返回容器中的最末的一个元素；SortedSet subSet(fromElement, toElement) 生成此 Set 的子集，范围从 fromElement (包含)到 toElement (不包含)。SortedSet headSet(toElement) 生成此 Set 的子集，由小于 toElement 的元素组成。SortedSet headSet(fromElement) 生成此 Set 的子集，由大于等于 fromElement 的元素组成。 队列除了并发应用，Queue 在Java SE5中仅有的两个实现是 LinkedList 和 PriorityQueue，它们的差异在于排序行为而不是性能。使用队列，你可以将元素从队列的一端插入，并于另一端将它们抽取出来。1234567891011121314151617181920212223242526public class QueueBehavior &#123; private static int count = 10; static &lt;T&gt; void test(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen) &#123; for(int i=0;i&lt;count;i++) &#123; queue.offer(gen.next()); &#125; while(queue.peek() != null) &#123; System.out.println(queue.remove()); &#125; &#125; static class Gen implements Generator&lt;String&gt; &#123; String[] s = &#123;\"one\", \"two\", \"three\", \"four\", \"five\", \"six\"&#125;; int i = 0; public String next() &#123;return s[i++];&#125; &#125; public static void main(String[] args) &#123; test(new LinkedList&lt;String&gt;(), new Gen()); test(new PriorityQueue&lt;String&gt;(), new Gen()); test(new ArrayBlockingQueue&lt;String&gt;(), new Gen()); test(new ConcurrentLinkedQueue&lt;String&gt;(), new Gen()); test(new LinkedBlockingQueue&lt;String&gt;(), new Gen()); test(new PriorityBlockingQueue&lt;String&gt;(), new Gen()); &#125;&#125;优先级的队列的排序顺序是通过实现 Comparable 而进行控制的。双向队列（双端队列）可以在任何一端添加或移除元素。12345678910111213141516171819public class DequeTest &#123; static void fillTest(Deque&lt;Integer&gt; deque) &#123; for(int i=0;i&lt;10;i++) &#123; deque.addFirst(i); &#125; for(int i=10;i&lt;20;i++) &#123; deque.addLast(i); &#125; &#125; public static void main(String[] args) &#123; Deque&lt;Integer&gt; deque = new ArrayDeque&lt;Integer&gt;(); fillTest(deque); while(deque.size() != 0) &#123; System.out.println(deque.removeFirst()); System.out.println(deque.removeLast()); &#125; &#125;&#125; 理解 Map映射表（也称为关联数组）的基本思想是它维护的是 健-值对 关联，因此你可以使用键来查找值。标准的Java类库中包含了 Map 的几种基本实现，包括: HashMap, TreeMap, LinkedHashMap, WeakHashMap, ConcurrentHashMap, IdentityHashMap。它们都有同样的基本接口 Map，但是行为特性各不相同，这表现在效率，键值对的保存及呈现次序，对象的保存周期，映射表如何在多线程程序中工作和判定“键”等价的策略等方面。下面是一个极其简单的实现：123456789101112131415161718192021222324public class AssociativeArray&lt;K, V&gt; &#123; private Object[][] pairs; private int index; public AssociativeArray(int length) &#123; pairs = new Object[length][2]; &#125; public void put(K key, V value) &#123; if(index &gt;= pairs.length) &#123; throw new IndexOutOfBoundsException(); &#125; pairs[index++] = new Object[]&#123;key, value&#125;; &#125; public V get(K key) &#123; for(int i=0;i&lt;index;i++) &#123; if(key.equals(pairs[i][0])) &#123; return (V)pairs[i][1]; &#125; &#125; return null; &#125;&#125;关联数组中的基本方法是 put() 和 get()。为了使用 get() 方法，你需要传递想要查找的 key，然后它会将之相关联的值作为结果返回。或者在找不到的情况下返回 null。在上面实现的 get() 方法中，使用的可能是能想象到的效率最差的方式来定位值：从数组的头部开始，使用 equals() 方法依次比较键。同时，上述实现中由于具有固定的尺寸而显得很不灵活。幸运的是，在 java.util 中的各种 Map 都没有这些问题。 性能性能是映射表中的一个重要问题，当在 get() 中使用线性搜索时，执行速度会相当地曼。而 HashMap 使用了特殊的值，称作 散列码，来取代对键的缓慢搜索。散列码是相对唯一的，用以代表对象的 int 值，它通过将该对象的某些信息进行转换而生成的。hashCode() 是根类 Object 中的方法，因此所有的Java对象都能产生散列码。如果你没有重写 hashCode() 方法，就会继承自 Object ，默认是使用对象的地址计算散列码。HashMap 就是使用对象的 hashCode() 进行快速查询的，此方法能显著提高性能。类型说明HashMap基于散列表的实现。插入和查询键值对的开销是固定的。可以通过构造器设置 容量 和 负载因子，以调整容器的性能。LinkedHashMap类似与 HashMap，但是迭代它时，取得键值对的顺序是其插入次序，或者是 最近最少使用（LRU） 的次序。只比 HashMap 慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序。TreeMap基于红黑树的实现。查看键或键值对时，它们会被排序（次序由 Comparable 或 Comparator 决定）。其特定在于所得到的结果是经过排序的。TreeMap 是唯一的带有 subMap() 方法的 Map，它可以返回一个子树。WeakHashMap弱键（weak key） 映射，允许释放映射所指向的对象。这是为了解决某类特殊问题而设计的。如果映射之外没有引用指向某个键，则此键可以被垃圾收集器回收。ConcurrentHashMap一种线程安全的 Map，它不涉及同步加锁。IdentityHashMap使用 == 代替 equals() 对键进行比较的散列映射，专为解决特殊问题而设计的。一般来说，如果你重写 hashCode() 方法也同时需要重写 equals() 方法，才能正常运行。正确的 equals 方法必须满足下列5个条件：自反性：对任意 x,x.equals(x) 一定返回 true。对称性：对任意 x 和 y，如果 y.equals(x) 返回 true，则 x.equals(y) 也返回 true。传递性：对任意 x, y, z, 如果有 x.equals(y) 返回 true, y.equals(z) 返回 true，则 x.equals(z) 一定返回 true。一致性：对任意 x 和 y,如果对象中用于等价比较的信息没有比较，无论调用多少次 equals() 方法，返回的结果应该保持一致。对任何不是 null 的 x，x.equals(null) 一定返回 false。默认的 Object.equals() 只是比较对象的地址。 散列与散列码首先，使用散列的目的在于：想要使用一个对象来查找另一个对象。散列的价值在于速度：散列使得查询得以快速进行。散列将键保存在某处，以便能够很快找到。存储一组元素最快的数据结构是数组，所以使用它来表示键的信息。但是因为数组不能调整容量。故数组并不保存键本身，而是通过键对象生成一个数字，将其作为数组的下标。这个数字就是 散列码。散列码由定义在 Object 且可能由你的类覆盖的 hashCode() （常称为 散列函数）方法生成。未解决数组容量被固定的问题，不同的键可以产生相同的下标。也就说，可能会有 冲突。于是查询一个值的过程首先就是计算散列码，然后使用散列码查询数组。如果能够保证没有冲突，那可就有了一个完美的散列函数，但是这种情况几乎不可能。通常，冲突由 外部链接 处理：数组并不直接保存值，而是保存值的 list。然后对 list 中的值使用 equals() 方法进行线性的查询。这部分的查询自然会比较慢，但是，如果散列函数好的话，数组的每个位置就只有较少的值。因此，不是查询整个 list，而是快速地跳到数组的某个位置，只对很少的元素进行比较。这就是 HashMap 会如此快的原因。下面实现一个简单的散列 Map：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class MapEntry&lt;K, V&gt; &#123; private K key; private V value; public MapEntry(K key, V value) &#123; this.key = key; this.value = value; &#125; public void set(K key, V value) &#123; this.key = key; this.value = value; &#125; public K getKey() &#123; return (K)key; &#125; public V getValue() &#123; return (V)value; &#125;&#125;public class SimpleHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; &#123; // 选择一个素数作为哈希表的大小以达到均匀分布 static final int SIZE = 997; // 每个槽的桶 LinkedList&lt;MapEntry&lt;K, V&gt;&gt;[] buckets = new LinkedList[SIZE]; public V put(K key, V value) &#123; V oldValue = null; // 根据哈希值计算放到那个桶 int index = Math.abs(key.hashCode()) % SIZE; // 初始化桶链表 if(buckets[index] == null) &#123; buckets[index] = new LinkedList&lt;MapEntry&lt;K, V&gt;&gt;(); &#125; LinkedList&lt;MapEntry&lt;K, V&gt;&gt; bucket = buckets[index]; MapEntry&lt;K, V&gt; pair = new MapEntry&lt;K, V&gt;(key, value); boolean found = false; ListIterator&lt;MapEntry&lt;K, V&gt;&gt; it = bucket.listIterator(); while(it.hasNext()) &#123; MapEntry&lt;K, V&gt; iPair = it.next(); if(iPair.getKey().equals(key)) &#123; oldValue = iPair.getValue(); it.set(pair); // 取代旧的键值对 found = true; break; &#125; &#125; // 如果没有相同的键 if(!found) &#123; buckets[index].add(pair); &#125; return oldValue; &#125; public V get(K key) &#123; int index = Math.abs(key.hashCode()) % SIZE; if(buckets[index] == null) &#123; return null; &#125; for(MapEntry&lt;K, V&gt; iPair : buckets[index]) &#123; if(iPair.getKey().equals(key)) &#123; return iPair.getValue(); &#125; &#125; return null; &#125; public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K, V&gt;&gt; set = new HashSet&lt;Map.Entry&lt;K, V&gt;&gt;(); for(LinkedList&lt;MapEntry&lt;K, V&gt;&gt; bucket: buckets) &#123; if(bucket == null) &#123; continue; &#125; for(MapEntry&lt;K, V&gt; mpair: bucket) &#123; set.add(mpair); &#125; &#125; return set; &#125;&#125;由于散列表中的 槽位（slot） 通常被称为 桶位（bucket），因此我们将实际三列表的数组命名为 bucket。为使得散列分布均匀，桶的数量通常使用质数。注意，为了能够自动处理冲突，使用了一个 LinkedList 的数组，每一个新的元素只是直接添加到 list 末尾的某个特定桶位中。对于 put() 方法，hashCode() 将针对键而被调用，并且其结果被强制转换未正数。为了使产生的数字适合 buckets 数组的大小，取模操作符将按照该数组的尺寸取模。get() 方法按照与 put() 方法相同的方式计算在 buckets 数组中的索引，如果此位置由 LinkedList 存在，就对其进行线性查询。注：事实证明，质数实际上并不是散列桶的理想容量。近来，经过广泛的测试，Java的散列函数都使用2的整数次方。对现代的处理器来说，除法与求余数是最慢的操作。使用2的整数次方长度的散列表，可以用掩码代替除法。因为 get() 方法是使用最多的操作，求余数的 % 操作是其开销最大的部分，而使用2的整数次方可以消除此开销。编写 hashCode() 方法的基本指导原则：给 int 变量 result 赋予某个非零值常量；为对象内每个有意义的域 f （即每个可以做 equals() 操作的域）计算出一个 int 散列值 c；合并计算得到的散列码；返回 result。检查 hashCode() 最后生成的结果，确保相同的对象由相同的散列码。 选择接口的不同实现实际上只有四种容器：Map, List, Set 和 Queue，但是每种接口都有不止一个实现版本。每种不同的实现各自的特征，优点和缺点。Hashtable, Vector 和 Stack 的特征是，它们是过去遗留下来的类，目的只是为了支持老的程序（最好不要在新的程序中使用它们）。容器之间的区别通常归结为由什么在背后支持它们。也就是说，所使用的接口是由什么样的数据结构实现的。例如，ArrayList 和 LinkedList 都实现 List 接口。然而，ArrayList 底层由数组支持，而 LinkedList 是由双向链表实现的。因此，如果要经常在表中插入或删除元素，LinkedList 就比较合适；否则，应该使用速度更快的 ArrayList。再举个例子，Set 可被实现为 TreeSet, HashSet 或 LinkedHashSet。每一种都有不同的行为。HashSet 是最常用的，查询速度最快。LinkedHashSet 保持元素插入的次序；TreeSet 基于 TreeMap，生成一个总是处于排序状态的 Set。你可以根据所需的行为来选择不同的接口实现。有时某个特定容器的不同实现会拥有一些共同的操作，但是这些操作的性能并不相同。在这种情况下，你可以基于使用某个特定操作的频率，以及你需要的执行速度来在它们中间进行选择。对于类似的情况，一种查看容器之间差异的方式是使用性能测试。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"16-数组","slug":"Java编程思想/16-数组","date":"2020-06-21T15:19:04.000Z","updated":"2020-06-21T15:19:28.673Z","comments":true,"path":"Java编程思想/16-数组/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/16-%E6%95%B0%E7%BB%84/","excerpt":"","text":"对数据的基本看法是，你可以创建并组装它们，通过使用整型索引值访问它们的元素，并且它们的尺寸不能改变。 数组为什么特殊数组与其他种类的容器之间的区别有三方面：效率、类型和保存基本类型的能力。在Java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。但是为这种速度所付出的代价是数组对象的大小被固定，并且在其生命周期中不可改变。你可能会建议使用 ArrayList，它可以通过创建一个新的实例，然后把旧实例中所有的引用移到新实例中，从而实现更多空间的自动分配，但是这种弹性需要开销，因此 ArrayList 的效率比数组低很多。数组之所以优于泛型之前的容器，就是因为你可以创建一个数组去持有某种具体类型。这意味着你可以通过编译期检查，来防止插入错误类型和抽取不当类型。数组可以持有基本类型，而泛型之前的容器则不能。但是有了泛型，容器就可以指定并检查它们所持有对象的类型，并且有了自动包装机制，容器看起来还能够持有基本类型。123456789101112131415161718192021222324252627class Element &#123;&#125;public class ContainerComparison &#123; public static void main(String[] args) &#123; // 数组 Element[] elements = new Element[10]; // ArrayList List&lt;Element&gt; elementList = new ArrayList&lt;Element&gt;(); // 添加元素 for(int i=0;i&lt;10;i++) &#123; Element element = new Element(); // 数组添加元素 elements[i] = element; // ArrayList添加元素 elementList.add(element); &#125; // 获取元素 for(int i=0;i&lt;10;i++) &#123; // 数组获取元素 System.out.println(elements[i]); // ArrayList获取元素 System.out.println(elementList.get(i)); &#125; &#125;&#125;这两种持有对象的方式都是类型检查的，并且唯一明显的差异就是数组用 [] 来访问元素，而 List 使用的是 add() 和 get() 这样的方法。 数组是第一级对象无论使用哪种类型的数组，数组标识符其实只是一个引用，指向在堆中创建的一个真实对象，这个（数组）对象用以保存指向其他对象的引用。可以作为数组初始化语法的一部分隐式地创建此对象，或者用 new 表达式显式地创建。只读成员 length 是数组对象的一部分（事实上，这是唯一可以访问的字段或方法），表示此数组对象可以存储多少元素。[] 语法是访问数组对象的唯一的方式。1234// 未初始化数组对象Element[] a;// 分配5个单元Element[] b = new Element[5];数组 a 是一个尚未初始化的变量，在你对它正确地初始化之前，编译期不允许用此引用做任何事情。数组 b 初始化指向一个 Element 引用的数组，但其实并没有将 Element 对象置入数组中。然而，仍然可以询问数组的大小，因为 b 指向一个合法的对象。这样有一个小缺点：你无法知道在此数组中确切有多少元素，因为 length 值表示数组能够容纳多少元素。新生成的一个数组对象时，其中所有的引用被自动初始化为 null，所以检查其中的引用是否为 null，即可知道数组的某个位置是否存有对象。同样，基本类型的数组如果是数值型的，就自动初始化为0；如果是字符型，就自动初始化为 (char)0; 如果是布尔型，就自动初始化为 false。 返回一个数组在Java中，你可以直接返回一个数组，而无需担心要为数组负责：只要你需要它，它就会一直存在，当你使用完后，垃圾回收期会清理掉它。123456789101112131415public class Fruit &#123; private String name; public Fruit(String name) &#123; this.name = name; &#125; // 获得水果数组 public static Fruit[] getFruits() &#123; String[] fruitNames = &#123;\"Apple\", \"Balana\", \"Orange\", \"Watermelon\", \"Mango\"&#125;; Fruit[] fruits = new Fruit[5]; for(int i=0;i&lt;5;i++) &#123; fruits[i] = new Fruit(fruitNames[i]); &#125; &#125;&#125; 多维数组对于基本类型的多维数组，可以通过使用花括号将每个分量分隔开：123456789public class MultidimensionalPrimitiveArray &#123; public static void main(String[] args) &#123; int[][] a = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#125;; System.out.println(Arrays.deepToString(a)); &#125;&#125;每对花括号括起来的集合都会把你带到下一级数组。还可以使用 new 来分配数组，下面的三维数组就是在 new 表达式中分配的：123456public class ThreeDimension &#123; public static void main(String[] args) &#123; int[][][] a = new int[2][2][4]; System.out.println(Arrays.deepToString(a)); &#125;&#125;数组中构成矩阵的每个向量都可以具有任意的长度（这被称为 粗糙数组）：1234567891011121314public class RaggedArray &#123; public staic void main(String[] args) &#123; Random rand = new Random(47); // 任意长度的三维数组 int[][][] a = new int[rand.nextInt(7)][][]; for(int i=0;i&lt;a.length;i++) &#123; a[i] = new int[rand.nextInt(5)][]; for(int j=0;j&lt;a[i].length;j++) &#123; a[i][j] = new int[rand.nextInt(5)]; &#125; &#125; System.out.println(Arrays.deepToString(a)); &#125;&#125; 数组与泛型通常，数组与泛型不能很好地结合。你不能实例化具有参数化类型的数组：12// IllegalPeel&lt;Banana&gt;[] peels = new Peel&lt;Banana&gt;[10];擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全。但是，你可以参数化数组本身的类型：123456789101112131415161718class ClassParameter&lt;T&gt; &#123; public T[] f(T[] arg) &#123;return arg;&#125;&#125;class MethodParameter &#123; public static &lt;T&gt; T[] f(T[] arg) &#123;return arg;&#125;&#125;public class ParameterizedArrayType &#123; public static void main(String[] args) &#123; Integer[] ints = &#123;1, 2, 3, 4, 5, 6&#125;; Double[] doubles = &#123;1.1, 2.2, 3.3, 4.4, 5.5, 6.6&#125;; Integer[] ints2 = new ClassParameter&lt;Integer&gt;().f(ints); Double[] doubles = new ClassParameter&lt;Double&gt;().f(doubles); ints2 = MethodParameter.f(ints); doubles = MethodParameter.f(doubles); &#125;&#125;注意：使用参数化方法而不使用参数化类的方便之处在于：你不必为需要应用的每种不同的类型都使用一个参数去实例化这个类，并且你可以将其定义为静态的。当然，你不能总是选择使用参数化方法而不是参数化类，但是它应该成为首选。 Arrays 实用功能在 java.utils 类库中可以找到 Arrays 类，它有一套用于数组的 static 实用方法，其中有六个基本方法：equals() 用于比较两个数组是否相等（deepEquals() 用于多维数组）；fill() 方法是将同一个值填充数组；sort() 方法用于对数组排序；binarySearch() 用于在已经排序的数组中查找元素；toString() 产生数组字符串表示；hashCode() 产生数组的散列码。所有这些方法对各种基本类型和 Object 类而重载过。此外，Arrays.asList() 接收任意的序列或数组作为其参数，并将其转变为 List 容器。 复制数组Java标准类库提供有 static 方法 System.arraycopy()，用它来复制数组比用 for 循环复制要快很多。System.arraycopy() 针对所有类型做了重载。123456int[] i = new int[7];// 使用47填充数组Arrays.fill(i, 47);int[] j = new int[10];// 复制数组System.arraycopy(i, 0, j, 0, i.length);arraycopy() 需要的参数有：源数组，表示从源数组中的什么位置开始复制的偏移量，表示从目标数组的什么位置开始复制的偏移量，以及需要复制的元素个数。当然，对数组的任何越界操作都会导致异常。如果复制对象数组，那么只是复制了对象的引用–而不是对象本身的拷贝。这被称为 浅复制（shallow copy）。注意：System.arraycopy() 不会执行自动包装和自动拆箱，两个数组必须具有相同的确切类型。 数组的比较Arrays 类提供了重载后的 equals() 方法，用来比较整个数组。同样，此方法针对所有基本类型与 Object 都做了重载。数组相等的条件是元素个数必须相等，并且对应位置的元素也相等，这可以通过对每一个元素使用 equals 作比较来判断。123int[] a1 = new int[10];int[] a2 = new int[10];System.out.println(Arrays.equals(a1, a2)); 数组元素的比较排序必须根据对象的实际类型执行比较操作。一种自然的解决方案是为每种不同的类型各编写一个不同的排序方法，但是这样的代码难以被新的类型所复用。程序设计的基本目标是：将保持不变的事物与发生改变的事物相分离。而这里，不变的是通用的排序算法，变化的是各种对象相互比较的方式。因此，使用 策略设计模式，可以将会发生变化的代码封装在单独的类中（策略对象）。Java有两种方式来提供比较功能。第一种是实现 java.lang.Comparable 接口，使你的类具有天生的比较能力。此接口简单，只有 compareTo() 一个方法。此方法接收另一个 Object 为参数，如果当前对象小于参数则返回负值，如果相等则返回零，如果当前对象大于参数则返回正值。123456789public class CompType implements COmparable&lt;CompType&gt; &#123; int i; public CompType(int n1) &#123; i = n1; &#125; public int compareTo(CompType rv) &#123; return (i &lt; rv.i ? -1 : (i == rv.i ? 0 : 1)); &#125;&#125; 在已排序的数组中查找如果数组已经排好序，就可以使用 Arrays.binarySearch() 执行快速查找。如果要对未排序的数组使用 binarySearch()，那么将产生不可预料的结果。123456789101112131415161718public class ArraySearching &#123; public static void main(String[] args) &#123; Random random = new Random(47); int[] a = new int[10]; for(int i=0;i&lt;10;i++) &#123; a[i] = rand.nextInt(100); &#125; System.out.println(Arrays.toString(a)); // 对数组排序 Arrays.sort(a); System.out.println(Arrays.toString(a)); // 寻找数字 61 int location = Arrays.binarySearch(a, 61); if(location &gt;= 0) &#123; System.out.println(\"Location: \", location); &#125; &#125;&#125;","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"15-泛型","slug":"Java编程思想/15-泛型","date":"2020-06-21T15:18:16.000Z","updated":"2020-06-21T15:19:30.470Z","comments":true,"path":"Java编程思想/15-泛型/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/15-%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。在面向对象编程语言中，多态算是一种泛化机制。但是，考虑到除了 final 类不能扩展，其他任何类都可以被扩展，所以这种灵活性大多数时候也会有一些性能损耗。泛型实现了 参数化类型 的概念，使得代码可以应用于多种类型。 简单泛型引入泛型机制的一个最重要的原因就是，为了创造容器类。容器就是存放要使用对象的地方。与简单的数组相比，容器类更加灵活，具备更多不同的功能。有些情况下，我们确实希望容器能够同时持有多种类型的对象。但是，通常而言，我们只会使用容器来存储一种类型的对象。泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。因此，相比使用 Object，我们更喜欢暂时不指定类型，而是稍后再决定具体使用什么类型。要达到这个目的，需要使用类型参数，用尖括号括住，放在类名后面。然后在使用这个类的时候，再用实际的类型替换此类型参数。在下面的代码中， T 就是类型参数(实际上，大写的26个字母都可以作为类型参数)：123456789101112131415161718public class Holder&lt;T&gt; &#123; private T a; public Holder(T a) &#123; this.a = a; &#125; // 设置持有的对象 public void set(T a) &#123;this.a = a;&#125; // 获取持有的对象 public T get() &#123;return a;&#125; // 测试例子 public static void main(String[] args) &#123; Holder&lt;Apple&gt; holder = new Holder(new Apple(\"apple1\")); System.out.println(holder.get()); holder.set(new Apple(\"apple2\")); System.out.println(holder.get()); &#125;&#125;这就是Java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节。 一个元组类库仅仅一次方法调用就能返回多个对象，这是经常需要的功能。可是 return 语句只允许返回单个对象。因此，解决的方法就是创建一个对象，用它来持有想要返回的多个对象。使用泛型，我们就能够一次性解决这个问题。同时，可以在编译期确保类型安全。这个概念称为 元组（tuple），它是将一组对象直接打包存储于其中的一个单一对象。这个容器对象允许读取其中元素，但是不允许向其中存放新的元素。这个概念也被称为 数据传送对象 或 信使。通常，元组可以具有任意长度。同时，元组中的对象可以是任意不同的类型。不过我们希望能够为每一个对象指明其类型，并且从容器中读取出来时，能够得到正确的类型。下面的代码是一个2维元组，它能够持有两个对象：1234567891011public class TwoTuple&lt;A, B&gt; &#123; public final A first; public final B second; public TwoTuple(A a, B b) &#123; this.first = a; this.second = b; &#125; public String toString() &#123; return \"(\" + first + \", \" + second + \")\"; &#125;&#125; 一个堆栈类下面来实现自己的内部链式存储机制：123456789101112131415161718192021222324252627282930313233343536373839404142public class LinkedStack&lt;T&gt; &#123; // 内部的节点类 private static class Node&lt;U&gt; &#123; // 节点元素 U item; // 下一个节点 Node&lt;U&gt; next; // 无参构造器 Node() &#123;item = null; next = null;&#125; // 全参构造器 Node(U item, Node&lt;U&gt; next) &#123; this.item = item; this.next = next; &#125; boolean end() &#123;return item == null &amp;&amp; next == null&#125;; &#125; // 栈顶节点，末端哨兵（end sentinel） private Node&lt;T&gt; top = new NOde&lt;T&gt;(); // 入栈 public void push(T item) &#123; top = new Node&lt;T&gt;(item, top); &#125; // 出栈 public T pop() &#123; T result = top.item; if(!top.end()) top = top.next; return result; &#125; // 测试例子 public static void main(String[] args) &#123; LinkedStack&lt;String&gt; lss = new LinkedStack&lt;String&gt;(); for(String s: \"Phaser or stun\".split(\" \")) &#123; lss.push(s); &#125; String s; while((s = lss.pop()) != null) &#123; System.out.println(s); &#125; &#125;&#125;这个例子使用了一个 末端哨兵（end sentinel） 来判断堆栈何时为空。其实这就是数据结构里面链表的前插法。 泛型接口泛型也可以应用于接口。例如 生成器（generator），这是一种专门负责创建对象的类。实际上，这是 工厂方法设计模式 的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。也就是说，生成器无需额外的信息就知道如何创建新对象。一般而言，一个生成器只定义一个方法，该方法用以产生新的对象。在这里，就是 next() 方法。1234567891011121314151617181920public interface Generator&lt;T&gt; &#123; T next();&#125;public class Fibonacci implements Generator&lt;Integer&gt; &#123; private int counter = 0; private int f1 = 1; private int f2 = 1; private int f3 = 0; public Integer next() &#123; if (counter++ &lt; 2) &#123; return 1; &#125; f3 = f1 + f2; f1 = f2; f2 = f3; return f3; &#125;&#125; 泛型方法可以在类中包含参数化方法，而这个方法所在的类可以是泛型类，也可以不是泛型类。泛型方法使得方法能够独立于类而产生变化。基本的指导原则是：无论何时，只要你能做到，你就应该尽量使用泛型方法。也就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法。要定义泛型方法，只需将泛型参数列表置于返回值之前：12345public class GenericMehods &#123; public &lt;T&gt; void f(T x) &#123; System.out.println(x.getClass() .getName()); &#125;&#125;注意：当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型。这称为 类型参数推断(type argument inference)。 擦除的神秘之处请尝试运行下面的代码：12345678public static void main(String[] args) &#123; Class class1 = new ArrayList&lt;Integer&gt;().getClass(); Class class2 = new ArrayList&lt;String&gt;().getClass(); System.out.println(class1 == class2); /* * output: true */&#125;ArrayList&lt;String&gt; 和 ArrayList&lt;Integer&gt; 很容易被认为是不同的类型。但是上面的程序会认为它们是相同的类型。在泛型代码内部，无法获得任何有关泛型参数类型的信息。因此，你可以知道诸如类型参数标识符和泛型类型边界这类的信息(通过 Class.getTypeParameters() 方法),却无法知道用来创建某个特例的实际的类型参数。Java泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此 ArrayList&lt;String&gt; 和 ArrayList&lt;Integer&gt; 在运行时事实上是相同的类型，这两种形式都被擦除成它们的原生类型 ``ArrayList`。泛型参数将擦除到它的第一个边界（它可能有多个边界）。编译器实际上会把类型参数替换为它的擦除。如果泛型在Java 1.0中就已经存在，那么这个特性就不会使用擦除来实现。它将使用具体化，使类型参数保持为第一类实体，因此你能够在类型参数上执行基于类型的语言操作和反射操作。在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型。泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如，诸如 List&lt;T&gt; 这样的类型注解将被擦除为 List，而普通的类型变量在未指定边界的情况下将被擦除为 Object。擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这常被称为 “迁移兼容性”。因此擦除的主要正当理由是从非泛化代码到泛化代码的转变过程中，以及在不破坏现有的类库的情况下，将泛型融入Java语言。擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作之中，例如转型，instanceof 和 new 表达式。因为所有关于参数的类型信息都丢失了。因为擦除在方法体中移除了类型信息，所以在运行时的问题就是 边界：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。在泛型中的所有动作都发生在边界处：对传递进来的值进行额外的编译期检查，并插入对传递除去的值的转型。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"14-类型信息","slug":"Java编程思想/14-类型信息","date":"2020-06-16T16:16:35.000Z","updated":"2020-06-16T16:16:50.425Z","comments":true,"path":"Java编程思想/14-类型信息/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/14-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/","excerpt":"","text":"运行时类型信息使得你可以在程序运行时发现和使用类型信息。Java主要有两种方式让我们在运行时识别对象和类的信息：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型；另一种是反射机制，它允许我们在运行时发现和使用类的信息。 Class 对象Class 对象包含了与类有关的信息，是用来创建类的所有的“常规”对象的。Java使用 Class 对象来执行其 RTTI，即使你正在执行的是类似转型这样的操作。类是程序的一部分，每个类都有一个 Class 对象。换言之，每当编写并且编译了一个新类，就会产生一个 Class 对象（更恰当地说，是被保存在一个同名的 .class 文件中）。为了生成这个类的对象，运行这个程序的Java虚拟机（JVM）将使用被称为类加载器的子系统。类加载器子系统实际上可以包含一条类加载链，但是只有一个原生类加载器，它是JVM实现的一部分。原生类加载器加载的是所谓的可信类，包括Java API类，它们通常是从本底盘加载的。在这条链，通常不需要添加额外的类加载器，但是如果你有特殊的需求，如从网络中下载类等，那么你有一种方式可以挂接额外的类加载器。所有的类都是在对其第一次使用时，动态加载到JVM中。当程序创建第一个对类的静态成员的引用时，就会加载这个类。这个证明构造器也是类的静态方法，即使在构造器之前并没有使用 static 关键字。因此使用 new 操作符创建类的新对象也会被当作对类的静态成员的引用。因此，Java程序在它开始运行之前并非被完全加载，其各个部分是在必须时才加载的。类加载器首先检查这个类的 class 对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找 .class 文件。在这个类的字节码被加载时，它们会接收验证，以确保其没有被破坏，并且不包含不良Java代码。一旦某各类的 Class 对象被载入内存，它就被用来创建这个类的所有对象。Class 对象和其他对象一样，可以获取并操作它的引用。其静态方法 forName() 是取得 Class 对象的引用的一种方法。它是用一个包含目标类的全限定名（注意拼写和大小写）的 String 作输入参数，返回的是一个 Class 对象的引用。如果 Class.forName() 找不到你要加载的类，会抛出异常 ClassNotFoundException。1Class cls = Class.forName(\"cn.hengxin.Test\");无论何时，只要你想在运行时候使用类型信息，就必须首先获得对恰当的 Class 对象的引用。Class.forName() 就是实现此功能的便捷途径，因为你不需要为了获得 Class 引用而持有该类型的对象。但是如果你已经拥有该类型对象，那就可以通过调用 getClass() 方法来获取 Class 引用，这个方法继承与基类 Object。12Apple apple = new Apple();Class cls = apple.getClass();如果你有一个 Class 对象，可以使用 getSuperclass() 方法查询其直接基类，这将返回你可以用来进一步查询的 Class 对象。因此你可以在运行时发现一个对象完整的类继承结构。也可以使用 printInfo(), getName(), getSimpleName(), getCanonicalName() 等方法获取类的信息或者名字（不包含包名的类名和全限定的类名）。当然，也可以使用 getInterfaces() 方法查询其所包含的接口。Class 的 newINstance() 方法是实现“虚拟构造器”的一种途径。虚拟构造器允许你声明：我不知道你的确切类型，但是无论如何要正确地创建自己。使用 newInstance() 来创建的类，必须带有默认的构造器。 类字面常量Java还提供了另一种方法来生成对 Class 对象的引用，即使用 类字面常量。1Apple.class;这样做不仅更简单而且更安全，因为它在编译时就会受到检查。并且它根除了对 forName() 方法的调用，所以也更高效。类字面量不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型。另外对于基本数据类型的包装器类，还有一个标准字段 TYPE。TYPE 字段是引用，指向对应的基本数据类型的 Class 对象。建议使用 .class 的形式，以保持与普通类的一致性。注意：当使用 .class 来创建对 Class 对象引用时，不会自动地初始化该 Class 对象。为了使用类而做的准备工作实际包含三个步骤：加载：由类加载器执行，该步骤将查找字节码（通常在classpath所指定的路径中查找），并从这些字节码中创建一个 Class 对象。链接：在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用。初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。初始化被延迟到了对静态方法（构造器隐式是静态的）或者非常数静态域进行首次引用时才执行。初始化有效地实现了尽可能的惰性，可以有效减少启动时的资源。Java SE5 允许你对 Class 引用指向的 Class 对象的类型进行限定而实现，这里用到了泛型语法。1Class&lt;Integer&gt; intClass = int.class; 泛化的 Class 引用通过使用泛型语法，可以让编译器强制执行额外的类型检查。为了在使用泛化的 Class 引用时放松限制，可以使用通配符，它是Java泛型的一部分。通配符使用 ?，表示任何事物。1Class&lt;?&gt; intClass = int.class;在Java SE5中，Class&lt;?&gt; 优于平凡的 Class，即便它们是等价的。为了创建一个 Class 引用，它被限定为某种类型，或该类型的任何子类型，可以将通配符和 extends 关键字相结合，创建一个范围。1Class&lt;? extends Number&gt; bounded = int.class;向 Class 引用添加泛型语法的原因仅仅是为了提供编译期类型检查，如果你操作有误，你马上就会发现。 使用 cast() 进行转型Java SE5还添加了用于 Class 引用的转型语法，即 cast() 方法：123Building b = new House();Class&lt;House&gt; houseClass = House.class;House h = houseClass.cast(b);cast() 方法接受参数对象，并将其转型为 Class 引用的类型。 类型转换前先做检查RTTI在Java中还有第三种形式，就是关键字 instanceof。它返回一个布尔值，告诉我们对象是不是某个特定类型的实例：123if(animal instanceof Dog) &#123; Dog dog = (Dog)animal;&#125;当然，你也可以使用 Class 对象的 isInstance() 方法进行检查：123if(Dog.class.isInstance(animal)) &#123; Dog dog = (Dog)animal;&#125; 反射：运行时的类信息如果不知道某个对象的确切类型，RTTI可以告诉你。但是有一个限制：这个类型在编译时必须已知，这样才能使用RTTI识别它，并利用这些信息做一些事。人们想要在运行时获取类的信息的一个动机是，希望提供在跨网络的远程平台上创建和运行对象的能力。这被称为 远程方法调用（RMI）,它允许一个Java程序将对象分布到多台机器上。Class 类与 java.lang.reflect 类库一起对反射的概念进行了支持，该类库包含了 Field, Mehod 以及 Constructor 类（每个类都实现了 Member 接口）。这些类型的对象是由JVM在运行时候创建的，用以表示未知类里对应的成员。这样你就可以使用 Constructor 创建新的对象，用 get() 和 set() 方法读取和修改与 Field 对象关联的字段，用 invoke() 方法调用与 Method 对象关联的方法。另外，还可以调用 getFields(), getMethods(), getCOnstructors() 等很便利的方法，以返回表示字段，方法以及构造器的对象数组。这样，匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。123Class&lt;Animal&gt; cls = Class.forName(\"cn.hengxin.Anmial\");Method[] methods = cls.getMethods();Constructor[] constructors = cls.getConstructors();Method 和 COnstructor 这两个类都提供了深层方法，用以解析其对象所代表的方法，并获取其名字，输入参数以及返回值。 动态代理代理是基本的设计模式之一它是你为了提供额外的或不同的操作，而插入的用来代替“实际”对象的对象。这些操作通常涉及与“实际”对象的通信，因此代理通常充当着中间人的角色。下面展示静态代理的代码：12345678910111213141516class Animal &#123; public void doSomething() &#123; // ... &#125;&#125;class AnimalProxy &#123; private Animal animal; public AnimalProxy(Animal animal) &#123; this.animal = animal; &#125; public void doSomething() &#123; animal.doSomething(); &#125;&#125;Java的 动态代理 比静态代理的思想更向前迈进了一部，因为它可以动态地创建代理并动态地处理对所代理方法的调用。在动态代理上所作的所有调用都会被重定向到单一的调用处理器上。123456789101112131415161718192021222324252627282930class DynamicProxyHandler implements InvocationHandler &#123; // 被代理的对象 private Object proxied; public DynamicProxyHandler(Object proxied) &#123; System.out.println(\"dynamic proxy!\"); this.proxied = proxied; &#125; // 调用方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(proxied, args); &#125;&#125;class SImpleDynamicProxy &#123; public static void consumer(Interface iface) &#123; iface.doSOmething(); &#125; public static void main(String[] args) &#123; RealObject real = new RealObject(); consumer(real); Interface proxy = (Interface)Proxy.newProxyInstance( real.getClass().getClassLoader(), real.getClass.getInterfaces(), new DynamicProxyHandler(real)); consumer(real); &#125;&#125;通过调用静态方法 Proxy.newProxyInstance() 可以创建动态代理，这个方法需要得到一个类加载器，一个你希望该代理实现的接口列表（不是类或抽象类），以及 InvocationHandler 接口的一个实现。动态代理可以将所有调用重定向到调用处理器，因此通常会向调用处理器的构造器传递给一个实际对象的引用，从而使得调用处理器在执行其中介人物时候，可以将请求转发。invoke() 方法中传递进来了代理对象，以防你需要区分请求的资源。但是在许多情况下，你并不关心这一点。注意：从上面的代码可以发现，Java原生支持的动态代理仅能代理实现于于某个接口的对象，而若你的对象并未实现任何接口是不能进行动态代理的。这个时候需要使用到第三方包：CGLib。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"13-字符串","slug":"Java编程思想/13-字符串","date":"2020-06-15T16:40:26.000Z","updated":"2020-06-15T16:40:49.467Z","comments":true,"path":"Java编程思想/13-字符串/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/13-%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串操作是计算机程序中最常见的行为。 不可变 StringString 对象是不可变的。String 类中每一个看起来会修改其值的方法，实际上都是创建了一个全新的 String 对象以及包含修改后的字符串内容。而最初的 String 对象丝毫未动。 重载 “+” 与 StringBuilderString 对象是不可变的，你可以给一个 String 对象加任意多的别名。因为 String 对象具有只读特性，所以指向它的任何引用都不可能改变它的值。不可变会带来一定的效率问题。为 String 对象重载的 “+” 操作符就是一个例子。重载的意思是，一个操作符在应用于特定的类时，被赋予了特殊的意义（用于 String 的 “+” 和 “+=” 是Java中仅有的两个重载过的操作符，而Java不允许程序员重载任何操作符）。1String s = \"I love\" + \"Java\";上面的代码为了生成最终的字符串 s，可能会产生一大堆需要垃圾回收的中间对象。因为，建议你在进行字符串拼接操作时候使用 StringBuilder 对象：12345StringBuilder sb = new StringBuilder();sb.append(\"I \");sb.append(\"love \");sb.append(\"Java!\");System.out.println(sb.toString());StringBuilder 提供了丰富而全面的方法，包括 insert(), replace(), substring(), reverse()。但是最常用的还是 append() 和 toString() 方法，还有 delete() 方法。StringBuilder 是Java SE5引入的，在这之前Java用的是 StringBuffer。后者是线程安全的，因此开销也会大些。 String 的常用方法方法参数，重载版本应用构造器重载版本：默认版本,String,StringBuilder,StringBuffer,char数组,byte数组创建 String 对象length()字符的个数chatAt()Int 索引取得该索引位置上的字符getChars(), getBytes()要复制部分的起点和终点的索引，复制的目标数组，目标数组的起始索引复制 char 或 byte 到一个目标数组中toCharArray()生成一个 char[],包含所有字符串equals(), equalsIgnoreCase()与之比较的字符串比较字符串内容是否相同。后者忽略大小写。compareTo()与之比较的字符串按词典顺序比较字符串内容，比较内容为负数、零或整数。注意，大小写不等价contains()要搜索的 CharSequence如果包含参数内容，则返回 truestartsWith()字符串返回 boolean 结果，以表明是否以参数起始endsWith字符串返回 boolean 结果，以表明是否以参数结尾indexOf(),lastIndexOf()重载版本：char，char与起始索引，String，String与起始索引如果字符串不包含此参数就返回-1，否则返回参数在字符串中起始所以。lastIndexOf()是从后向前搜索substring()重载版本：起始索引；起始索引+终点索引返回指定索引的新的字符串concat()要连接的字符串返回原始字符串连接上参数的新的字符串replace()要替换掉的字符，用来进行替换的新字符返回替换字符后的新的字符串对象toLowerCase(),toUpperCase()将字符串大小写改变后返回一个新的字符串。如果没有改变发生，则返回原始的字符串对象trim()将字符串两端的空白字符删除。如果没有改变发生，则返回原始字符串对象valueOf()重载版本：Object；char[];char[],偏移量，字符个数；boolean；char；int；long；float；double返回一个表示参数内容的子字符串当需要改变字符串内容时，String 类的方法都会返回一个新的 String 对象。同时，如果内容没有发生改变，只是返回原始对象的引用而已。这可以节约存储空间以及避免额外的开销。 格式化输出 System.out.format()Java SE5 引入的 format() 方法可用于 PrintStream 或 PrintWriter对象，其中也包括 System.out 对象。format() 方法模仿自C的 printf()。123int x = 5;double y = 5.322;System.out.format(\"int %d;double %f\\n\", x, y);以百分号开头的占位符称为格式修饰符，它们不但说明了插入数据的位置，同时还说明了将插入什么类型的变量。 Formatter 类在Java中，所有新的格式化功能都由 java.util.Formatter 类处理。可以将 Formatter 看作一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。12Formatter f = new Formatter(System.out);f.format(\"%s at (%d, %d)\", \"Turtle\", 3, 4); Formatter转换下面表格包含了最常用的类型转换：类型转换符对应的类型%d整数型（十进制）%cUnicode字符%bBoolean值%s字符串%f浮点数（十进制）%e浮点数（科学计数）%x整数（十六进制）%h散列码（十六进制）%%字符百分号“%” 正则表达式正则表达式是一种强大而灵活的文本处理工具。使用正则表达式，我们能够以编程的方式，构造复杂的文本模式，并对输入的字符串进行搜索。一旦找到匹配这些模式的部分，你就能随心所欲地对它们进行处理。正则表达式提供了一种完全通用的方式，能够解决各种字符串相关的问题：匹配，选择，编辑以及验证。 基础对字符进行匹配：字符意义B指定字符B\\xhh十六进制值为0xhh的字符\\t制表符\\n换行符\\r回车\\f换页\\e转义（Escape）对字符类进行匹配：字符意义.任意字符[abc]包含a、b和c的任何字符[^abc]除了a、b和c之外的任何字符（否定）[a-z]从a到z的任何字符（范围）\\s空白字符（空格，tab，换行，换页和回车）\\S非空白字符 [^\\s]\\d数字 [0-9]\\D非数字 [^0-9]\\w词字符 [0-9a-zA-Z]\\W非词字符 [^\\w]逻辑操作符：逻辑操作符意义XYY跟在X后面XY(X)捕获组(capturing group)。可以在表达式中用\\i引用第i个捕获组边界匹配符：边界匹配符意义^一行的起始$一行的结束\\b词的边界\\B非词的边界\\G前一个匹配的结束 量词贪婪型：量词总是贪婪的。如果它是贪婪的，那么它就会继续往下匹配。勉强型：用问号来指定，这个量词匹配满足模式所需的最少字符数。因此也被称为懒惰的，非贪婪的。占有型：目前这种类型的量词只有Java语言中才可用。当正则表达式被应用于字符串时，它会产生相当多的状态，以便在匹配失败时可以回溯。而占有量词并不会保存这些中间状态，因此它可以防止回溯，常用于防止正则表达式失控，因为可以使正则表达式执行起来更有效。贪婪型勉强型占有型如何匹配X?X??X?+一个或零个XX*X*?X*+零个或多个XX+X+?X++一个或多个XX{n}X{n}?X{n}+恰好n个XX{n,}X{n,}?X{n,}+至少n个XX{n,m}X{n,m}?X{n,m}+X至少n次，且不超过m次 Pattern 和 Matcher一般来说，比起功能有限的 String 类，我们更愿意构造功能强大的正则表达式对象。只需要导入 java.util.regex 包，然后用 static Pattern.compile() 方法编译正则表达式即可。它会根据你传入的字符串类型的正则表达式生成一个 Pattern 对象。接下来，把你想要检索的字符串传入 Pattern 对象的 matcher() 方法。该方法会生成一个 Matcher() 对象。12345Pattern pattern = Pattern.compile(\"abcabcabcefgabc\");Matcher matcher = pattern.matcher(\"abc\");while(matcher.find())&#123; System.out.println(\"Match \\\"\" + matcher.group() + \"\\\"\" + \" at positions \" + m.start() + \"-\" + (m.end() - 1));&#125;","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"12-异常","slug":"Java编程思想/12-异常","date":"2020-06-15T16:38:07.000Z","updated":"2020-06-15T16:40:09.436Z","comments":true,"path":"Java编程思想/12-异常/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/12-%E5%BC%82%E5%B8%B8/","excerpt":"","text":"Java 的基本理念是“结构不佳的代码不能运行”。发现错误的理想时机是编译阶段，然而编译期间不能找出所有的错误，余下的问题必须在运行期间解决。这就需要错误源能通过某种方式，把适当的信息传递给某个接收者–该接收者将知道如何正确处理这个问题。 概念C以及其他早期语言常常具有多种错误处理模式，这些模式往往建立在约定俗成的基础之外，而并不属于语言的一部分。通常会返回某个特殊值或者设置某个标志，并且假定接收者将对这个返回值或者标志进行检查，以判定是否发生了错误。但是如果每次调用方法的时候都彻底进行错误检查，代码很可能变得难以阅读。解决的办法是，用强制规定的形式来消除错误处理过程中随心所欲的因素。C++ 的异常处理机制基于Ada，Java中的异常处理机制则建立在C++基础之上。使用异常明显的好处是，它往往能降低错误处理代码的复杂度。使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能 捕捉 这个错误。并且，只需要在一个地方处理错误，即所谓的 异常处理程序 中。异常机制使代码、编写和调试工作更加井井有条。 基本异常异常情形（exceptional condition） 是指阻止当前方法或作用域继续执行的问题。普通问题指在当前环境下能够得到足够的信息，总能处理这个错误。而对于异常情形，就不能继续辖区了，因为在当前环境下无法获得必要的信息，只能将问题交给上一级环境。如果你正在处理一个意料之外的值，你也不清楚该如何处理，那就要抛出异常，而不是顺着原来的路径继续执行下去。当抛出异常后，同Java中其他对象的创建一样，将使用 new 在堆上创建异常对象。然后，当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序。这个恰当的地方就是 异常处理程序，它的人物是将程序从错误状态中恢复。123if(t == null) &#123; throw new NullPointException();&#125;异常使得我们可以将每件事都当作一个事务考虑，而异常可以看护着这些事务的底线。 异常参数所有标准异常类都有两个构造器：一个是默认构造器；另一个是接收一个字符串作为参数，以便把相关信息放入异常对象的构造器。1throw new NullPointException(\"t=null\");在使用 new 创建异常对象后，此对象的引用交付给了关键字 throw。尽管返回的异常对象其类型通常与方法设计的返回类型不同，但从效果上看，它就是从方法“返回”的。故可以简单地把异常处理看成一种不同的返回机制。此外，可以在方法内抛出人一类型的 Throwable 对象，它是异常类型的根类。通常，对于不同类型的错误，要抛出相应的异常。错误信息可以保存在异常对象的内部或者仅用异常类的名称来暗示。 捕捉异常**监控区域（guard region）**是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。 try 块如果在方法内抛出了异常（或者调用的其他方法抛出了异常），这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕捉异常。它是跟在 try 关键字之后的普通程序块：123try &#123; // code that might generate exceptions&#125; 异常处理程序当然，抛出的异常必须在某处得到处理，这个地点就是 异常处理程序。而且针对每个要捕捉的异常，得准备相应的处理程序。异常处理程序紧跟在 try 块之后，以关键字 catch 表示：1234567try &#123; // code that might generate exceptions&#125; catch(Exception1 e1) &#123; // handle exception of Exception1&#125; catch(Exception2 e2) &#123; // handle exception of Exception2&#125;每个 catch 子句（异常处理程序）看起来就像是接收一个且仅接收一个特殊类型的参数的方法。可以在处理程序的内部使用参数获取异常信息。异常处理程序必须紧跟 try 块之后。当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序，然后进入的 catch 子句执行。此时认为异常得到了处理。注意：在 try 块内部许多不同的方法调用可能会产生类型相同的异常，而你只需要提供一个针对此类型的异常处理程序。 终止与恢复异常处理理论上有两种基本模型。Java支持 终止模型，在这种模型中，将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行。另一种称为 恢复模型，意思是异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。 创建自定义异常要定义异常类，必须从已有的异常类继承，最好选择意思相近的异常类继承（不好找）。1class SimpleExcepton extends Exception &#123;&#125; 异常说明Java鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员。异常说明使用了附加的关键字 throws，后面接一个所有潜在异常类型的列表，所有方法定义可能看起来像这样：123void f() throws SimpleException, DivZeroException &#123; // ... &#125;代码必须与异常说明保持一致。如果方法里的代码产生了异常却没有进行处理，编译器会发现这个问题并提醒你：要么处理这个异常，要么就在异常说明中表明此方法会产生异常。 捕捉所有异常可以制鞋一个异常处理程序来捕捉所有类型的异常：通过捕捉异常类型的基类 Exception。123catch(Exception e) &#123; System.out.println(\"Caught an exception!\");&#125;这将捕捉所有异常，所以最好把它放在处理程序列表的末尾，以防它抢在其他处理程序之前先把异常捕获了。Exception 是所有异常类的基类，所以它不会含有太多具体的信息，不过可以调用它从其基类 Throwable 继承的方法：12345678String getMessage(); // 获取详细信息String getLocalizedMessage(); // 本地语言表示的详细信息// 打印调用栈轨迹void printStackTrace(); // 输出到标准错误void printStackTrace(PrintStream); // 选择要输出的流void printStackTrace(java.io.PrintWriter);// 在 Throwable 对象内部记录栈帧的当前状态Throwable fillInStackTrace(); 栈轨迹printStackTrace() 方法所提供的信息可以通过 getStackTrace() 方法来直接访问，这个方法返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一帧。元素0是栈顶元素，并且是调用序列中最后一个方法调用。12345catch(Exception e) &#123; for(StackTraceElement ste: e.getStackTrack()) &#123; System.out.println(ste.getMethodName()); &#125;&#125; 重新抛出异常有时希望把刚捕获的异常重新抛出，尤其是在使用 Exception 捕获所有异常的时候。123catch(Exception e) &#123; throw e;&#125; 异常链常常会想要在捕捉一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。在JDK1.4之后，所有 Throwable 的子类在构造器中都可以接受一个 cause (因由)对象作为参数。这个 cause 就用来表示原始异常，这样也就能通过这个异常链追踪到异常最初发生的位置。在 Throwabe 的子类中，只有三种基本的异常类提供了带 cause 参数的构造器，它们是 Error(用于Java虚拟机报告系统错误),Exception 以及 RuntimeException。如果要把其他类型的异常链接起来，应该使用 initCause() 方法而不是构造器。 Java标准异常Throwable 这个Java类被用来表示任何可以作为异常被抛出的类。Trowable 对象可以分为两种类型：Error 用来表示编译时和系统错误；Exception 是可以抛出的基本类型，这也是Java程序员关心的类型。异常的基本概念是用名称代表发生的问题，并且异常的名称应该是可以望文知意。 使用 finally 进行清理对于一些代码，可能会希望无论 try 块中的异常是否抛出，他们都能得到执行。为了达到这个效果，可以在异常处理程序后面加上 finally 子句。完整的异常处理程序看起来像这样：1234567try &#123; // the guarded region&#125; cathc(E1 e1) &#123; // handle Exception of E1&#125; finally &#123; // Activities that happen every time&#125;无论异常是否被抛出，finally 子句总能被执行。当要把除内存之外的资源恢复到它们的初始状态时，就要用到 finally 子句。如：已经打开的文件或网络连接，在屏幕上画的图形或者是外部世界的某个开关。 异常使用指南在恰当的级别处理问题（在知道该如何处理的情况下才捕捉异常）解决问题并且重新调用产生异常的方法进行少许修补，然后绕过异常发生的地方继续执行用别的数据进行计算，以代替方法预计会返回的值把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层把当前运行环境下能做的事情尽量做完，然后把不同的异常重抛到更高层终止程序进行简化让类库和程序更安全","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"11-持有对象","slug":"Java编程思想/11-持有对象","date":"2020-06-03T10:18:51.000Z","updated":"2020-06-09T13:21:56.415Z","comments":true,"path":"Java编程思想/11-持有对象/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/11-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"通常，程序总是根据运行时才知道的某些条件去创建新的对象，即需要在任意时刻和任意位置创建任意数量的对象。所以不能依靠创建命名的引用来持有每一个对象。Java 有多种方式来保存对象，例如数组。数组是保存一组对象的最有效的方式，如果你想保存一组基本数据类型，也推荐使用这种方式。但是数组具有固定的尺寸，显得过于受限。Java 使用类库提供了一套相当完整的容器类来解决这个问题，其中基本类型是：List, Set, Queue 和 Map。这些对象类型被称为集合类，但由于 Java 的类库使用了 Collection 这个名字来指代该类库的一个特殊子集，所以一般使用范围更广泛的术语 “容器” 来称呼它们。Java 的容器类都可以自动地调整自己的大小，因此你可以将任意数量的对象放置到容器中，并且不需要担心容器应设置为多大。同时，容器还有一些其他的特性，如：Set 对于每个值都只保存一个对象，Map 是允许你将某些对象与其他一些对象关联起来的 关联数组。 ArrayList 容器和泛型最基本最可靠的容器是 ArrayList ，你可以认为它是可以自动扩充自身尺寸的数组。使用 ArrayList 相当简单：创建一个实例，使用 add() 插入对象；然后用 get() 访问对象，这个时候需要使用索引；使用 size() 可以获取当前已经有多少元素添加进来了，从而不会不小心的因索引越界而引发错误。1234567891011// 实例化一个ArrayList容器以装载Apple对象ArrayList apples = new ArrayList()// 添加10个Apple对象for(int i=0;i&lt;10;i++)&#123; apples.add(new Apple())&#125;// 获取每一个Apple对象for(int i=0;i&lt;apples.size();i++)&#123; Apple apple = (Apple)apples.get(i); system.out.println(apple);&#125;上述的例子有一个问题，就是我们没有指定容器应该装载的类型，这个时候默认容器允许装载 Object 对象，这样会让我们获取对象时候十分复杂并且容易导致转型错误。这样时候就可以使用 泛型 来解决这个问题。例如，你可以声明 ArrayList&lt;Apple&gt;， 其中尖括号括起来的是 类型参数 （可以有多个），它指定了这个容器实例可以保存的类型。同时，使用泛型就可以在编译期防止将错误类型的对象放置到容器中。而且，使用泛型之后，我们不再需要进行类型转换的操作即可得到原设定类型的对象。1234567891011// 实例化一个ArrayList容器以装载Apple对象ArrayList&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;()// 添加10个Apple对象for(int i=0;i&lt;10;i++)&#123; apples.add(new Apple())&#125;// 获取每一个Apple对象for(int i=0;i&lt;apples.size();i++)&#123; Apple apple = apples.get(i); system.out.println(apple);&#125;现在，如果你将一个 Orange 对象放置进入 apples 容器中，编译器将会阻止你。通过使用泛型，编译器将会检查你放置到容器中的对象类型，而且在使用容器中的对象时，可以使用更加清晰的语法。 基本概念Java 的容器的用途是保存对象，可以再将其细分为两类：Collection：一个独立元素的序列，这些元素都服从一条或多条的规则。List: 必须按照插入的顺序保存元素，允许重复；Set: 不能有重复的元素，且顺序按照其哈希值进行计算；Queue：按照排队规则来确定对象产生的顺序（先进先出或按优先级等）。Map：一组成对的“键值对”对象，允许你使用键来查找值。也被称为“关联数组”或“字典”。在理想情况下，你编写的大部分代码都是在与这些接口打交道，并且你唯一需要指定所使用的精确类型的地方就是在创建的时候：1List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;();当然，这种方式并非总是很好的，因为某些类具有额外的功能。例如，LinkedList 具有 List 接口中未包含的额外方法，而 TreeMao 中包含 Map 接口中未包含的方法。 添加一组元素在 Arrays 和 Collections 类中有很多实用的方法，可以在一个 Collection 中添加一组元素。Arrays.asList() 方法接收一个数组或是一个用逗号分隔的元素列表（使用可变参数），并将其转换为一个 List 对象。Collections.addAll() 方法接收一个 Collection 对象，以及一个数组或用一个逗号分割的列表，将元素添加到 Collection 中。1234Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3));Integer[] moreInt = &#123;4, 5&#125;;collection.addAll(Arrays.asList(moreInt));Collections.addAll(collection, 6, 7, 8);注意：使用 Arrays.asList() 其底层表示的是数组，因此不能调整尺寸。如果你试图用 add() 或 delete() 方法在这种列表中添加或删除元素，会引发 Unsupported Operation（不支持的操作） 的错误。 ListList 承诺可以将元素维护在特定的序列中。List 接口在 Collection 的基础上添加了大量的方法，使得可以在 List 的中间插入和移除元素。有两种基本类型的 List：ArrayList: 常用于随机访问元素，但在中间插入和移除元素时较慢。LinkedList: 通过代价较低的在中间进行插入和删除操作，提供了优化的顺序访问。但它的特性集较 ArrayList 较大。12345678910111213// 创建一个ArrayList容器List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();// 添加10个元素for(int i=0;i&lt;10;i++)&#123; list.add(i);&#125;// 获取并打印第5个元素Integer fifth = list.get(4);system.out.println(fifth);// 获取子序列（切片）List&lt;Integer&gt; subList = list.subList(1, 4);// 重新设置第一个元素的值为100list.set(0, 100);下面介绍一些常用的 List 的方法:add(): 添加一个元素contains(): 确定某个对象是否在列表中remove(): 移除一个对象indexOf(): 传递一个对象并发现该对象所处位置的索引编号,-1表示未找到它subList(): 从较大的列表中创建处一个片段isEmpty(): 判断列表是否为空列表clear(): 移除所有的元素，与 removeAll() 方法等效toArray(): 转换为一个数组，这是一个重载方法，其无参数版本返回的是 Object 数组 LinkedListLinkedList 与 ArrayList 一样实现了基本的 List 接口，但是它执行某些操作（在中间插入和移除）时比 ArrayList 更高效，但在随机访问操作方面却要逊色一些。LinkedList 还添加了可以使其用作栈、队列或双端队列的方法。下面介绍一些常用的方法：getFirst(), element() 和 peek(): 都返回列表的第一个元素，而不移除它。如果 List 为空，前两个方法抛出 NoSuchElementException，peek() 方法则返回 null。addFirst(), add() 和 addLast()：都是插入元素，第一个方法插入到列表的头部，而后面两个方法插入元素到列表的尾部。removeFirst(), remove() 和 poll: 都是移除并返回列表的头，前两个方法在列表为空时候抛出 NoSuchElementException，而 poll() 方法返回 null。removeLast()：移除并返回列表的最后一个元素。 Stack栈通常指后进先出（LIFO）的容器。LinkedList 具有能够直接实现栈的所有功能的方法，因此可以直接将 LinkedList 作为栈使用。不过有时一个真正的栈更能直观的表示。12345678public class Stack&lt;T&gt; &#123; private LinkedList&lt;T&gt; storage = new LinkedList&lt;T&gt;(); public void push(T v) &#123;storage.addFirst(v);&#125; public T peek() &#123;return storage.getFirst();&#125; public T pop() &#123;return storage.removeFirst();&#125; public boolean isEmpty() &#123;return storage.isEmpty()&#125;; public String toString() &#123;return storage.toString()&#125;;&#125; SetSet 不保存重复的元素。如果你试图将相同对象的多个实例添加到 Set 中，那么它会阻止这种重复的现象。Set 最常被用作是测试归属性，你可以很容易地询问某个对象是否在某个 Set 中。因此，你通常选择一个 HashSet 的实现，它专门对快速查找进行了优化。Set 具有与 Collection 完全一样的接口，因此没有任何额外的功能，只是行为不同。 HashSetHashSet 使用散列的方式进行存储，所以元素在容器内的顺序和你插入的顺序并不太一致，这是出于速度原因的考虑。12345Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();for(int i=0;i&lt;100;i++)&#123; set.add(i);&#125;system.out.println(set); TreeSetTreeSet 将元素存储在红-黑数数据结构中。元素在 TreeSet 中是排序的，按照字典序列进行。12345Set&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;();for(int i=0;i&lt;100;i++)&#123; set.add(i);&#125;system.out.println(set); Map将对象映射到其他对象的能力是一种解决编程问题的杀手锏。Map 具有键和值两个属性，两个属性间一一对应。键在 Map 中是唯一的，但是值是允许重复的。1234567891011121314151617181920212223Random rand = new Random(47);// 初始化一个Map容器Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer&gt;();for(int i=0;i&lt;10;i++) &#123; // 产生一个0-20之间的随机数 int key = rand.nextInt(20); // 根据键获取对应的值，如果不存在该键则会返回null Integer value = map.get(key); // 如果值为空，则置为1,否则自增1 if(value == null) &#123; value = 1; &#125;else&#123; value++; &#125; // 将键-值对放入map容器中 map.put(key, value);&#125;// 打印map容器system.out.println(map);// 打印map容器的键的Setfor(Integer key: map.keySet()) &#123; system.out.println(key);&#125; Queue队列是一个典型的先进先出（FIFO）的容器。即从容器的一端放入事物，从另一端取出，并且事物放入容器的顺序与取出的顺序是相同的。队列常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在并发编程中特别重要。LinkedList 提供方法以支持队列的行为，并且它实现了 Queue 接口，因此可以将 LinkedList 当作 Queue 的一种实现。123456789Queue&lt;Integer&gt; queue = new Queue&lt;Integer&gt;();// offer()方法在允许的情况下将一个元素插入到队尾或者返回falsequeue.offer(1);// 在不移除的情况下返回队头Integer head1 = queue.peek(); // 队列为空时返回nullInteger head2 = queue.element(); // 队列为空时抛出NoSuchElementException// 移除并返回队头Integer head3 = queue.remove(); // 队列为空时抛出NoSuchElementExceptionInteger head4 = queue.poll(); // 队列为空时返回null PriorityQueue队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则。先进先出描述了典型的队列规则，声明的是下一个元素应该是等待时间最长的元素。优先级队列声明下一个弹出元素是最需要的元素（具有最高的优先级）。当你在 PriorityQueue 上调用 offer() 方法插入一个对象时，这个对象会在队列中被排序。默认的排序将使用对象在队列中的自然顺序，但是你可以通过提供自己的 Comparator 来修改这个顺序。PriorityQueue 可以确保当你调用 peek(), poll() 和 remove() 方法时，获取的元素将是队列中优先级最高的元素。 迭代器任何容器类，都必须有某种方式可以插入元素并将它们再次取回。对于 List，add() 是插入元素的方法之一，而 get() 是取出元素的方法之一。迭代器（也是一种设计模式）是一种对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必关系该序列底层的结构。此外，迭代器通常被称为轻量级对象：创建它的代价小。Java 中的 Iterator 只能单向移动：使用 iterator() 方法要求容器返回迭代器，迭代器将准备好序列的第一个元素。使用 next() 方法获取序列的下一个元素。使用 hasNext() 方法检查序列是否还有元素。使用 remove() 方法将迭代器新近返回的元素删除。123456789101112// 创建一个容器并添加10个元素List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();for(int i=0;i&lt;10;i++) &#123; list.add(i);&#125;// 生成容器的迭代器Iterator&lt;Integer&gt; it = list.iterator();// 遍历打印元素while(it.hasNext())&#123; Integer i = it.next(); system.out.println(i);&#125;","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"10-内部类","slug":"Java编程思想/10-内部类","date":"2020-05-30T13:51:09.000Z","updated":"2020-05-31T16:08:13.349Z","comments":true,"path":"Java编程思想/10-内部类/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/10-%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"可以将一个类的定义放在另一个类的定义内部，这就是内部类。内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织起来，并控制位于内部类的可视性。 创建内部类创建内部类的方式如同你想的一样–把类的定义置于外围类的里面：123456789public class Parcell &#123; class Contents &#123; private int i = 1; &#125; class Destination &#123; private String label = \"\" &#125;&#125;如果你想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体的指明这个对象的类型（前提是该内部类非 private）：1OuterClassName.InnerClassName inner = new OuterClassName.InnerClassName(); 链接到外部类内部类似乎只是一种名字隐藏和组织代码的模式，但它还有其他的用途。当生成一个内部类的对象时，此对象与制造它的 外围对象（enclosing object） 之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还具有外围类的所有元素的访问权。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 迭代器接口interface Selector &#123; // 是否已经到尾 boolean end(); // 获取当前的元素 Object current(); // 移动到下一个元素 void next();&#125;public class Sequence &#123; private Object[] items; private int next = 0; public Sequence(int size) &#123; items = new Object[size]; &#125; // 增加一个元素 public void add(Object x) &#123; if(next &lt; items.length)&#123; items[next++] = x; &#125; &#125; // 迭代器 private class SequenceSelector implements Selector &#123; private int i = 0; // 是否已经到尾 public boolean end() &#123; return i == items.length; &#125; // 获取当前的元素 public Object current() &#123; return items[i]; &#125; // 移动到下标到下一个元素 public void next() &#123; if(i &lt; items.length)&#123; i++; &#125; &#125; &#125; // 获取新的迭代器 public Selector selector() &#123; return new SequenceSelector(); &#125; // 运行 public static void main(String[] args) &#123; Sequence sequence = new Sequence(10); for(int i=0;i&lt;10;i++)&#123; sequence.add(i); &#125; Selector selector = sequence.selector(); while(!selector.end()) &#123; system.out.println(selector.current()); selector.next(); &#125; &#125;&#125;所有内部类自动拥有对其外围类所有成员的访问权。这是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部类对象必定秘密捕捉一个指向那个外围对象的引用。然后，当你访问此外围类对象时，就是用该引用来选择外围类的成员。而这，都是编译器在帮助你处理所有的细节。 使用 .this 和 .new如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点 . 和 this。这样产生的引用自动地具有正确的类型。这一点在编译器就被知晓并受到检查，因此没有任何运行时的开销。12345678910// 外部类public class OuterClass &#123; // 内部类 public class InnerClass &#123; // 返回外部类的引用 public OuterClass getOuter() &#123; return OuterClass.this; &#125; &#125;&#125;有时候你可能去创建其他类的某个内部类对象，要实现这个目的，你必须在 new 表达式中提供对其他外部类对象的引用，这时可以使用 .new 语法。12345678910111213// 外部类public class OuterClass &#123; // 内部类 public class InnerClass &#123; &#125; // 测试 public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); // 直接创建内部类 OuterClass.InnerClass inner = outer.new Inner(); &#125;&#125;你必须使用外部类的对象来创建该内部类对象。在拥有外部类对象之前是不可能创建内部类对象的，这是因为内部类对象会暗暗地链接到创建它的外部类对象上。当然，如果你创建的是 嵌套类（静态内部类） ，那么它就不需要对外部类对象的引用。 在方法和作用域内的内部类通常，如果你所读、写的代码包含了内部类，那么它们都是“平凡的”内部类，简单且容易理解。然后，内部类的语法覆盖了大量其他难以理解的技术。例如，可以在一个方法或者任意作用域内定义内部类。这么做有两个理由：实现了某类型的接口，于是可以创建并返回对其的引用；你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但又不希望这个类是公共可用的。在方法的作用域内创建一个完整的类，这被称为局部内部类。1234567891011public class OuterClass &#123; public Destination destination() &#123; class PDestination implements Destination &#123; private String label; private PDestination(String label)&#123;this.label = label;&#125; public String readLabel() &#123;return label;&#125; &#125; return new PDestination(\"to your heart!\"); &#125;&#125; 匿名内部类12345678public class OuterClass &#123; public InnerClass inner() &#123; return new InnerClass() &#123; // 插入一个类的定义 private int i = 1; public int value() &#123;return i;&#125; &#125; &#125;&#125; 嵌套类如果不需要内部对象与外围对象之间有联系，那么可以将内部类声明为 static。这通常被称为 嵌套类。普通的内部类对象隐式地保存了一个引用，指向创建它的外围对象。然后，当内部类是 static 时：要创建嵌套类的对象，不需要其外围类的对象；不能从嵌套类的对象访问非静态的外围类对象。嵌套类与普通的内部类还有一个区别：普通内部类的字段与方法，只能放在类的外部层次上，所有普通的内部类不能有 static 数据和 static 字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西。123456public OuterClass &#123; private static class InnerClass &#123; private int i = 0; public static int value = 11; &#125;&#125; 为什么需要内部类一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。内部类最吸引人的原因是：每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型。 内部类标识符由于每个类都会产生一个 .class 文件，其中包含了如何创建该类型对象的全部信息（此信息产生一个 “meta-class”, 称为 Class 对象）。内部类也必须生成一个 .class 文件以包含它们的 Class 对象信息。这些类文件的命名有严格的规则：外围类的名字$内部类的名字.class。例如产生了以下的类文件：12OuterClass.classOuterClass$InnerClass.class虽然这种格式简单又直接，但它还是很健壮的，足以应对绝大多数情况。因为这是Java标准的命名方式，所以产生的文件自动都是平台无关的。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"09-接口","slug":"Java编程思想/09-接口","date":"2020-05-30T10:55:09.000Z","updated":"2020-05-30T12:11:31.905Z","comments":true,"path":"Java编程思想/09-接口/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/09-%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。 抽象类与抽象方法Java 提供一个叫做 抽象方法 的机制，这种方法是不完整的，仅有声明而没有方法体。1abstract void f();包含抽象方法的类叫做 抽象类。如果一个类中含有抽象方法，该类必须被限定为抽象的，否则编辑器将会给出报错信息。123public abstract class Tutorial &#123; public abstract void abstractMethod();&#125;如果从一个抽象类继承，并想创建该新类的对象，那么必须为基类中所有的抽象方法提供方法定义。如果不这么做，那么导出类便也是抽象类，且编译器将会强制使用 abstract 关键字来限定这个类。抽象类中并不是所有的方法都是抽象的，也可以有具体实现的方法。抽象类和抽象方法十分有用，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算如何使用它们。抽象类还是很有用的重构工具，因为它使得我们可以很容易地将公共方法沿着继承层次结构向上移动。 接口interface 关键字使抽象的概念更向前迈进了一步。abstract 关键字允许人们在类中创建一个或多个没有任何定义的方法。而 interface 这个关键字产生一个完全抽象的类，它根本没有提供任何具体实现。它允许创建者确定方法名，参数列表和返回类型，但是没有任何方法体。接口只提供形式，而未提供任何具体实现。因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。因此，接口被用来建立类与类之间的协议。interface 不仅仅是一个极度抽象的类，它还允许人们创建一个能够被向上转型为多种基型的类型，来实现某种多重继承的特性。而抽象类则不能达到这一点，因为Java是纯单根继承的体系。要想创建一个接口，需要使用 interface 关键字来替代 class 关键字。注意：接口也可以包含域，但是这些域隐式地是 static 和 final 的。同时，接口的方法默认都是 public 的。要让一个类遵循某个特定接口（或者一组接口），需要使用 implements 关键字。1234567891011121314interface Instrument &#123; int VALUE = 5; // static&amp;final void play(); // automatically public void adjust();&#125;class Wind implements Instrument &#123; public void play() &#123; system.out.println(\"wind playing...\"); &#125; public void adjust() &#123; system.out.println(\"wind adjusting...\"); &#125;&#125; 完全解耦只要一个方法操作的是类而非接口，那么你就只能使用这个类及其子类。如果你想要将这个方法应用于不在此继承体系的其他类中，那么是不允许的。接口可以在很大程序上放宽了这种限制。因此，接口使得我们可以编写可复用性更好的代码。1234567891011121314151617181920212223242526272829303132333435// 处理器接口interface Processor &#123; String name(); Object process(Object input);&#125;// 应用器class Apply &#123; public static void process(Processor p, Object input) &#123; system.out.println(\"Using Processor \" + p.name()); system.out.println(p.process(input)); &#125;&#125;// 滤波器适配器：一个处理器的具体实现class FilterAdapter implements Processor &#123; Filter filter; public FilterAdapter(Filter filter)&#123; this.filter = filter; &#125; public String name() &#123; return filter.name(); &#125; public Waveform process(Object input)&#123; return filter.process((Waveform)input); &#125;&#125;class FilterProcessor &#123; public static void main(String[] args)&#123; Waveform w = new Waveform(); Apply.process(new FilterAdapter(new LowPass(1.0)), w); Apply.process(new FilterAdapter(new HighPass(1.0)), w); &#125;&#125;上面的例子中，使用了 适配器模式。适配器中的代码将接收你所拥有的接口，并产生你所需要的接口。你可能还注意到，在 FilterAdapter 中使用了 代理。 Java中的多重继承接口不仅仅是一种更纯粹形式的抽象类，因为接口是根本没有任何实现–即没有任何与接口相关的存储。因此，也无法阻止多个接口的组合。这一点是很有价值的，因为你有时需要去表示“一个 xxx 是一个 aaa 和一个 bbb”。在C++中，组合多个类的接口的行为被称作 多重继承。如果要从一个非接口的类继承，那么只能从一个类去继承。这一点由Java的单根继承体系所决定。但一个类可以实现多个接口，只需要将所有的接口名都置于 implements 关键字之后，并用逗号 , 将它们一一隔开。可以继承任意多个接口，并可以向上转型为每个接口，因为每一个接口都一个独立类型。12345678910111213141516interface Fight &#123; void fight();&#125;interface Swim &#123; void Swim();&#125;public class Hero implements Fight, Swim &#123; public void fight() &#123; system.out.println(\"I can fight!\"); &#125; public void swim() &#123; system.out.println(\"I can swim!\"); &#125;&#125; 通过继承来扩展接口通过继承，可以很容易地在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。1234567891011interface Monster &#123; void menace();&#125;interface Lethal &#123; void kill();&#125;interface Vampire extends Monster, Lethal &#123; void drinkBlood();&#125;在 Vampire 中使用的语法仅仅适用于接口继承。一般情况下，只可以将 extends 关键字用于单一类。 接口适配接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现。在简单的情况下，它的体现形式通常是接收一个接口类型的方法，而该接口的实现与向该方法传递的对象则取决于方法的使用者。因此，接口一种最常见的用法就是 策略设计模式。此时你编写一个执行某些操作的方法，而该方法将接收一个同样是你指定的接口。这使得你的方法更加灵活、通用，并更具复用性。例如，Java SE5 中 Scanner 类的构造器接收的就是一个 Readable 接口。 接口中的域因为你放入接口中的任何域都自动是 static 和 final 的，所在接口就成为了一种很便捷的用来创建常量组的工具。在Java SE5 之前，这是产生枚举类型 enum 的唯一途径。123public interface Color &#123; int RED = 1, BLUE = 2, GREEN = 3;&#125;请注意，Java中标识具有常量初始化值的 static final 时，会使用大写字母的风格（使用下划线分割单词）。接口中的域自动是 public 的。 接口与工厂接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式是 工厂方法 设计模式。这与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象。理论上，我们的代码将完全与接口的实现分离，这也可以使我们可以透明地将某个实现替换成另一个实现。12345678910111213141516171819202122interface Phone &#123; void call() &#123;&#125;;&#125;class Iphone implements Phone &#123; void call() &#123; system.out.println(\"Iphone is calling!\"); &#125;&#125;class Huawei implements Phone &#123; void call() &#123; system.out.println(\"Huawei is calling!\"); &#125;&#125;class PhoneFactory&#123; public void testPhoneCall(Phone phone) &#123; phone.call(); &#125;&#125; 总结确定接口是理想选择，因而应该总是选择接口而不是具体的类。这其实是一种引诱。任何抽象性都应该是应真正的需求而产生的。恰当的原则应该是优先选择类而不是接口。接口是一种重要的工具，但是它们容易被滥用。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"基于URL的权限系统","slug":"web/基于URL的权限系统","date":"2020-05-29T12:59:34.000Z","updated":"2020-05-30T16:17:39.816Z","comments":true,"path":"web/基于URL的权限系统/","link":"","permalink":"https://hengxincheung.github.io/web/%E5%9F%BA%E4%BA%8EURL%E7%9A%84%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"概念1权限管理，一般指根据系统设置的安全规则或者安全策略，用户可以访问而且只能访问自己被授权的资源，不多不少。通俗易懂地总结，权限系统就是谁（什么身份）可以允许对什么内容（资源）执行什么操作（查看、增加、修改、删除等）。最常用的权限系统使用 基于角色的权限访问控制 （Role-Based Access Control，RBAC） 的方式实现。RBAC支持三个著名的安全原则：最小权限原则，责任分离原则和数据抽象原则。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。想要做到从用户到功能的精确控制，要从数据库表结构设计和代码控制同时进行。 表结构 用户表 useridusernamepasswordstautsis_superadmin…用户id用户名密码状态，如冻结、锁定、正常等是否超级管理员其他信息，如创建时间等is_superadmin 字段用以标识是否为超级管理员，即当用户为超级管理员时候，无需配置任何权限都可对任何资源进行任何操作。 角色表 roleidcodenamedescribecreatorcreatedstatus…主键角色编码角色名称角色描述创建者创建时间状态，如禁用、正常等其他信息 用户-角色表 user_roleiduser_idrole_idstatus…主键用户id角色id状态，如正常、禁用等其他信息，如创建时间 资源表 resourceidcodenamedescribeurlactionlevelparent_idis_leaf…主键资源编码资源名称资源描述资源url请求方法资源等级父节点主键是否叶节点其他信息，如资源icon等因为资源表在前端需要展示，所以数据设定为树结构，方便加载和筛选。只有叶节点对应的资源才具有真正的 url 和 action。非叶节点的资源可以认为是功能模块的描述。举个例子，如：12345用户管理 |___账号信息 |___修改基本信息 |___修改密码 |___查看所有人的账号信息说明：权限也是一种资源，可以配置给适当的角色进行管理。 角色-资源表 role_resourceidrole_idresource_idstatus…主键角色id资源id状态，如正常、禁用其他信息，如创建时间等 其他说明 权限不足时首先，前端不应该展示任何无法操作的资源若用户通过某些方式访问了未授权的权限，应当返回 404 页面。 公共资源有一些公共资源，如首页等，是不需要进行授权检查的。这时候，我们只需要一个能灵活配置的授权切入点。如在全局配置了使用基于该URL权限系统的检查器，但可以在局部取消对该资源的检查。这一点，目前主流的框架都能实现。同时应当对公共资源进行限流操作，如同一ip每秒只能请求1次等，可以根据服务器状态进行动态调整。这样可以避免服务器被频繁的请求使得服务器响应缓慢。 登录失败时使用密码登录失败时，应当返回 账号或密码不正确 而不应该返回具体的 账号不存在 或者 密码不正确 的信息。这样可以防止别有用心的人进行撞库搜集用户信息。","categories":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/tags/web/"},{"name":"权限系统","slug":"权限系统","permalink":"https://hengxincheung.github.io/tags/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/"}]},{"title":"一个简单的用户系统设计","slug":"web/一个简单的用户系统设计","date":"2020-05-29T08:18:53.000Z","updated":"2020-05-29T12:48:31.838Z","comments":true,"path":"web/一个简单的用户系统设计/","link":"","permalink":"https://hengxincheung.github.io/web/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"用户系统是最基础的构成之一，但是越是基础越是难以设计。在设计用户系统的时候，首先想到的自建一个用户系统，劳烦用户填写资料进行注册登录。但同时还需要考虑如何兼容第三方平台授权登录等。 登录方式 密码登录账号密码是最常见的一种登录注册设计，适用于普遍场景，鼓励用户用注册方式登录，有利于产品引导用户完善更多的资料，留存自己的用户信息。现在的账号密码登录都会以用户注册填写的用户名、邮箱或手机号代替系统生成的id作为账号。纯账号密码登录是较为早期的设计，例如早期qq和飞信。 验证码登录验证码登录，也叫免密登录。主要分为手机短信验证码和邮箱验证码。适用于用户不登录能够完成大部分行为，只有在某种场景下必须获得用户身份时才需要用户登录，且此时用户的想要完成的行为是被要求登录操作打断的。但繁琐的注册或者登录都有可能导致用户流失，所以这时获取用户身份的方式一定要尽可能便捷。一般来说，这种方式在手机号或邮箱未注册过的时候，会自动为用户创建一个账户。 第三方授权登录第三方授权登陆，适用于对用户资料和权限要求不高快速解约开发成本的产品。建议在应用构建用户系统的前期可以首先接入第三方，快速的实现登录功能。但是若想建设自身关系链还是需要完善自己的用户系统。用户资料实际也属于用户系统等设计的内容。是否要增加此项的判断原则是根据这个产品对用户资料的需求程度决定用户注册时是否要增加资料填写页，资料填写页是强制阻断性的还是可跳过的，必填的资料项有哪些，希望填的有哪些。 表结构 系统用户表 useridusernamepasswordtelephoneemail…用户id用户名密码电话号码邮箱其他信息，如密码盐、状态、创建时间等 用户授权信息表 user_authiduser_idtypeidentifiercredentialexpire_time…主键id用户id登录类型，如手机验证码、邮箱验证码、微信小程序、微博等授权书，如手机号、邮箱、第三方平台的唯一标识等证书，如验证码、第三方的保存token等过期时间,如验证码等需要其他信息，如创建时间、更新时间等 用户资料表 user_profileiduser_idnicknameavatarsexcity…主键id用户id昵称头像性别城市其他信息，如创建时间、修改时间等这里也提供另一种思路，将用户资料表分为两张表，分别是用户资料名和用户资料值，这样可以通过后台自定义去不断扩展需要的用户资料:用户资料名表 user_profile_key：idcodenamedescribeis_fileis_require…主键id资料名编码资料名资料名描述是否文件是否必须其他信息，如创建时间等用户资料值表 user_profile_value：iduser_idprofile_key_idtext_valuefile_value…主键标识用户id资料名id文本值文件值其他信息，如创建时间、更新时间等 登录流程 密码登录用户在页面输入用户名\\邮箱\\手机号和密码，点击登录；后台只需要校验信息是否在用户表中存在，若存在，则返回成功登录的信息。 验证码登录验证码登录主要分为手机验证码和邮箱验证码，两者思路一致，下面以手机验证码为例：用户在页面输入手机号，点击获取验证码按钮；后台校验手机号的合法性，若合法则生成随机数字串并调用短信api向该号码发送短信，同时向用户授权信息表中写入数据（也可以利用缓存增加系统性能）；用户接收到短信后，填写验证码，点击登录按钮；后台在用户授权信息表中校验请求的手机号和验证码是否匹配；若该手机号无绑定的用户(user_id)，则自动创建一个用户进行绑定。注：登录按钮请求的地址可以是同一个，也可以是不同的地址。若是同一个请求地址，可以通过增加 type 字段以区分登录方式，由后台根据 type 字段再进行分发。也可以使用不同的请求地址以区分不同的登录方式。 第三方授权登录进入 Web2.0 时代, 许多平台都开放了第三方登录，如微博、微信等。但这些平台的登录逻辑都大大同小异：客户端调用 api 唤起授权页面；客户端将授权通过返回的信息发送到服务器；服务器将授权信息和在各平台注册获取的 appid 和 secret 发送到各开发平台接口；若服务器能查询到正确的用户信息，即表示验证通过；若返回的用户信息并未在用户授权信息表中存在，则为用户自动创建一个账户，并且将相关信息写入用户授权信息表中。 手机号/邮箱绑定注册的时候，可能会允许用户不填写手机号或邮箱信息。那么，系统需要增加手机号/邮箱绑定的功能。用户在页面输入手机号/邮箱，点击获取验证码按钮；后台校验手机号的/邮箱合法性，若合法则生成随机数字串并向该手机号/邮箱发送验证码，同时向用户授权信息表中写入数据（也可以利用缓存增加系统性能）；用户接收到短信后，填写验证码，点击绑定按钮；后台在用户授权信息表中校验请求的手机号/邮箱和验证码是否匹配；将当前用户的的 user_id 绑定到授权信息表中。想一想：如果该手机号/邮箱之前已经绑定了其他用户如何处理？","categories":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/tags/web/"},{"name":"用户系统","slug":"用户系统","permalink":"https://hengxincheung.github.io/tags/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/"}]},{"title":"08-多态","slug":"Java编程思想/08-多态","date":"2020-05-27T12:56:56.000Z","updated":"2020-05-27T17:56:21.961Z","comments":true,"path":"Java编程思想/08-多态/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/08-%E5%A4%9A%E6%80%81/","excerpt":"","text":"在面向对象的程序设计语言中，多态（也称为动态绑定，后期绑定或者运行时绑定）是继数据抽象和继承之后的第三种基本特征。封装 通过合并特征和行为来创建新的数据类型；实现隐藏 通过将细节 “私有化” 把接口和实现分离开来。多态 的作用则是消除类型之间的耦合关系。 再论向上转型对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。而这种视为其基类型的引用的做法被称为 向上转型。 忘记对象类型为什么所有人都故意忘记对象的类型呢？如果我们只写一个简单的方法，它仅接收基类作为参数，而不是那些特殊的子类，会让我们编写的代码只是与基类打交道，显得简单而优雅。特别是许多时候我们并不关心子类的具体类型，只需要知道传入的参数是这个基类，我们只需要利用它们的共性而不是异性。 转机 方法调用绑定将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定（由编译器和连接程序实现），叫做 前期绑定。这在面向过程语言中是默认的绑定方式，例如C语言。若在运行时候根据对象的类型进行绑定，叫做 后期绑定。如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用正确的方法体。Java中除了 static 和 final 方法之外，其他的方法都是后期绑定。 产生正确的行为一旦知道Java中的所有方法都是通过动态绑定实现多态这个事实之后，我们就可以编写只与其基类打交道的程序代码了。并且这些代码对所有子类都可以正确运行了。或者说，发送消息给某个对象，让该对象去判断做什么事情。 可扩展性假设我们有一个名为 Instrument 的基类。由于有了多态机制，我们可以根据自己的需要对系统添加任意多的新类型，而不需要更改其 tune() 方法。在一个设计良好的OOP程序中，大多数或者所有方法都会遵循 tune() 的模型，而且只与基类接口通信。这样的程序是可扩展的，因为可以从通用的基类继承出新的数据类型，从而添加一些功能。那些操纵基类接口的方法不需要任何改动就可以应用于新类。 构造器和多态通常，构造器不同于其他种类的方法。涉及多态时仍是如此。尽管构造器并不具有多态性（构造方法实际上是 static 方法，只不过这种声明是隐式的）。 构造器的调用顺序基类的构造器总是在子类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使得每个基类的构造器都得到调用。因为构造器具有一项特殊的任务：检查对象是否正确地构造。构造器的执行遵循下列顺序：调用基类构造器。这个步骤会不断反复递归下去。按声明顺序调用成员的初始化方法。调用子类的构造器的主体。 构造器内部的多态方法的行为如果一个构造器的内部调用正在构造的对象的某个动态绑定方法，那会发生什么情况呢？如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖后的定义。然而，这个调用的效果可能相当难以预料，因为被覆盖的方法在对象被完全构造之前会被调用。这可能会造成一些难以发现的隐藏错误。初始化的完整过程是：在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的零。如前所述调用基类构造器。按照声明的顺序调用成员的初始化方法。调用子类的构造器主体。这样做有一个优点，那就是所有东西都至少初始化为了零，这通常也是发现问题的证据。因此，编写构造器有一条有效的准则：用尽可能简答的方法使对象进入正常状态；如果可以，避免调用其他方法。在构造器内唯一能够安全调用的那些方法是基类中的 final 或 private 方法，这些方法不能被覆盖，因此也不会出现不可预知的问题。 协变返回类型Java SE5 中添加了协变返回类型，它表示在子类的被覆盖方法中可以返回基类方法的返回类型的某种子类型。即可以返回原返回类型的子类。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"07-复用类","slug":"Java编程思想/07-复用类","date":"2020-05-27T11:30:44.000Z","updated":"2020-05-27T15:14:38.754Z","comments":true,"path":"Java编程思想/07-复用类/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/07-%E5%A4%8D%E7%94%A8%E7%B1%BB/","excerpt":"","text":"组合：在新的类中产生现有类的对象。继承：按照现有类的类型来创建新类。继承是面向对象设计的基石之一。 组合语法假设你需要某个对象，它要具有多个 String 对象，几个基础类型数据，以及另一个类的对象。1234567891011121314151617181920212223242526class WaterSource&#123; private String s; public WaterSource()&#123; System.out.println(\"WaterSource()\"); &#125; public String toString()&#123; return s; &#125;&#125;public class SprinklerSystem&#123; private String value1, value2; private WaterSource waterSource = new WaterSource(); private int i; private float f; public String toString()&#123; return \"value1 = \" + value1 + \"\\n\" + \"value2 = \" + value2 + \"\\n\" + \"i = \" + i + \"\\n\" + \"f = \" + f + \"\\n\" + \"waterSource = \" + waterSource + \"\\n\" &#125;&#125;如上面的代码所示，我们并没有初始化各个变量。正如前面的章节所提到的，基本类型能够被自动初始化为零。但是对象引用会被初始化为 null。但是，当你尝试打印 SprinklerSystem 对象时，可以在不抛出异常的情况下打印出一个 null 引用，这对于我们调式程序十分方便和有用。你可以认为，是编译器在打印过程中将 null 引用转换为了字符串。 toString() 方法每一个非基本类型的对象都有一个 toString() 方法，而当编译器需要一个 String 而却只有一个对象时，该方法便会被调用。如果你没有重写 toString() 方法，那么将使用继承于 Object 类的 toString() 方法（除非你继承的类中重写了该方法），返回的是 类名@hashcode。 初始化的正确位置如果想初始化引用，可以在代码中的下列位置进行：在定义对象的地方，这意味着它们总能够在构造器被调用之前被初始化。在类的构造器中。在正要使用这些对象之前，这种方式被称为惰性初始化。在生成类对象前不必生成其包含的其他对象，这种方式可以减少额外的负担。 继承语法继承是所有 OOP 语言不可缺少的组成部分。当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承，否则就是隐式地从Java标准根类 Object 进行继承。继承使用一种特殊的语法，这种声明通过在类主体的左边花括号之前，书写关键字 extends 和需要继承的基类而实现。当这么做之后，会自动获得基类中的所有域和方法。123456789class Cleanser&#123; private String s; public void append(String a) &#123;s += a;&#125; public String toString() &#123;return s;&#125;&#125;public class Detergent extends Cleanser&#123; public foam()&#123;system.out.println(\"foam()\");&#125;&#125;由上述的代码所示，类 Detergent 天然就拥有了基类的 Cleanser 的 append() 和 toString() 方法。当然，你也可以通过重写同名的方法以覆盖父类中的方法。如果覆盖了父类中的方法，又想要在子类中的调用基类继承而来的方法，可以使用 super 关键字以实现。如 super.append(&quot;调用父类中的方法&quot;);。 如何继承基类的属性与属性当创建一个子类的对象时，该对象会包含一个基类的子对象。这个子对象与你直接使用基类创建的对象是一样的。二者的区别是，后者来源于外部，而基类的子对象被包装在导出类对象内部。你可以认为这个基类的子对象就是 super。 那么我们不妨猜测继承的工作机制是如下所示：调用方法中的一个属性或方法。在本对象中判断是否具有该属性或方法，若有则执行并返回。否则，在基类子对象中一直向上寻找是否具有该属性或方法，若有则执行并返回。若寻找到根类 Object 中也没有该属性或方法，则抛出属性或方法不存在的异常。 初始化基类对基类子对象的正确初始化是直观重要的，而且仅有一种方法来保证这一点：在构造器中调用基类构造器来执行初始化。如果你没有显式在构造器中的第一行（必须是第一行），Java会自动在子类的构造器中插入对基类构造器的调用。构造过程是从基类“向外”扩散的，所以基类子对象在子类构造器可以访问它之前，就已经完成了初始化。 带参数的构造器如果没有默认的基类构造器，或者想要调用一个带参数的基类构造器，就必须使用关键字 super 显示编写调用基类构造器的语法，并匹配适当的参数列表。123456789class Game&#123; public Game(String name)&#123; system.out.println(\"You are playing \" + name); &#125; &#125;class Chess extends Game&#123; public Chess()&#123;&#125;&#125;如果基类的构造器需要参数列表，而你没有显示调用基类构造器，编译器就会“抱怨”无法找到符合默认构造器形式的构造器。而且，调用调类构造器必须是你在子类构造器中要做的第一件事，否则构造器也会“提醒”你。 名称屏蔽如果 Java 的基类拥有某个已被多次重载的方法名称，那么在子类中重新定义该方法名称并不会屏蔽其在基类中的任何版本。Java SE5 新增了 @Override 注解。它并不是关键字，但是可以把它当作关键字使用。当你想要覆写某个方法时，可以选择添加这个注解。在你不留心重载而不是覆写该方法时，编译器会生成一条错误信息提示你:1method does not override a method from its superclass protected 关键字关键字 protected 指明了：就类用户而言，这是 private 的。但对于任何继承与此类的任何子类或其他任何位于同一个包内的类来说，它却是可以访问的。note：protected 也提供了包内访问权限。尽管可以创建 protected 域，但是最好的方式还是将域保持为 private：你应当一直保留更改底层实现的权力。然后通过 protected 方法来控制类的继承者的访问权限。 向上转型为新类提供方法并不是继承技术最重要的考虑。其最重要的方面是用来表现新类与基类之间的关系。这种关系可以用**“新类是现有类的一种类型”**加以概括。Java 对类型的检查十分严格，接收某种类型的方法同样可以接收另一种类型会显得十分奇怪。除非编译器意识到接收的对象是需要类型的子类。这种将子类引用转换为基类引用的动作，称作向上转型。子类是基类的一个超集，它可能比基类含有更多的方法，但它必须至少具备基类中的方法。在向上转型的过程中，类接口唯一可能发生的事情就是丢失方法。但这种丢失只是在编译层面的，实际上在运行时仍保留着子类所有的方法。但是如果你用正常的方法去调用方法将会引起编译错误。对于这种情况，你可以通过反射去调用，但这种方式不予以推荐。 final 关键字 final 数据一块永恒不变的数据：一个永不改变的编译时常量。一个在运行时被初始化的值，但初始化后不可以改变。对于基本类型，final 使得数值恒定不变；而对于对象引用，final 使得引用恒定不变，即一旦引用被初始化指向一个对象，就无法再把它指向另一个对象。 final 方法使用 final 方法的原因有两个：把方法锁住，以防任何继承类修改它的含义，不会被覆盖；效率。将一个方法指明为 final，就是同意编译器针对该方法的所有调用都转为内嵌调用。但现在并不建议使用 final 进行优化，因为虚拟机变得功能更加强大了。 final 和 private 关键字类中所有的 private 方法都隐式地指定为了 final。由于无法取用 private 方法，所以也无法覆盖它。可以对 private 方法添加 final 修饰词，但并无任何额外的意义。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"随机森林简述","slug":"统计机器学习/随机森林简述","date":"2020-05-26T06:53:11.000Z","updated":"2020-05-27T07:22:46.853Z","comments":true,"path":"统计机器学习/随机森林简述/","link":"","permalink":"https://hengxincheung.github.io/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E7%AE%80%E8%BF%B0/","excerpt":"","text":"摘要摘要：随机森林是一种灵活的、便于使用的统计学习方法，即使在没有超参数调整的情况下，往往也能取得好的结果。随机森林是典型的集成学习例子，采用自举法生成多个样本集并分别进行建模，然后组合多颗决策树的预测并投票得出最终结果。随机森林具有较高的预测准确率，且对异常值和噪声不敏感，不容易出现过拟合，在医学、生物信息等领域有着广泛的应用。关键字：随机森林; 集成学习; 自举; 决策树 1 前言传统的分类模型往往精度不高，且容易出现过拟合问题。而如支持向量机(Support Vector Machine, SVM)、多层神经网络等模型又很少能提供对数据内部关系的观察能力，但这种透明度对于医学决策支持、质量控制等应用领域是至关重要的。因此，很多学者通过聚集多个简单模型来提高预测精度和模型解释性。这种方法被称为集成(ensemble)或分类器组合(classifier combination)，其核心思想在于利用训练数据构建一组基分类模型(base classifier)，然后通过对每个基分类器模型的预测值进行投票（预测值为离散变量）或取平均值（预测值为连续变量）来输出最终的预测值。随机森林（Random Forest，RF）是由Leo Bremian与Adele Cutler于2011年提出的一种以决策树作为弱分类器的集成分类器。传统的CART决策树可以提供对内部关系的观察能力，但对训练集中的小波动十分敏感，而随机森林充分吸收了决策树的优点并最大化消除了其缺点。为了生成随机森林，通常需要生成随机变量来控制组合中的每个决策树的生长。装袋算法（Bagging）是早期组合树方法之一，又称自助聚集（bootstrap aggregating），是一种从训练集随机抽取部分样本来生成决策树的方法。同时，Ho关于随机子空间（Random subspace）方法做了许多研究，该方法通过对特征变量随机选取子集来生成每颗决策树，对随机森林的研究起到巨大的推进。随机森林利用自举法（Bootstrap）方法从原始样本集中进行重采样，进而得到多个样本集，对每个样本集进行决策树建模，然后组合多棵决策树的结果，最后通过投票得出最终的预测结果。大量的理论和研究都证明了随机森林具有很高的预测准确率，且不容易出现过拟合。总结来说，随机森林是一种自然的非线性建模工具，在数据挖掘、生物医学等领域有重大意义和广泛应用。 2 随机森林相关概念介绍 2.1 自举法 2.1.1 自举法简介自举法是一种通过抽取多个样本集来估计抽样分布的方法，这些样本集中包含单个随机样本的替换内容。这些重复样本被称为重新采样的样本。每个重新采样的样本集的数量小于等于原始样本的数量。自举法是非参数统计中一种重要的估计统计量，并可进行统计量区间估计的统计方法。并且，自举法还可以用来进行假设检验。 2.1.2 自举法的基本思想自举法的基本思想如下:从原始样本集中随机抽取一个样本，将其副本放入新的样本集中，并将该样本放回到原始样本集中；重复采样mmm次，即可得到一个新的样本集。其中次数mmm一般要小于原始样本集的数目nnn;重复上述步骤kkk次，即可得到kkk个新的样本集，计算这kkk个样本集的统计量。 2.1.3 自举法的代码实现123456789101112131415161718192021222324252627import randomimport numpy as npfrom sklearn import datasets# 加载iris数据集iris = datasets.load_iris()iris = np.hstack((iris.data, iris.target.reshape(-1, 1)))# 定义新的样本集的列表samples_list = []# 生成10个新的样本集for k in range(10): # 定义新的样本集 samples = [] # 新的样本集中采样100个样本 for m in range(100): # 获得一个随机下标 idx = random.randint(0, iris.shape[0]-1) # 得到一个样本 sample = iris[idx, :].reshape(1, -1) # 添加进入新的样本集中 samples.append(sample) samples = np.array(samples) print(f\"样本集[&#123;k&#125;]的维度是:&#123;samples.shape&#125;\") # 将新的样本集添加到列表中 samples_list.append(samples)samples_list = np.array(samples_list) 2.2 集成分类器以多个弱分类器组合成的分类器通常被称为集成分类器(Ensemble Classifier)。常见的集成分类器包括 Boosting和Bootstrap aggregation（简称Bagging）。 2.2.1 BoostingBoosting通常的做法是迭代地重复调用弱分类器学习算法构造一系列弱分类器，然后将它们以加权的方式联合起来形成一个强分类器。迭代是Boosting方法的显著特征。Boosting的基本流程如下：（1）在首轮调用弱学习算法时，以均匀分布从训练样本全集中抽取一个训练样本子集，并在此子集上学习生成弱分类器；（2）以后每轮对选取此轮样本子集时对前一轮训练失败的样本给以更大的分布权值，使其在这一轮训练中出现的概率增加，使后续的弱分类器集中对比较难训练的样本进行学习，最后在此子集上学习生成弱分类器；（3）迭代若干次后会得到一系列弱分类器，每个都有一个对应的权值，其权值大小根据该分类器的效果而定。最后的分类器由生成的多个分类器加权联合产生。 2.2.2 BaggingBagging是Leo Breiman在1996年提出的通过组合随机生成的训练集而改进分类的集成算法。与Boosting的迭代做法不同，Bagging以独立同分布选取的训练样本子集训练弱分类器，作为其组成元素的各个弱分类器之间也是平权的。许多研究都指出神经网络、CART 树和线性回归中的子集选择都是不稳定的，而Bagging可以正常处理不稳定情形。Bagging通过将独立同分布的弱分类器通过平均集成起来，可以在使偏差保持基本不变的同时降低方差以及弱分类器之间相关值的平均。这样，如果独立同分布的弱分类器的相关值和偏差都较小，则总的分类误差可以降低。实践和理论双方面都表明，Bagging可以将一个好的但不稳定的过程向着最优化的方向椎动一大步，它可以相对性的降低对稳定性的要求。 2.3 决策树 2.3.1 决策树简介决策树(decision tree)是一类常见的机器学习方法。一般地，一颗决策树包含一个根节点、若干个内部节点和若个叶子节点，其中叶子节点对应于决策结果，其他每个节点则对应于一个属性测试。每个节点包含的样本集合根据属性测试的结果被划分到子节点中。根节点包含整个样本集，从根节点到每个叶子节点的路径对应了一个判定测试序列。决策树学习的目的是为了产生一棵泛化能力强，即处理未见示例能力强的决策树。决策树学习算法主要由三部分构成：（1）特征选择；（2）决策树生成；（3）决策树剪枝。决策树学习算法最著名的代表是ID3、C45和CART。这些算法主要区别在于分类节点上特征选取的标准不同。常用的划分标准包括信息增益、增益率、基尼指数等。此外学者们还设计了许多其他的准则，然而实验表明划分标准只对决策树的尺寸有较大影响，但对泛化能力的影响有限。 2.3.2 决策树的基本思想决策树是一种基本的分类与回归方法，它可以看作是一系列if-then规则的集合，也可以认为是定义在特征空间与类空间的条件概率分布。决策树的根节点到叶节点的每一条路径构建一条规则，路径内部节点的特征对应着规则的条件，叶子节点的类则对应着规则的结论。决策树的生成流程遵循简单且直观的“分而治之”（divide-and-conquer）策略：生成一个树节点nodenodenode；如果样本集中的样本全属于同一个类别CCC，将树节点nodenodenode标记为CCC类叶子节点，返回该树节点；如果属性集AAA为空集或者样本在属性集AAA上取值相同，将树节点nodenodenode标记为样本集DDD中最多的类，返回该树节点成；从属性集AAA中选取最优划分属性a∗a_*a∗​;遍历最优划分属性a∗a_*a∗​中的每一个值a∗va_{*}^{v}a∗v​，为树节点nodenodenode生成一个分支，在样本集DDD中选出在a∗a_*a∗​上取值为a∗va_{*}^{v}a∗v​的样本子集DvD_vDv​。如果DvD_vDv​为空，则将分支节点标记为叶节点，其类别标记为DDD中最多的类，返回该树节点；否则，以(Dv,A∖a∗)(D_v, A \\setminus a_*)(Dv​,A∖a∗​)作为分支节点，重复上述步骤。显然，决策树的关键在于如何选择最优划分属性。一般而言，随着划分过程不断进行，决策树的分支节点所包含的样本尽可能都属于同一类别，即节点的“纯度”（purity）越来越高。 2.3.3 决策树的优缺点决策树的优点:易于理解和解释，甚至比线性回归更直观；与人类做决策思考的思维习惯相吻合；模型可以通过树的形式进行可视化展示；可以直接处理非数值型数据，不需要进行哑变量的转化，甚至可以直接处理含缺失值的数据。决策树的缺点：对于有大量数值型输入和输出的问题，决策树未必是一个好的选择；当数值型变量之间存在许多错综复杂的关系，模型不能很好的处理；模型鲁棒性差，某一个节点的小小变化都可能导致整棵树发生变化。 2.3.4 决策树的代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245import mathdef divide_on_feature(X, feature_i, threshold): \"\"\" 基于特征索引上的样本值是否大于给定的阈值进行分割\"\"\" split_func = None if isinstance(threshold, int) or isinstance(threshold, float): split_func = lambda sample: sample[feature_i] &gt;= threshold else: split_func = lambda sample: sample[feature_i] == threshold X_1 = np.array([sample for sample in X if split_func(sample)]) X_2 = np.array([sample for sample in X if not split_func(sample)]) return np.array([X_1, X_2])def calculate_entropy(y): \"\"\" 计算熵 \"\"\" log2 = lambda x: math.log(x) / math.log(2) unique_labels = np.unique(y) entropy = 0 for label in unique_labels: count = len(y[y == label]) p = count / len(y) entropy += -p * log2(p) return entropydef accuracy_score(y_true, y_pred): \"\"\" 计算精度\"\"\" accuracy = np.sum(y_true == y_pred, axis=0) / len(y_true) return accuracyclass DecisionNode(): \"\"\"决策树节点\"\"\" def __init__(self, feature_i=None, threshold=None, value=None, true_branch=None, false_branch=None): self.feature_i = feature_i # 特征索引 self.threshold = threshold # 特征的阈值 self.value = value # 叶子节点的值 self.true_branch = true_branch # 子树 self.false_branch = false_branch # 子树class DecisionTree(object): \"\"\"决策树\"\"\" def __init__(self, min_samples_split=2, min_impurity=1e-7, max_depth=float(\"inf\"), loss=None): self.root = None # 根节点 # 调整拆分的最小样本数 self.min_samples_split = min_samples_split # 调整拆分的最小不纯度 self.min_impurity = min_impurity # 树生长的最大深度 self.max_depth = max_depth # 切割树的方法，gini，方差等 self._impurity_calculation = None # 树节点取值的方法，分类树：选取出现最多次数的值，回归树：取所有值的平均值 self._leaf_value_calculation = None # 标签是不是one-hot编码 self.one_dim = None self.loss = loss def fit(self, X, y, loss=None): \"\"\" 训练决策树 \"\"\" self.one_dim = len(np.shape(y)) == 1 self.root = self._build_tree(X, y) self.loss = None def _build_tree(self, X, y, current_depth=0): \"\"\" 递归地构建决策树\"\"\" largest_impurity = 0 best_criteria = None # 特征索引和与之 best_sets = None # 数据集的子集 # 检查y是否扩展 if len(np.shape(y)) == 1: y = np.expand_dims(y, axis=1) # 把y加到X的最后一列上 Xy = np.concatenate((X, y), axis=1) n_samples, n_features = np.shape(X) if n_samples &gt;= self.min_samples_split and current_depth &lt;= self.max_depth: # 计算每个特征的不纯度 for feature_i in range(n_features): # 特征i的所有值 feature_values = np.expand_dims(X[:, feature_i], axis=1) unique_values = np.unique(feature_values) # 遍历特征列i的所有唯一值并计算不纯度 for threshold in unique_values: # 根据索引特征i处X的特征值是否满足阈值来划分X和y Xy1, Xy2 = divide_on_feature(Xy, feature_i, threshold) if len(Xy1) &gt; 0 and len(Xy2) &gt; 0: # 选择两个集合的y值 y1 = Xy1[:, n_features:] y2 = Xy2[:, n_features:] # 计算不纯度 impurity = self._impurity_calculation(y, y1, y2) # 如果此阈值导致比先前记录的信息增益更高，则保存阈值和特征索引 if impurity &gt; largest_impurity: largest_impurity = impurity best_criteria = &#123;\"feature_i\": feature_i, \"threshold\": threshold&#125; best_sets = &#123; \"leftX\": Xy1[:, :n_features], \"lefty\": Xy1[:, n_features:], \"rightX\": Xy2[:, :n_features], \"righty\": Xy2[:, n_features:], &#125; if largest_impurity &gt; self.min_impurity: # 为左右分支建立子树 true_branch = self._build_tree(best_sets[\"leftX\"], best_sets[\"lefty\"], current_depth + 1) false_branch = self._build_tree(best_sets[\"rightX\"], best_sets[\"righty\"], current_depth + 1) return DecisionNode(feature_i=best_criteria[\"feature_i\"], threshold=best_criteria[ \"threshold\"], true_branch=true_branch, false_branch=false_branch) # 我们在leaf=&gt;确定价值 leaf_value = self._leaf_value_calculation(y) return DecisionNode(value=leaf_value) def predict_value(self, x, tree=None): \"\"\" 递归搜索得到的叶子节点的值\"\"\" if tree is None: tree = self.root # 如果我们有一个值（即在叶子节点上）=&gt;返回值作为预测 if tree.value is not None: return tree.value # 选择要测试的特征 feature_value = x[tree.feature_i] # 确定是跟随左分支还是跟随右分支 branch = tree.false_branch if isinstance(feature_value, int) or isinstance(feature_value, float): if feature_value &gt;= tree.threshold: branch = tree.true_branch elif feature_value == tree.threshold: branch = tree.true_branch # 测试子树 return self.predict_value(x, branch) def predict(self, X): \"\"\" 预测单个样本 \"\"\" y_pred = [] for x in X: y_pred.append(self.predict_value(x)) return y_pred def print_tree(self, tree=None, indent=\" \"): \"\"\" 可视化决策树 \"\"\" if not tree: tree = self.root # 如果是叶子节点，打印 if tree.value is not None: print(tree.value) # 往深处寻找 else: print(\"%s:%s? \" % (tree.feature_i, tree.threshold)) print(\"%sT-&gt;\" % (indent), end=\"\") self.print_tree(tree.true_branch, indent + indent) print(\"%sF-&gt;\" % (indent), end=\"\") self.print_tree(tree.false_branch, indent + indent)class ClassificationTree(DecisionTree): \"\"\"分类树\"\"\" def _calculate_information_gain(self, y, y1, y2): # 切割树的标准，这里使用的是交叉熵 p = len(y1) / len(y) entropy = calculate_entropy(y) info_gain = entropy - p * \\ calculate_entropy(y1) - (1 - p) * \\ calculate_entropy(y2) # print(\"info_gain：\", info_gain) return info_gain def _majority_vote(self, y): # 计算子节点值的方法，这里使用的是选取数据集中出现最多的种类 most_common = None max_count = 0 for label in np.unique(y): # Count number of occurences of samples with label count = len(y[y == label]) if count &gt; max_count: most_common = label max_count = count # print(\"most_common :\", most_common) return most_common def fit(self, X, y): # 将分类树切割的标准与计算子节点值的方式传回给基类DecisionTree self._impurity_calculation = self._calculate_information_gain self._leaf_value_calculation = self._majority_vote super(ClassificationTree, self).fit(X, y)class RegressionTree(DecisionTree): def _calculate_variance_reduction(self, y, y1, y2): # 切割树的标准，这里使用的是平方残差 var_tot = calculate_variance(y) var_1 = calculate_variance(y1) var_2 = calculate_variance(y2) frac_1 = len(y1) / len(y) frac_2 = len(y2) / len(y) # 计算方差减少量 variance_reduction = var_tot - (frac_1 * var_1 + frac_2 * var_2) return sum(variance_reduction) def _mean_of_y(self, y): # 计算子节点值的方法，这里使用的是取数据集中的平均值 value = np.mean(y, axis=0) return value if len(value) &gt; 1 else value[0] def fit(self, X, y): # 将回归树切割的标准与计算子节点值的方式传回给基类DecisionTree self._impurity_calculation = self._calculate_variance_reduction self._leaf_value_calculation = self._mean_of_y super(RegressionTree, self).fit(X, y)# 测试代码from sklearn import datasetsfrom sklearn.model_selection import train_test_splitimport numpy as npimport matplotlib.pyplot as plt# 加载iris数据集data = datasets.load_iris()X = data.datay = data.target# 切割训练集和测试集X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4)# 实例化分类树clf = ClassificationTree()clf.fit(X_train, y_train)y_pred = clf.predict(X_test)accuracy = accuracy_score(y_test, y_pred)print (\"Accuracy:\", accuracy) 3 随机森林 3.1 随机森林的定义随机森林是一个由kkk个树状分类器h(x,θk),k=1,2,...h(x, \\theta_k), k=1,2,...h(x,θk​),k=1,2,...组成的分类器，且每棵树为输入变量xxx归属于哪个类投出平等的一票。这里的θk\\theta_kθk​是独立同分布的随机向量，它通过在独立同分布的bootstrap集上学习而被独立同分布地确定。在预测的时候，被θk\\theta_kθk​确定的第kkk棵树被用来对输入向量xxx做预测。 3.2 抗过拟合性质设有一个包括若干未知参数的模型和为便于拟合该模型提供的数据集，拟合过程可以简要定义为通过优化模型参数使得模型尽量与训练数据拟合。如果用一个从训练数据相同群落中独立的抽取验证数据，总会发现模型不能像拟合训练数据一样好的拟合验证数据，这被称为过拟合。通常过拟合的程度可以以泛化误差来表现。在随机森林的定义基础上，这里假设训练集{(x,y)}\\{(x,y)\\}{(x,y)}是由随机向量XXX和YYY分布所抽取出来的，那么可以定义边际函数为：mg(X,Y)=avkI(hk=y)−maxj≠yavkI(hk(x)=j)mg(X, Y) = av_kI(h_k=y) - max_{j \\ne y}av_kI(h_k(x)=j)mg(X,Y)=avk​I(hk​=y)−maxj​=y​avk​I(hk​(x)=j)其中，函数I(∙)I(\\bullet)I(∙)表示示性函数，avk(∙)av_k(\\bullet)avk​(∙)表示取平均。这里的边际函数表示在XXX和YYY分布下正确投票数的平均数超出错误投票平均数的值。这个值越大则分类正确的信息越大。这样，泛化误差可以如下式表示：PE=Px,y(mg(X,Y)&lt;0)PE = P_{x,y}(mg(X,Y)&lt;0)PE=Px,y​(mg(X,Y)&lt;0)其中XXX和YYY下标表示此泛化误差是在随机变量XXX和YYY分布下取得的。应用大数定理，随着树的数目的增加，对于所有树参数序列θ1,θ2,...\\theta_1, \\theta_2, ...θ1​,θ2​,...，泛化误差PEPEPE几乎处处收敛于:PX,Y(Pθ(h(X,θ))=y)=y−maxj≠YPθ(h(x,θ)=j)&lt;0)P_{X,Y}(P_\\theta(h(X,\\theta))=y) = y-max_{j \\ne Y}P_\\theta(h(x, \\theta)=j)&lt;0)PX,Y​(Pθ​(h(X,θ))=y)=y−maxj​=Y​Pθ​(h(x,θ)=j)&lt;0) 3.3 随机森林的优缺点优点：可以同时处理离散型和连续型特征，可以用于解决分类和回归问题；通过平均决策树的方式，降低了过拟合的风险性，具有抗过拟合的能力；具有极强的稳定性，只有在半数以上的基分类器出现差错时才会做出错误的预测；能够有效地运行在大型数据集上，且能直接处理高维数据而不需要降维；在生成过程中，能够获取到内部生成误差的一种无偏估计。缺点：在解决回归问题时，不能够做出超越训练集数据范围的预测，这可能导致在某些特定噪声的数据进行建模时出现过度拟合；可能有很多相似的决策树，掩盖了真实的结果；对于小数据或者低维数据（特征较少的数据），可能不能产生很好的分类；计算成本高。 3.4 随机森林的现状在随机森林提出后，有不少学者针对它进行改进和优化。Rodriguez等人提出用旋转森林取代随机森林。为了创建旋转森林的LLL个基本分类器中的一个，特征集被随机的分成KKK个子集，在每个子集上抽取一个bootstrapbootstrapbootstrap样本集，然后施以主分量变换。所有的主分量被用作分类器训练。他们的结果表示旋转森林比随机森林更准确。需要指出的是这里的“旋转”指的是特征空间上的广义的旋转，而与图像中的旋转没有任何联系。Osman通过增量式的特征选择改进随机森林而提出了在线随机森林。与其它在线学习方法相似，特点在于其学习是随着训练数据的逐步增加而趋于完善，实验表明其表现随着数据的加入逼近离线随机森林，在所有数据全部获取的情况下达到离线随机森林的水平。随机森林的一个另重要发展是语义纹元森林（Semantic Texton Forest, STF）。纹元森林方法首先将局部的小图块聚类，然后将它们组织成有层次的纹元树，最后用这些树对新的图块做分类。与经典的随机森林的最大差别在于它利用像素样本邻域上下文的信息。这通常是以扩展分割函数运算来实现的，纹元森林的分割函数不仅可以是基于本训练样本特征向量，还可以是其邻域内两个样本特征向量之间的运算。这一重要的扩展将纹理信息、邻域信息也考虑在内，大大增强了决策树对信息的分辨力。 3.5 随机森林的代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class RandomForest(): \"\"\"随机森林 ----------- n_estimators: int 树的数量 max_features: int 每棵树选用数据集中的最大的特征数 min_samples_split: int 每棵树中最小的分割数，比如 min_samples_split = 2表示树切到还剩下两个数据集时就停止 min_gain: float 每棵树切到小于min_gain后停止 max_depth: int 每棵树的最大层数 \"\"\" def __init__(self, n_estimators=100, min_samples_split=2, min_gain=0, max_depth=float(\"inf\"), max_features=None): self.n_estimators = n_estimators self.min_samples_split = min_samples_split self.min_gain = min_gain self.max_depth = max_depth self.max_features = max_features self.trees = [] # 建立森林(bulid forest) for _ in range(self.n_estimators): tree = ClassificationTree(min_samples_split=self.min_samples_split, min_impurity=self.min_gain, max_depth=self.max_depth) self.trees.append(tree) def fit(self, X, Y): # 训练，每棵树使用随机的数据集(bootstrap)和随机的特征 # every tree use random data set(bootstrap) and random feature sub_sets = self.get_bootstrap_data(X, Y) n_features = X.shape[1] if self.max_features == None: self.max_features = int(np.sqrt(n_features)) for i in range(self.n_estimators): # 生成随机的特征 # get random feature sub_X, sub_Y = sub_sets[i] idx = np.random.choice(n_features, self.max_features, replace=True) sub_X = sub_X[:, idx] self.trees[i].fit(sub_X, sub_Y) self.trees[i].feature_indices = idx print(\"tree\", i, \"fit complete\") def predict(self, X): y_preds = [] for i in range(self.n_estimators): idx = self.trees[i].feature_indices sub_X = X[:, idx] y_pre = self.trees[i].predict(sub_X) y_preds.append(y_pre) y_preds = np.array(y_preds).T y_pred = [] for y_p in y_preds: # np.bincount()可以统计每个索引出现的次数 # np.argmax()可以返回数组中最大值的索引 # cheak np.bincount() and np.argmax() in numpy Docs y_pred.append(np.bincount(y_p.astype('int')).argmax()) return y_pred def get_bootstrap_data(self, X, Y): # 通过bootstrap的方式获得n_estimators组数据 # get int(n_estimators) datas by bootstrap m = X.shape[0] Y = Y.reshape(m, 1) # 合并X和Y，方便bootstrap (conbine X and Y) X_Y = np.hstack((X, Y)) np.random.shuffle(X_Y) data_sets = [] for _ in range(self.n_estimators): idm = np.random.choice(m, m, replace=True) bootstrap_X_Y = X_Y[idm, :] bootstrap_X = bootstrap_X_Y[:, :-1] bootstrap_Y = bootstrap_X_Y[:, -1:] data_sets.append([bootstrap_X, bootstrap_Y]) return data_sets # 测试代码import numpy as npfrom sklearn import datasets# 加载digits数据集data = datasets.load_digits()X = data.datay = data.target# 切割训练集和测试集X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4, seed=2)print(\"X_train.shape:\", X_train.shape)print(\"Y_train.shape:\", y_train.shape)# 实例化随机森林clf = RandomForest(n_estimators=100)# 训练clf.fit(X_train, y_train)y_pred = clf.predict(X_test)accuracy = accuracy_score(y_test, y_pred)print(\"Accuracy:\", accuracy) 4 对比实验 4.1 实验结果为了相对公正地对比各模型地差别，采用sklearn库中的模型进行实验，同时所有的模型都采用默认的参数设置。数据集使用sklearn生成线性可分、环形形状、月亮形状三种不同数据分布数据集。模型平均精度线性可分精度环形形状精度月亮形状精度KNN0.90670.970.800.95Linear SVM0.75671.000.420.85RBF SVM90.670.970.820.93Decision Tree0.8333970.750.78RandomForest-100.89330.930.820.93RandomForest-250.90000.950.820.93RandomForest-500.90000.970.800.97RandomForest-1000.90670.970.820.93AdaBoost0.87670.950.780.90Navie Bayes0.87331.000.800.82从实验结果可看出，随机森林模型在三种不同数据分布的数据集上都保持有较高的精度。同时，与其他模型相比较，随机森林模型的精度毫不逊色。而且，随机森林模型在三种数据集上的精度比单一的决策树都提升了很多。但是，可以看出，随机森林模型随着内部基分类器（决策树）数目的增加，其精度并不会有较大的提高。 4.2 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.colors import ListedColormapfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.datasets import make_moons, make_circles, make_classificationfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.svm import SVCfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.ensemble import RandomForestClassifier, AdaBoostClassifierfrom sklearn.naive_bayes import GaussianNB h = .02 # mesh的步长 names = [\"Nearest Neighbors\", \"Linear SVM\", \"RBF SVM\", \"Decision Tree\", \"Random Forest_10\", \"Random Forest_25\",\"Random Forest_50\",\"Random Forest_100\", \"AdaBoost\", \"Naive Bayes\",]classifiers = [ KNeighborsClassifier(3), SVC(kernel=\"linear\", C=0.025), SVC(gamma=2, C=1), DecisionTreeClassifier(), RandomForestClassifier(n_estimators=10), RandomForestClassifier(n_estimators=25), RandomForestClassifier(n_estimators=50), RandomForestClassifier(n_estimators=100), AdaBoostClassifier(), GaussianNB(),] X, y = make_classification(n_features=2, n_redundant=0, n_informative=2, random_state=1, n_clusters_per_class=1)rng = np.random.RandomState(2)X += 2 * rng.uniform(size=X.shape)linearly_separable = (X, y) datasets = [make_moons(noise=0.3, random_state=0), make_circles(noise=0.2, factor=0.5, random_state=1), linearly_separable ] figure = plt.figure(figsize=(27, 9))i = 1# 遍历每个数据集for ds in datasets: # 处理数据集 X, y = ds X = StandardScaler().fit_transform(X) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.4) x_min, x_max = X[:, 0].min() - .5, X[:, 0].max() + .5 y_min, y_max = X[:, 1].min() - .5, X[:, 1].max() + .5 xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h)) # 先绘制数据集 cm = plt.cm.RdBu cm_bright = ListedColormap(['#FF0000', '#0000FF']) ax = plt.subplot(len(datasets), len(classifiers) + 1, i) # 绘制训练集 ax.scatter(X_train[:, 0], X_train[:, 1], c=y_train, cmap=cm_bright) # 绘制测试集 ax.scatter(X_test[:, 0], X_test[:, 1], c=y_test, cmap=cm_bright, alpha=0.6) ax.set_xlim(xx.min(), xx.max()) ax.set_ylim(yy.min(), yy.max()) ax.set_xticks(()) ax.set_yticks(()) i += 1 # 遍历每个分类器 for name, clf in zip(names, classifiers): ax = plt.subplot(len(datasets), len(classifiers) + 1, i) clf.fit(X_train, y_train) score = clf.score(X_test, y_test) # 绘制决策边界 if hasattr(clf, \"decision_function\"): Z = clf.decision_function(np.c_[xx.ravel(), yy.ravel()]) else: Z = clf.predict_proba(np.c_[xx.ravel(), yy.ravel()])[:, 1] # 绘制结果 Z = Z.reshape(xx.shape) ax.contourf(xx, yy, Z, cmap=cm, alpha=.8) ax.scatter(X_train[:, 0], X_train[:, 1], c=y_train, cmap=cm_bright) ax.scatter(X_test[:, 0], X_test[:, 1], c=y_test, cmap=cm_bright, alpha=0.6) ax.set_xlim(xx.min(), xx.max()) ax.set_ylim(yy.min(), yy.max()) ax.set_xticks(()) ax.set_yticks(()) ax.set_title(name) ax.text(xx.max() - .3, yy.min() + .3, ('%.2f' % score).lstrip('0'), size=15, horizontalalignment='right') i += 1 figure.subplots_adjust(left=.02, right=.98)plt.show() 参考文献雷震. 随机森林及其在遥感影像处理中应用研究[D].上海交通大学,2012.周志华. 机器学习[M]. 北京:清华大学出版社, 2016:73-93.https://zhuanlan.zhihu.com/p/32179140https://zhuanlan.zhihu.com/p/32180057","categories":[{"name":"统计机器学习","slug":"统计机器学习","permalink":"https://hengxincheung.github.io/categories/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"统计机器学习","slug":"统计机器学习","permalink":"https://hengxincheung.github.io/tags/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"随机森林","slug":"随机森林","permalink":"https://hengxincheung.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"}]},{"title":"git命令大全","slug":"git/git命令大全","date":"2020-05-26T06:51:35.000Z","updated":"2020-05-27T07:23:06.623Z","comments":true,"path":"git/git命令大全/","link":"","permalink":"https://hengxincheung.github.io/git/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"","text":"参考文档 git 命令123456789101112131415161718192021222324252627282930语法： git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;&#x3D;&lt;value&gt;] [--exec-path[&#x3D;&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p|--paginate|--no-pager] [--no-replace-objects] [--bare] [--git-dir&#x3D;&lt;path&gt;] [--work-tree&#x3D;&lt;path&gt;] [--namespace&#x3D;&lt;name&gt;] [--super-prefix&#x3D;&lt;path&gt;] &lt;command&gt; [&lt;args&gt;] 选项： --version # 打印git程序的版本号 --help # 打印概要和最常用命令的列表 -C &lt;path&gt; # 在&lt;path&gt;而不是当前的工作目录中运行git -c &lt;name&gt;&#x3D;&lt;value&gt; # 将配置参数传递给命令, 给定的值将覆盖配置文件中的值 --exec-path[&#x3D;&lt;path&gt;] # 安装核心Git程序的路径, 可以通过设置GIT_EXEC_PATH环境变量来控制, 如无路径, git将打印当前设置并退出 --html-path # 打印Git的HTML文档安装并退出的路径, 不带斜杠 --man-path # 打印man(1)此版本Git的手册页的manpath, 并退出 --info-path # 打印记录此版本Git的Info文件的安装路径并退出 -p, --paginate # 如果标准输出是终端, 则将所有输出管道更少（或如果设置为$ PAGER）, 这将覆盖pager.&lt;cmd&gt; 配置选项 --no-pager # 不要将Git输出管道传输到寻呼机 --no-replace-objects # 不要使用替换参考来替换Git对象 --bare # 将存储库视为裸存储库, 如果未设置GIT_DIR环境, 则将其设置为当前工作目录 --git-dir&#x3D;&lt;path&gt; # 设置存储库的路径, 可以通过设置GIT_DIR环境变量来控制, 可以是当前工作目录的绝对或相对路径 --work-tree&#x3D;&lt;path&gt; # 设置工作树的路径, 可以通过设置GIT_WORK_TREE环境变量和core.worktree配置变量来控制, 相对于当前工作目录的绝对或相对路径 --namespace&#x3D;&lt;path&gt; # 设置Git命名空间, 相当于设置GIT_NAMESPACE环境变量 --super-prefix&#x3D;&lt;path&gt; # 目前仅供内部使用, 设置一个前缀, 该前缀从存储库到根的路径, 一个用途是给调用它的超级项目的子模块上下文 --literal-pathspecs # 字面上处理pathspecs, 相当于设置GIT_LITERAL_PATHSPECS为1 --glob-pathspecs # 添加&quot;glob&quot;到所有pathspec, 相当于设置GIT_GLOB_PATHSPECS为1 --noglob-pathspecs # 添加&quot;文字&quot;到所有pathspec, 相当于设置GIT_NOGLOB_PATHSPECS为1 --icase-pathspecs # 添加&quot;icase&quot;到所有pathspec, 相当于设置GIT_ICASE_PATHSPECS为1 --no-optional-locks # 不要执行需要锁定的可选操作, 相当于设置GIT_OPTIONAL_LOCKS为0 config 命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546语法： git config [&lt;file-option&gt;] [type] [--show-origin] [-z|--null] name [value [value_regex]] git config [&lt;file-option&gt;] [type] --add name value git config [&lt;file-option&gt;] [type] --replace-all name value [value_regex] git config [&lt;file-option&gt;] [type] [--show-origin] [-z|--null] --get name [value_regex] git config [&lt;file-option&gt;] [type] [--show-origin] [-z|--null] --get-all name [value_regex] git config [&lt;file-option&gt;] [type] [--show-origin] [-z|--null] [--name-only] --get-regexp name_regex [value_regex] git config [&lt;file-option&gt;] [type] [-z|--null] --get-urlmatch name URL git config [&lt;file-option&gt;] --unset name [value_regex] git config [&lt;file-option&gt;] --unset-all name [value_regex] git config [&lt;file-option&gt;] --rename-section old_name new_name git config [&lt;file-option&gt;] --remove-section name git config [&lt;file-option&gt;] [--show-origin] [-z|--null] [--name-only] -l | --list git config [&lt;file-option&gt;] --get-color name [default] git config [&lt;file-option&gt;] --get-colorbool name [stdout-is-tty] git config [&lt;file-option&gt;] -e | --edit选项： --system # 使用系统配置文件 --global # 使用全局配置文件 --local # 使用本地配置文件, 默认 -f &lt;filename&gt;, --file &lt;filename&gt; # 使用指定配置文件 --blob &lt;blob-id&gt; # 使用指定blob --int # 确保输出为简单十进制数 --bool # 确保输出为&quot;true&quot; 或 &quot;false&quot; 的布尔字符串表示 --bool-or-int # 确保输出为--bool或--int的格式 --path # 将扩展~到指定用户的主目录的值 $HOME和~user主目录。 --replace-all # 替换与该键匹配的所有行 --add # 添加配置项 --get # 获取给定键的值（可选用与值匹配的正则表达式进行过滤） --get-all # 像get一样，但返回多值键的所有值 --get-regexp # 像get-all一样，但将该名称解释为正则表达式并写出键名称 --get-urlmatch name URL # 当给定一个由两部分组成的名称section.key时，会返回部分&lt;url&gt;.key的值 --remove-section # 从配置文件中删除给定的部分 --rename-section # 将给定部分重命名为新名称 --unset # 从配置文件中删除与密钥匹配的行 --unset-all # 从配置文件中删除所有与密钥匹配的行 -l, --list # 列出在配置文件中设置的所有变量及其值 --expiry-date # 将确保输出从固定或相对日期字符串转换为时间戳, 设置该值时此选项无效 -z, --null # 对于输出值和&#x2F;或键的所有选项，始终使用空字符结束值, 使用换行符作为键和值之间的分隔符 --name-only # 输出--listor 的配置变量的名称--get-regexp --show-origin # 使用原点类型（文件, 标准输入, blob, 命令行）和实际原点（配置文件路径, ref或blob id）扩大所有查询配置选项的输出 --get-colorbool name [stdout-is-tty]# 找到name（例如color.diff）的颜色设置并输出&quot;true&quot;或&quot;false&quot; --get-color name [default] # 查找name（例如color.diff.new）配置的颜色并将其作为ANSI颜色转义序列输出到标准输出 -e, --edit # 打开一个编辑器来修改指定的配置文件; 或者 --system，--global或者存储库（默认） --[no-]includes # 查找值, 默认off, on搜索所有配置文件, 当值定文件时（使用：--file，--global等） help 命令12345678910语法： git help [-a|--all] [-g|--guide] [-i|--info|-m|--man|-w|--web] [COMMAND|GUIDE]选项： -a, --all # 在标准输出上打印所有可用的命令 -g, --guide # 在标准输出上打印有用的指南列表 -i, --info # 以信息格式显示命令的手册页 -m, --man # 以man格式显示命令的手册页 -w, --web # 以Web（HTML）格式显示命令的手册页 init 命令12345678910111213141516语法： git init [-q | --quiet] [--bare] [--template&#x3D;&lt;template_directory&gt;] [--separate-git-dir &lt;git dir&gt;] [--shared[&#x3D;&lt;permissions&gt;]] [directory]选项： -q, --quiet # 仅打印错误和警告消息, 所有其他输出将被抑制 --bare # 创建一个裸仓库, 如果GIT_DIR未设置环境, 则将其设置为当前工作目录 --template&#x3D;&lt;template_directory&gt; # 指定将使用模板的目录 --separate-git-dir&#x3D;&lt;git dir&gt; # 相反, 初始化存储库作为目录之一$GIT_DIR或者.&#x2F;.git&#x2F;, 创建一个包含路径的实际存储库的文本文件存在, 该文件充当文件系统不可知的Git与存储库的符号链接 --shared[&#x3D;(false|true|umask|group|all|world|everybody|0xxx)] # 指定Git存储库在多用户间共享, 允许同一组的用户推入该存储库 umask (or false) # 使用由umask(2)报告的权限, --shared未指定时的默认值 group (or true) # 使存储库组可写 all (or world or everybody) # 与组相同，但使存储库可供所有用户读取 0xxx # 0xxx是八进制数, 每个文件都有模式0xxx。 0640将创建一个组可读的存储库, 但不能对其他组进行写入或访问。0660将创建一个对当前用户和组可读可写的回购, 但其他人无法访问。 clone 命令12345678910111213141516171819202122232425262728293031323334353637语法： git clone [--template&#x3D;&lt;template_directory&gt;] [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror] [-o &lt;name&gt;] [-b &lt;name&gt;] [-u &lt;upload-pack&gt;] [--reference &lt;repository&gt;] [--dissociate] [--separate-git-dir &lt;git dir&gt;] [--depth &lt;depth&gt;] [--[no-]single-branch] [--no-tags] [--recurse-submodules[&#x3D;&lt;pathspec&gt;]] [--[no-]shallow-submodules] [--jobs &lt;n&gt;] [--] &lt;repository&gt; [&lt;directory&gt;]选项： -l, --local # 当克隆的存储库位于本地计算机上时, 此标志绕过正常的“Git aware”传输机制, 并通过复制HEAD以及对象和引用目录下的所有内容来克隆存储库 --no-hardlinks # 强制从本地文件系统的存储库复制进程, 以复制目录下的.git&#x2F;objects 文件而不是使用硬链接 -s, --shared # 当克隆的存储库位于本地计算机上时, 将自动设置.git&#x2F;objects&#x2F;info&#x2F;alternates为与源存储库共享对象, 而不是使用硬链接, 生成的存储库首先没有任何对象 --reference[-if-able] &lt;repository&gt; # 如存储库位于本地计算机上, 则自动设置.git&#x2F;objects&#x2F;info&#x2F;alternates为从存储库获取对象将已存在存储库用作备用存储库将需从正在克隆的存储库中复制更少对象, 而降低网络和本地存储成本 --dissociate # 借助--reference仅使用选项指定的引用存储库借用对象, 以减少网络传输, 并通过制作所需的借用对象的本地副本, 在克隆完成后停止借用它们 -q, --quiet # 安静地操作, 进度未报告给标准错误流 -v, --verbose # 运行详细, 不影响向标准错误流报告进度状态 --progress # 当连接到终端时，默认情况下, 标准错误流中会报告进度状态，除非指定-q，即使标准错误流未定向到终端, 此标志也会强制进度状态 -n, --no-checkout # 克隆完成后, 不执行HEAD签出 --bare # 制作一个纯粹的 Git存储库 --mirror # 设置源存储库的镜像 -o &lt;name&gt;, --origin &lt;name&gt; # 不要使用远程名称origin来跟踪上游存储库，请使用&lt;name&gt; -b &lt;name&gt;, --branch &lt;name&gt; # 而不是将新创建的HEAD指向克隆存储库HEAD指向的&lt;name&gt;分支，而是指向分支在非裸仓库中, 这是将被检出的分支。 --branch也可以在生成的存储库中提交标签并分离HEAD -u &lt;upload-pack&gt;, --upload-pack &lt;upload-pack&gt; # 当给定时, 通过ssh访问要克隆的存储库, 这将为另一端运行的命令指定非默认路径 --template&#x3D;&lt;template_directory&gt; # 指定将使用模板的目录 -c &lt;key&gt;&#x3D;&lt;value&gt;, --config &lt;key&gt;&#x3D;&lt;value&gt; # 在新创建的存储库中设置配置变量 --depth &lt;depth&gt; # 创建一个历史截断为指定数目的提交的浅表副本 --shallow-since&#x3D;&lt;date&gt; # 在指定时间后创建一个具有历史记录的浅表克隆 --shallow-exclude&#x3D;&lt;revision&gt; # 创建有历史记录的浅层克隆, 但不包括从指定远程分支或标记可访问的提交 --[no-]single-branch # 只克隆导致单个分支尖端的历史记录, 无论--branch选项指定还是主分支远程的HEAD指向 --no-tags # 不要克隆任何标签, 并remote.&lt;remote&gt;.tagOpt&#x3D;--no-tags在配置中设置, 确保将来git pull和git fetch操作不会跟随任何标签 --recurse-submodules[&#x3D;&lt;pathspec] # 创建克隆后, 根据pathspec初始化和克隆子模块。如未提供pathspec, 则初始化并克隆所有子模块 --[no-]shallow-submodules # 所克隆的所有子模块将会变浅, 深度为1 --separate-git-dir&#x3D;&lt;git dir&gt; # 不要将克隆的存储库放置在它应该存在的位置, 而应将克隆的存储库放置在指定的目录中,然后创建一个与文件系统无关的Git符号链接。结果是Git仓库可以从工作树中分离出来 -j &lt;n&gt;, --jobs &lt;n&gt; # 同时获取的子模块的数量。默认为submodule.fetchJobs选项 &lt;repository&gt; # 从中克隆的存储库 &lt;directory&gt; # 要克隆到的新目录的名称 add 命令12345678910111213141516171819202122232425语法： git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p] [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize] [--chmod&#x3D;(+|-)x] [--] [&lt;pathspec&gt;…​]选项： -v, --verbose # 详细 -n, --dry-run # 不要实际添加文件, 只显示它们是否存在和&#x2F;或将被忽略 -f, --force # 允许添加被忽略的文件 -i, --interactive # 在工作树中交互添加修改的内容到索引 -p, --patch # 在索引和工作树之间交互地选择补丁块, 并将它们添加到索引中 -e, --edit # 在编辑器中打开差异与索引并让用户编辑它。编辑器关闭后, 调整大块头并将补丁应用到索引 -u, --update # 更新已存在匹配&lt;pathspec&gt;条目的索引。这会删除和修改索引条目以匹配工作树, 但不会添加新文件 -A, --all, --no-ignore-removal # 更新索引不仅在工作树具有匹配&lt;pathspec&gt;的文件的位置, 而且索引已经有条目的位置这会添加，修改和删除索引条目以匹配工作树 --no-all, --ignore-removal # 通过添加索引未知的新文件和工作树中修改的文件来更新索引, 但忽略已从工作树中删除的文件当没有使用&lt;pathspec&gt;时，该选项是无操作的 -N, --intent-to-add # 只记录路径将在稍后添加的事实。路径条目放置在没有内容的索引中 --refresh # 不要添加文件，而只需刷新索引中的stat()信息 --ignore-errors # 如果某些文件因索引错误而无法添加, 请不要中止操作，而是继续添加其他文件 --ignore-missing # 该选项只能与--dry-run一起使用。用户可检查是否有给定的文件被忽略, 不管是否已存在于工作树中 --no-warn-embedded-repo # 默认情况下, git add向嵌入式存储库添加索引时会发出警告, 而不用git submodule add其中创建条目.gitmodules。该选项将会禁止警告 --renormalize # 将新鲜的&quot;干净&quot;过程应用于所有跟踪的文件, 以强制将其再次添加到索引 --chmod&#x3D;(+|-)x # 覆盖添加文件的可执行位。可执行位仅在索引中更改, 磁盘上的文件保持不变。 -- # 此选项可用于将命令行选项与文件列表分开 &lt;pathspec&gt;… # 要从中添加内容的文件。*.c可以给Fileglobs（例如）添加所有匹配的文件 status 命令1234567891011121314151617181920语法： git status [&lt;options&gt;…​] [--] [&lt;pathspec&gt;…​]选项： -s, --short # 以短格式输出输出 -b, --branch # 甚至以短格式显示分支和跟踪信息 --show-stash # 显示当前隐藏的条目数量 --porcelain[&#x3D;&lt;version&gt;] # 为脚本提供易于解析的格式输出 --long # 以长格式输出输出, 默认 -v, --verbose # 除了已更改的文件名称之外, 还会显示正在执行的文本更改 -u[&lt;mode&gt;], --untracked-files[&#x3D;&lt;mode&gt;] # 显示未跟踪的文件 --ignore-submodules[&#x3D;&lt;when&gt;] # 查找更改时忽略对子模块的更改。&lt;when&gt;可以是&quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot;或&quot;all&quot;, 这是默认设置 --ignored[&#x3D;&lt;mode&gt;] # 也显示忽略的文件。mode参数用于指定忽略文件的处理, 可选的, 默认为传统 traditional # 传统, 显示被忽略的文件和目录, 除非指定--untracked-files &#x3D; all，这种情况下将显示忽略目录中的单个文件 no # 否, 不显示任何被忽略的文件 matching # 匹配, 显示与忽略模式匹配的忽略文件和目录 -z # 用NUL而不是LF终止输入 --no-column, --column[&#x3D;&lt;options&gt;] # 在列中显示未跟踪的文件 --ahead-behind, --no-ahead-behind # 显示或不显示分支相对于其上游分支的详细前&#x2F;后计数。默认为true &lt;pathspec&gt;…​ # diff 命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788语法： git diff [options] [&lt;commit&gt;] [--] [&lt;path&gt;…​] git diff [options] --cached [&lt;commit&gt;] [--] [&lt;path&gt;…​] git diff [options] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…​] git diff [options] &lt;blob&gt; &lt;blob&gt; git diff [options] [--no-index] [--] &lt;path&gt; &lt;path&gt;选项： -p, -u, --patch # 生成补丁, 这是默认设置 -s, --no-patch # 抑制差异输出。对于像git show这样的命令很有用，默认显示补丁，或取消效果--patch -U&lt;n&gt;, --unified&#x3D;&lt;n&gt; # 使用&lt;n&gt;行上下文生成差异，而不是通常的三行。意味着-p --raw # 以原始格式生成差异 --patch-with-raw # 原始的同义词-p --raw --indent-heuristic, --no-indent-heuristic # 为了帮助调试和调整实验启发式, 改变差异边界以使修补程序更易于阅读, 默认关闭 --minimal # 花费额外的时间来确保生成最小可能的差异 --patience # 使用&quot;耐心差异&quot;算法生成差异 --histogram # 使用&quot;直方图差异&quot;算法生成差异 --diff-algorithm&#x3D;&#123;patience|minimal|histogram|myers&#125; # 选择一种差异算法 default, myers # 基本的贪婪diff算法, 默认设置 minimal # 花费额外的时间来确保生成最小可能的差异 patience # 生成补丁时使用&quot;耐心差异&quot;算法 histogram # 该算法将耐心算法扩展为&quot;支持低出现率的通用元素&quot; --stat[&#x3D;&lt;width&gt;[,&lt;name-width&gt;[,&lt;count&gt;]]] # 生成一个diffstat --numstat # 类似--stat，但显示十进制表示法中添加和删除的行数以及不带缩写的路径名。 对于二进制文件，输出两个-而不是说 0 0 --shortstat # 只输出--stat包含修改文件总数的格式的最后一行, 以及添加和删除行的数量 --dirstat[&#x3D;&lt;param1,param2,…​&gt;] # 输出每个子目录的相对变化量分布。--dirstat可以通过传递逗号分隔的参数列表来定制行为 changes # 通过计算已从源中删除或添加到目标的行来计算dirstat数字 lines # 通过执行常规基于行的差异分析来计算dirstat数字，并将删除&#x2F;添加的行数相加 files # 通过计算更改的文件数量来计算dirstat数字 cumulative # 计数父目录的子目录中的更改 &lt;limit&gt; # 整数参数指定截断百分比（默认为3％）。输出中不显示贡献小于此百分比的目录 --summary # 输出扩展头信息的精简摘要，如创建，重命名和模式更改 --patch-with-stat # 同义词- p - stat -z # 当--raw，--numstat，--name-only或--name-status已给出，不Munge时间路径名，并使用完全无效的输出字段终止符 --name-only # 仅显示已更改文件的名称 --name-status # 仅显示已更改文件的名称和状态 --submodule[&#x3D;&lt;format&gt;] # 指定如何显示子模块中的差异 --color[&#x3D;&lt;when&gt;] # 显示有色差异 --no-color # 关闭有色差异 --word-diff[&#x3D;&lt;mode&gt;] # 显示一个单词diff，使用&lt;mode&gt;分隔已更改的单词。默认: 空格分隔 color # 仅使用颜色突出显示更改的词 plain # 将单词显示为[-removed-]和&#123;+added+&#125;。如果输入中出现分隔符，则不会尝试跳过分隔符，因此输出可能不明确 porcelain # 使用专门用于脚本消费的基于行的格式 none # 再次禁用字差异 --word-diff-regex&#x3D;&lt;regex&gt; # 使用&lt;regex&gt;来决定一个单词是什么，而不是将非空白的运行视为一个单词 --color-words[&#x3D;&lt;regex&gt;] # 相当于--word-diff&#x3D;color加号 --no-renames # 关闭重命名检测，即使配置文件提供了默认设置 --check # 警告如果更改引入冲突标记或空白错误。认为空白错误由core.whitespace 配置控制。 --ws-error-highlight&#x3D;&lt;kind&gt; # 按&lt;颜色&gt;指定的颜色突出显示由&lt;颜色&gt;指定的行上的空白错误color.diff.whitespace --full-index # 在生成补丁格式输出时，在“索引”行上显示完整的映像前和映像后blob对象名称，而不是第一批字符 --binary # 除了--full-index输出可以应用的二进制差异git-apply --abbrev[&#x3D;&lt;n&gt;] # 不是在diff-raw格式输出和diff-tree标题行中显示完整的40字节十六进制对象名称，只显示部分前缀 -B[&lt;n&gt;][&#x2F;&lt;m&gt;], --break-rewrites[&#x3D;[&lt;n&gt;][&#x2F;&lt;m&gt;]] # 将完全重写更改分解为删除和创建对 -M[&lt;n&gt;], --find-renames[&#x3D;&lt;n&gt;] # 检测重命名 -C[&lt;n&gt;], --find-copies[&#x3D;&lt;n&gt;] # 检测副本以及重命名 --find-copies-harder # 出于性能原因，默认情况下，-C只有当副本的原始文件在相同的变更集中被修改时，选项才会查找副本 -D, --irreversible-delete # 省略原图像进行删除，即仅打印标题，但不打印原像和之间的差异&#x2F;dev&#x2F;null -l&lt;num&gt; # 在-M和-C选项需要为O（n ^ 2）的处理时间，其中n是&#x2F;复制目标潜在的重命名的数目如果重命名&#x2F;复制目标的数量超过指定的数量，则此选项可防止重命名&#x2F;复制检测运行 --diff-filter&#x3D;[(A|C|D|M|R|T|U|X|B)…​[*]] # 选择仅添加(A), 复制(C), 删除(D), 修改(M), 重命名(R), 其类型(即常规文件, 符号链接, 子模块, ...)更改(T), Unmerged(U), 未知(X)或已配对Broken(B) 可以使用任何过滤字符的组合(包括无)当*（全部或无）添加到组合中时，如果有任何文件与比较中的其他条件匹配，则选择所有路径; 如果没有与其他标准匹配的文件，则不会选择任何内容 -S&lt;string&gt; # 查找改变文件中指定字符串出现次数（即添加&#x2F;删除）的差异 -G&lt;regex&gt; # 寻找补丁文本包含与&lt;regex&gt;匹配的添加&#x2F;删除行的差异 --pickaxe-all # 当-S或-G发现更改时，显示该更改集中的所有更改，而不仅仅是包含&lt;string&gt;中的更改的文件 --pickaxe-regex # 将给定的&lt;string&gt; -S视为扩展的POSIX正则表达式进行匹配 -O&lt;orderfile&gt; # 控制文件在输出中出现的顺序 -R # 交换两个输入; 即显示索引或磁盘文件与树内容的差异 --relative[&#x3D;&lt;path&gt;] # 从项目的子目录运行时，可以通过此选项告知排除目录外的更改并显示与其相关的路径名 -a, --text # 将所有文件视为文本 --ignore-space-at-eol # 忽略EOL中的空白变化 -b, --ignore-space-change # 忽略空白量的变化。这会忽略行结束处的空白，并认为一个或多个空白字符的所有其他序列是等价的 -w, --ignore-all-space # 比较行时忽略空格。即使一行有空白，而另一行没有空白，这也会忽略差异 --ignore-blank-lines # 忽略其行全部空白的更改 --inter-hunk-context&#x3D;&lt;lines&gt; # 显示差异hunk之间的上下文，直到指定的行数，从而融合彼此接近的hunk -W, --function-context # 显示整个周围的变化功能 --exit-code # 用类似于diff（1）的代码退出程序。也就是说，如果存在差异，则1退出，0表示没有差异 --quiet # 禁用程序的所有输出。意味着--exit-code --ext-diff # 允许执行一个外部比较助手 --no-ext-diff # 禁止外部差异驱动程序 --textconv, --no-textconv # 在比较二进制文件时，允许（或不允许）运行外部文本转换过滤器 --ignore-submodules[&#x3D;&lt;when&gt;] # 忽略差异代中子模块的更改。&lt;when&gt;可以是“none”，“untracked”，“dirty”或“all”，这是默认设置 --src-prefix&#x3D;&lt;prefix&gt; # 显示给定的源前缀而不是“a &#x2F;” --dst-prefix&#x3D;&lt;prefix&gt; # 显示给定的目的地前缀而不是“b &#x2F;” --no-prefix # 不要显示任何来源或目的地前缀 --line-prefix&#x3D;&lt;prefix&gt; # 为每行输出预留一个额外的前缀 --ita-invisible-in-index # 默认情况下，由“git add -N”添加的条目显示为“git diff”中的现有空文件和“git diff --cached”中的新文件 -1 --base, -2 --ours, -3 --theirs # 比较工作树与“基本”版本（阶段＃1），“我们的分支”（阶段＃2）或“他们的分支”（阶段＃3） -0 # 忽略差异输出未合并的条目并只显示“未合并”。仅在将工作树与索引进行比较时才能使用 &lt;path&gt;…​ # 给出的&lt;paths&gt;参数用于将diff限制为指定的路径 commit 命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253语法： git commit [-a | --interactive | --patch] [-s] [-v] [-u&lt;mode&gt;] [--amend] [--dry-run] [(-c | -C | --fixup | --squash) &lt;commit&gt;] [-F &lt;file&gt; | -m &lt;msg&gt;] [--reset-author] [--allow-empty] [--allow-empty-message] [--no-verify] [-e] [--author&#x3D;&lt;author&gt;] [--date&#x3D;&lt;date&gt;] [--cleanup&#x3D;&lt;mode&gt;] [--[no-]status] [-i | -o] [-S[&lt;keyid&gt;]] [--] [&lt;file&gt;…​]选项： -a, --all # 告诉命令自动对已被修改和删除的文件进行分段处理，但没有告知Git的新文件不受影响 -p, --patch # 使用交互式补丁选择界面来选择要提交的更改 -C &lt;commit&gt;, --reuse-message&#x3D;&lt;commit&gt; # 取一个现有的提交对象，并在创建提交时重用日志消息和作者信息（包括时间戳） -c &lt;commit&gt;, --reedit-message&#x3D;&lt;commit&gt; # 像-C一样，但-c调用了编辑器，以便用户可以进一步编辑提交消息 --fixup&#x3D;&lt;commit&gt; # 构建一个提交消息以供使用rebase --autosquash。提交消息将成为指定提交的主题行，其前缀为“fixup！” --squash&#x3D;&lt;commit&gt; # 构建一个提交消息以供使用rebase --autosquash。提交消息主题行取自指定的提交，前缀为“squash！” --reset-author # 当与-C &#x2F; -c &#x2F; - 修改选项一起使用时，或者在冲突樱桃挑选后提交时，声明结果提交的作者现在属于提交者 --short # 进行干运行时，请以短格式输出 --branch # 甚至以短格式显示分支和跟踪信息 --porcelain # 进行干式运行时，请将输出信号以瓷器准备好的格式输出 --long # 进行干式运行时，请以长格式输出 -z, --null # 显示short或porcelain状态输出时，逐字打印文件名并用NUL而不是LF结束输入。如果没有给出格式，则表示--porcelain输出格式 -F &lt;file&gt;, --file&#x3D;&lt;file&gt; # 从给定的文件中获取提交消息。使用-从标准输入中读取消息 --author&#x3D;&lt;author&gt; # 覆盖提交作者。使用标准A U Thor &lt;author@example.com&gt;格式指定明确的作者 --date&#x3D;&lt;date&gt; # 覆盖提交中使用的作者日期 -m &lt;msg&gt;, --message&#x3D;&lt;msg&gt; # 使用给定的&lt;msg&gt;作为提交消息 -t &lt;file&gt;, --template&#x3D;&lt;file&gt; # 编辑提交消息时，使用给定文件中的内容启动编辑器 -s, --signoff # 提交日志消息结尾处的提交者添加Signed-off-by行 -n, --no-verify # 该选项绕过预先提交和提交msg钩子 --allow-empty # 通常记录具有与其唯一父提交完全相同的树的提交是个错误，并且该命令阻止您提交此类提交 --allow-empty-message # 像--allow-empty这个命令主要供外国SCM接口脚本使用。它允许你使用空的提交消息创建一个提交，而不使用像git-commit-tree [1]命令 --cleanup&#x3D;&lt;mode&gt; # 这个选项决定了在提交之前应该如何清理提供的提交消息。所述&lt;模式&gt;可以是strip， whitespace，verbatim，scissors或default strip # 删除前导和尾随空行，尾随空白，评论和折叠连续的空行 whitespace # 同strip除#commentary不会被删除 verbatim # 根本不要改变信息 scissors # 相同whitespace，除了一切从（并包括）下面找到的行被截短，如果消息是要被编辑 default # 就strip好像要编辑的消息一样。否则whitespace -e, --edit # 从文件提取的消息-F，命令行 -m和从提交对象中取出的消息-C通常用作未修改的提交日志消息 --no-edit # 使用选定的提交消息而不启动编辑器。例如，git commit --amend --no-edit修改提交而不更改其提交消息 --amend # 通过创建一个新的提交来替换当前分支的提示 --no-post-rewrite # 绕过重写挂钩 -i, --include # 在到目前为止的阶段性内容提交之前，请在命令行上指定路径的内容。这通常不是你想要的，除非你正在完成一个冲突的合并。 -o, --only # 通过获取命令行中指定路径的更新工作树内容来进行提交，而忽略已为其他路径执行的任何内容 -u[&lt;mode&gt;], --untracked-files[&#x3D;&lt;mode&gt;] # 显示未跟踪的文件。模式可选的(默认为全部), 并用于指定未跟踪文件的处理; 当-u未被使用时，默认是正常的，即显示未跟踪的文件和目录。所述&lt;模式&gt;可以是no， normal，all -v, --verbose # 显示HEAD提交与提交消息模板底部提交的内容之间的统一差异，以帮助用户通过提醒提交具有哪些更改来描述提交 -q, --quiet # 禁止提交摘要消息 --dry-run # 不要创建提交,而是显示要提交的路径列表,包含将保留未提交的本地更改的路径以及未跟踪的路径 --status # 使用编辑器准备提交消息时，在提交消息模板中包含git-status [1]的输出。默认为打开，但可用于覆盖配置变量commit.status。 --no-status # 使用编辑器准备默认提交消息时，不要在提交消息模板中包含git-status [1]的输出。 -S[&lt;keyid&gt;], --gpg-sign[&#x3D;&lt;keyid&gt;] # GPG标志提交。该keyid参数是可选的，并且默认为提交者身份 --no-gpg-sign # commit.gpgSign设置为强制每个提交进行签名的计数器配置变量 -- # 不要将更多的参数解释为选项 &lt;file&gt;…​ # 当在命令行上给出文件时，该命令将提交指定文件的内容，而不记录已经执行的更改 reset 命令123456789101112语法： git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​ git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​] git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;]选项： -q, --quiet # 保持安静，只报告错误 --soft # 根本不触摸索引文件或工作树（但将头重置为&lt;commit&gt;，就像所有模式一样） --mixed # 重置索引而不是工作树（即，保存更改的文件但未标记为提交）并报告尚未更新的内容。这是默认操作 --hard # 重置索引和工作树。放弃自&lt;commit&gt;以来对工作树中跟踪文件所做的任何更改 --merge # 重置索引并更新工作树中&lt;commit&gt;和HEAD之间不同的文件，但保留索引和工作树之间不同的文件（即没有添加更改的文件）如果&lt;commit&gt;和索引之间的文件有不同的变化，则重置会中止 --keep # 重置索引条目并更新工作树中&lt;commit&gt;和HEAD之间不同的文件。如果&lt;commit&gt;和HEAD之间的文件有本地更改，则重置会中止 rm 命令123456789101112语法： git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch] [--quiet] [--] &lt;file&gt;…​选项： &lt;file&gt;…​ # 要删除的文件 -f, --force # 覆盖最新的检查 -n, --dry-run # 切勿删除任何文件。相反，只需显示它们是否存在于索引中，否则将被命令删除 -r # 当给出主目录名时允许递归删除 -- # 此选项可用于将命令行选项与文件列表分开，（当文件名可能被误认为是命令行选项时很有用） --cached # 使用此选项可以取消仅从索引中删除路径的情况。工作树文件，无论是否修改，都将被单独保留 --ignore-unmatch # 即使没有匹配的文件，也可以用零状态退出 -q, --quiet # 该选项禁止输出 mv 命令12345678语法： git mv &lt;options&gt;…​ &lt;args&gt;…​选项： -f, --force # 即使目标存在，也要强制重命名或移动文件 -k # 跳过移动或重命名会导致错误情况的操作 -n, --dry-run # 没做什么; 只显示会发生什么 -v, --verbose # 报告移动文件的名称 branch 命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152语法： git branch [--color[&#x3D;&lt;when&gt;] | --no-color] [-r | -a] [--list] [-v [--abbrev&#x3D;&lt;length&gt; | --no-abbrev]] [--column[&#x3D;&lt;options&gt;] | --no-column] [--sort&#x3D;&lt;key&gt;] [(--merged | --no-merged) [&lt;commit&gt;]] [--contains [&lt;commit]] [--no-contains [&lt;commit&gt;]] [--points-at &lt;object&gt;] [--format&#x3D;&lt;format&gt;] [&lt;pattern&gt;…​] git branch [--track | --no-track] [-l] [-f] &lt;branchname&gt; [&lt;start-point&gt;] git branch (--set-upstream-to&#x3D;&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;] git branch --unset-upstream [&lt;branchname&gt;] git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt; git branch (-c | -C) [&lt;oldbranch&gt;] &lt;newbranch&gt; git branch (-d | -D) [-r] &lt;branchname&gt;…​ git branch --edit-description [&lt;branchname&gt;]选项： -d, --delete # 删除分支 -D # 快捷键--delete --force -l, --create-reflog # 创建分支的reflog -f, --force # 将&lt;branchname&gt;重置为&lt;startpoint&gt;，即使&lt;branchname&gt;已存在 -m, --move # 移动&#x2F;重命名分支和相应的reflog -M # 快捷键--move --force -c, --copy # 复制分支和相应的reflog -C # 快捷键--copy --force --color[&#x3D;&lt;when&gt;] # 颜色分支突出显示当前，本地和远程跟踪分支。该值必须始终（默认），永不，或自动 --no-color # 关闭分支颜色，即使配置文件将默认设置为颜色输出。和...一样--color&#x3D;never -i, --ignore-case # 排序和过滤分支不区分大小写 --column[&#x3D;&lt;options&gt;], --no-column # 在列中显示分支列表 -r, --remotes # 列出或删除（如果与-d一起使用）远程跟踪分支 -a, --all # 列出远程追踪分行和当地分行 --list # 列出分支 -v, -vv, --verbose # 在列表模式下，显示sha1并为每个头提交主题行，以及与上游分支（如果有）的关系 -q, --quiet # 创建或删除分支时更安静，抑制非错误消息 --abbrev&#x3D;&lt;length&gt; # 改变输出列表中sha1的最小显示长度。默认值是7 --no-abbrev # 在输出列表中显示完整的sha1，而不是缩写它们 -t, --track # 创建新分支时，设置branch.&lt;name&gt;.remote和 branch.&lt;name&gt;.merge配置条目以将起点分支标记为新分支的“上游” --no-track # 即使branch.autoSetupMerge配置变量为true，也不要设置“上游”配置 --set-upstream # 由于此选项具有混淆语法，因此不再支持。请使用--track或--set-upstream-to替代 -u &lt;upstream&gt;, --set-upstream-to&#x3D;&lt;upstream&gt; # 设置&lt;branchname&gt;的跟踪信息，以便&lt;upstream&gt;被视为&lt;branchname&gt;的上游分支。如果未指定&lt;branchname&gt;，则默认为当前分支。 --unset-upstream # 删除&lt;branchname&gt;的上游信息。如果未指定分支，则默认为当前分支 --edit-description # 打开一个编辑器，编辑文本解释分支是干什么用的，通过其他各种命令使用（例如format-patch， request-pull和merge（如果启用）） --contains [&lt;commit&gt;] # 只列出包含指定提交的分支（如果未指定，则为HEAD）。意味着--list --no-contains [&lt;commit&gt;] # 只列出不包含指定提交的分支（如果未指定，则为HEAD）。意味着--list --merged [&lt;commit&gt;] # 仅列出可从指定提交中获得提示的分支（如果未指定，则为HEAD）。暗示--list，不符合--no-merged --no-merged [&lt;commit&gt;] # 只列出提示无法从指定提交中获得的分支（如果未指定，则为HEAD）。暗示--list，不符合--merged &lt;branchname&gt; # 要创建或删除的分支的名称 &lt;start-point&gt; # 新的分支头将指向这个提交 &lt;oldbranch&gt; # 要重命名的现有分支的名称 &lt;newbranch&gt; # 现有分支的新名称 --sort&#x3D;&lt;key&gt; # 根据给定的关键字进行排序 --points-at &lt;object&gt; # 只列出给定对象的分支 --format &lt;format&gt; # 从显示的分支ref 中插入的字符串以及它指向的对象。格式与git-for-each-ref [1]的格式相同 checkout 命令12345678910111213141516171819202122232425262728293031语法： git checkout [-q] [-f] [-m] [&lt;branch&gt;] git checkout [-q] [-f] [-m] --detach [&lt;branch&gt;] git checkout [-q] [-f] [-m] [--detach] &lt;commit&gt; git checkout [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;] git checkout [-f|--ours|--theirs|-m|--conflict&#x3D;&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​ git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​ git checkout (-p|--patch) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​]选项： -q, --quiet # 抑制反馈信息 --[no-]progress # 除非--quiet 已指定，否则标准错误流默认情况下会将其连接到终端时报告进度状态 -f, --force # 切换分支时，即使索引或工作树与HEAD不同，也要继续。这用于丢弃本地更改 --ours, --theirs # 当从索引中检出路径时，请检查第2阶段(ours)或第3阶段(theirs)是否有未合并的路径 -b &lt;new_branch&gt; # 创建一个名为&lt;new_branch&gt;的新分支并在&lt;start_point&gt;处启动它 -B &lt;new_branch&gt; # 创建分支&lt;new_branch&gt;并在&lt;start_point&gt;处启动它 -t, --track # 创建新分支时，设置“上游”配置 --no-track # 即使branch.autoSetupMerge配置变量为true，也不要设置“上游”配置 -l # 创建新分支的reflog --detach # 而不是检查一个分支来处理它，检查提交检查和可废弃的实验 --orphan &lt;new_branch&gt; # 创建一个名为&lt;new_branch&gt; 的新孤立分支，从&lt;start_point&gt;开始并切换到该分支 --ignore-skip-worktree-bits # 在稀疏结帐模式下，git checkout -- &lt;paths&gt;只会更新$GIT_DIR&#x2F;info&#x2F;sparse-checkout中由&lt;路径&gt;和稀疏模式匹配的条目 -m, --merge # 在切换分支时，如果对当前分支与切换到的分支之间的一个或多个文件进行本地修改，则该命令将拒绝切换分支以便在上下文中保留修改 --conflict&#x3D;&lt;style&gt; # 与上面的--merge选项相同，但改变了冲突的区块显示方式，覆盖merge.conflictStyle配置变量 -p, --patch # 在&lt;tree-ish&gt;（或索引，如果未指定）和工作树之间的区别中交互地选择hunk。然后将选定的区块反向应用于工作树（并且如果指定了&lt;tree-ish&gt;，则索引） --ignore-other-worktrees # git checkout当被通缉的裁判已经被另一个工作树签出时拒绝。这个选项使它无论如何检查裁判 --[no-]recurse-submodules # 使用--recurse子模块将根据超级项目中记录的提交更新所有已初始化的子模块的内容 &lt;branch&gt; # 分支, 如果它引用了一个分支（即，前缀为“refs&#x2F;heads&#x2F;”的名称是有效的ref），那么该分支将被签出 &lt;new_branch&gt; # 新分支的名称 &lt;start_point&gt; # 要开始新分支的提交的名称 &lt;tree-ish&gt; # 要检出的树（当有路径时）。如果未指定，则会使用索引 merge 命令123456789101112131415161718192021222324252627282930313233语法： git merge [-n] [--stat] [--no-commit] [--squash] [--[no-]edit] [-s &lt;strategy&gt;] [-X &lt;strategy-option&gt;] [-S[&lt;keyid&gt;]] [--[no-]allow-unrelated-histories] [--[no-]rerere-autoupdate] [-m &lt;msg&gt;] [&lt;commit&gt;…​] git merge --abort git merge --continue选项： --commit, --no-commit # 执行合并并提交结果。这个选项可以用来覆盖--no-commit -e, --edit, --no-edit # 在提交成功的机械合并之前调用编辑器来进一步编辑自动生成的合并消息，以便用户可以解释并验证合并 --ff # 当合并解析为快进时，只更新分支指针，而不创建合并提交。这是默认行为 --no-ff # 即使合并解析为快进，也可以创建合并提交。这是合并注释标记时的默认行为 --ff-only # 拒绝合并并以非零状态退出，除非当前HEAD已更新或合并可以解决为快进 -S[&lt;keyid&gt;], --gpg-sign[&#x3D;&lt;keyid&gt;] # GPG-签署合并提交 --log[&#x3D;&lt;n&gt;], --no-log # 除了分支名称之外，还可以用来自至多&lt;n&gt;实际提交的单行描述来填充日志消息 --signoff, --no-signoff # 提交日志消息结尾处的提交者添加Signed-off-by行 --stat, -n, --no-stat # 在合并结束时显示diffstat。diffstat也由配置选项merge.stat控制 --squash, --no-squash # 生成工作树和索引状态，就像发生真正的合并一样，但实际上并未进行提交，移动HEAD或记录$GIT_DIR&#x2F;MERGE_HEAD -s &lt;strategy&gt;, --strategy&#x3D;&lt;strategy&gt; # 使用给定的合并策略; 可以多次提供，以按照他们应该尝试的顺序指定它们 -X &lt;option&gt;, --strategy-option&#x3D;&lt;option&gt; # 将合并策略特定选项传递给合并策略 --verify-signatures, --no-verify-signatures # 验证被合并的分支的提示提交是否使用有效密钥进行签名，即具有有效uid的密钥：在默认信任模型中， 这意味着签名密钥已由可信密钥签名。如果侧分支的提示提交未使用有效密钥进行签名，则会中止合并 --summary, --no-summary # 同义词--stat和--no-stat; 这些已被弃用，并将在未来被删除 -q, --quiet # 安静地操作。意味着 - 没有进步 -v, --verbose # 详细 --progress, --no-progress # 明确地打开&#x2F;关闭进度。如果没有指定，如果标准错误连接到终端，则显示进度 --allow-unrelated-histories # 默认情况下，git merge命令拒绝合并不共享祖先的历史记录 -m &lt;msg&gt; # 设置要用于合并提交的提交消息（以防创建） --[no-]rerere-autoupdate # 如果可能的话，允许rerere机制用自动冲突解决的结果更新索引 --abort # 中止当前的冲突解决过程，并尝试重新构建预合并状态 --continue # 经过git的合并，由于停止冲突，那么可以得出结论：通过运行合并混帐合并--continue &lt;commit&gt;…​ # 提交, 通常其他分支, 合并到我们的分支 mergetool 命令123456789语法： git mergetool [--tool&#x3D;&lt;tool&gt;] [-y | --[no-]prompt] [&lt;file&gt;…​] 选项： -t &lt;tool&gt;, --tool&#x3D;&lt;tool&gt; # 使用&lt;tool&gt;指定的合并解析程序。有效值包括emerge，gvimdiff，kdiff3，meld，vimdiff和tortoisemerge。 运行git mergetool --tool-help 有效的&lt;工具&gt;设置列表 --tool-help # 打印可能使用的合并工具列表--tool -y, --no-prompt # 在每次调用合并解析程序之前不要提示。如果通过--tool或 merge.tool配置变量显式指定合并解析程序(默认值) --prompt # 在每次调用合并解决方案之前提示，以使用户有机会跳过该路径 -O&lt;orderfile&gt; # 按照&lt;orderfile&gt;中指定的顺序处理文件，每行有一个shell glob模式 log 命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103语法： git log [&lt;options&gt;] [&lt;revision range&gt;] [[\\--] &lt;path&gt;…​] 选项： --follow # 继续列出除重命名之外的文件历史记录（仅适用于单个文件） --no-decorate, --decorate[&#x3D;short|full|auto|no] # 打印出任何提交的ref名称 --decorate-refs&#x3D;&lt;pattern&gt;, --decorate-refs-exclude&#x3D;&lt;pattern&gt; # 如果没有--decorate-refs给出，假装所有参考文献都包含在内 --source # 打印在每个提交到达的命令行上给出的ref名称 --use-mailmap # 使用邮件地图文件将作者和提交者姓名和电子邮件地址映射到规范的实名和电子邮件地址 --full-diff # 没有此标志，git log -p &lt;path&gt;...显示提交触摸指定的路径，并且差异关于相同指定的路径 --log-size # 在每个提交的输出中包含一行“log size &lt;number&gt;”，其中&lt;number&gt;是该提交消息的长度（以字节为单位） -L &lt;start&gt;,&lt;end&gt;:&lt;file&gt;, -L :&lt;funcname&gt;:&lt;file&gt; # 跟踪&lt;file&gt;中由“&lt;start&gt;，&lt;end&gt;”（或函数名称regex &lt;funcname&gt;）给出的行范围的演变 &lt;revision range&gt; # 仅显示指定修订范围内的提交 [\\--] &lt;path&gt;…​ # 仅显示足以解释如何匹配指定路径的文件的提交 提交限制： -&lt;number&gt;, -n &lt;number&gt;, --max-count&#x3D;&lt;number&gt; # 限制提交输出的数量 --skip&#x3D;&lt;number&gt; # 在开始显示提交输出之前跳过数字提交 --since&#x3D;&lt;date&gt;, --after&#x3D;&lt;date&gt; # 显示比特定日期更近的提交 --until&#x3D;&lt;date&gt;, --before&#x3D;&lt;date&gt; # 显示比特定日期更早的提交 --author&#x3D;&lt;pattern&gt;, --committer&#x3D;&lt;pattern&gt; # 将提交输出限制为与指定模式（正则表达式）匹配的作者&#x2F;提交者标题行 --grep-reflog&#x3D;&lt;pattern&gt; # 将提交输出限制为具有与指定模式（正则表达式）匹配的reflog条目的提交输出 --grep&#x3D;&lt;pattern&gt; # 将提交输出限制为符合指定模式（正则表达式）的日志消息 --all-match # 将提交输出限制为匹配所有给定的提交--grep，而不是至少匹配一个提交 --invert-grep # 将提交输出限制为与日志消息不匹配的模式--grep&#x3D;&lt;pattern&gt; -i, --regexp-ignore-case # 匹配正则表达式限制模式而不考虑字母大小写 --basic-regexp # 考虑限制模式是基本的正则表达式; 这是默认值 -E, --extended-regexp # 考虑限制模式是扩展正则表达式而不是默认的基本正则表达式 -F, --fixed-strings # 考虑限制模式为固定字符串（不要将模式解释为正则表达式） -P, --perl-regexp # 考虑限制模式是与Perl兼容的正则表达式 --remove-empty # 当给定的路径从树上消失时停止 --merges # 仅打印合并提交。这完全一样--min-parents&#x3D;2 --no-merges # 不要打印与多个父代的提交。这完全一样--max-parents&#x3D;1 --min-parents&#x3D;&lt;number&gt;, --max-parents&#x3D;&lt;number&gt; # 仅显示至少（或至多）多次父级提交的提交 --no-min-parents, --no-max-parents # --no-min-parents并--no-max-parents重新设置这些限制（无限制） --first-parent # 在查看合并提交后，只跟踪第一个父提交 --not # 反转的意思^前缀（或缺乏）的所有后续修订说明符，到下一个--not --all # 假设所有的参考文件refs&#x2F;，以及HEAD命令行都列为&lt;commit&gt; --branches[&#x3D;&lt;pattern&gt;] # 假设所有的参数refs&#x2F;heads都在命令行上列为&lt;commit&gt;。如果给定&lt;pattern&gt;，则将分支限制为与给定shell glob匹配的分支 --tags[&#x3D;&lt;pattern&gt;] # 假设所有的参数refs&#x2F;tags都在命令行上列为&lt;commit&gt;。如果给出&lt;pattern&gt;，则将标记限制为与给定shell glob相匹配的标记 --remotes[&#x3D;&lt;pattern&gt;] # 假设所有的参数refs&#x2F;remotes都在命令行上列为&lt;commit&gt;。如果给出&lt;pattern&gt;，则将远程跟踪分支限制为与给定shell glob匹配的分支 --glob&#x3D;&lt;glob-pattern&gt; # 假设所有与shell glob &lt;glob-pattern&gt;匹配的ref 在命令行中都以&lt;commit&gt;列出。前导refs &#x2F;，如果缺失，将自动添加前缀 --exclude&#x3D;&lt;glob-pattern&gt; # 不包括裁判匹配&lt;水珠图案&gt;，未来--all， --branches，--tags，--remotes，或--glob原本考虑 --reflog # 假设所有reflog提到的对象都在命令行中列为&lt;commit&gt; --single-worktree # 默认情况下，所有工作的树木将被下面的选项时，有一个以上--all，--reflog和 --indexed-objects。该选项强制他们仅检查当前工作树 --ignore-missing # 在输入中看到一个无效的对象名称时，假装没有给出错误的输入 --bisect # 假装好坏的二等分参考文献refs&#x2F;bisect&#x2F;bad 被列出，并且仿佛它被跟随，--not并且良好的平分参考refs&#x2F;bisect&#x2F;good-*命令行 --stdin # 除了命令行上列出的&lt;commit&gt;之外，还可以从标准输入中读取它们。如果--看到分隔符，请停止读取提交并开始读取路径以限制结果 --cherry-mark # 像--cherry-pick（见下面）但标记等价提交&#x3D;而不是省略它们，而不等价的提交+ --cherry-pick # 当提交集合受到对称差异限制时，省略任何提交引入与“另一侧”上的另一个提交相同的更改的提交 --left-only, --right-only # 列表仅在对称差异的相应侧提交，即只有那些将被标记&lt;为resp的列表。&gt;通过 --left-right --cherry # 的代名词--right-only --cherry-mark --no-merges; 有用的是将输出限制在我们这边的提交中，并将那些已经应用到 分叉历史的另一边的标记标记为 git log --cherry upstream...mybranch类似于 git cherry upstream mybranch -g, --walk-reflogs # 而不是走提交祖先链，将reflog条目从最近的一条走到更旧的条目 --merge # 合并失败后，显示引用文件有冲突并且不存在于所有合并头上 --boundary # 输出排除边界提交。边界提交以前缀- 历史简化： &lt;paths&gt; # 提交修改给定的&lt;路径&gt;被选中 --simplify-by-decoration # 由某个分支或标签引用的提交被选中 Default mode # 将历史简化为解释树的最终状态的最简单历史记录 --full-history # 与默认模式相同，但不修剪某些历史记录 --dense # 只显示选定的提交，另外一些提供有意义的历史记录 --sparse # 显示简化历史记录中的所有提交 --simplify-merges # 附加选项可--full-history从结果历史记录中删除一些不必要的合并，因为没有选定的提交对此合并作出贡献 --ancestry-path # 当给定一个范围提交的显示（例如commit1..commit2 或commit2 ^ commit1）， 只直接存在于之间的祖先链显示提交commit1和 commit2，即提交属于的两个后代commit1，和祖先commit2提交订单： --date-order # 在显示所有孩子之前不显示父母，但在提交时间戳顺序中显示提交 --author-date-order # 在显示所有孩子之前不显示父母，但以作者时间戳顺序显示提交 --topo-order # 在显示所有孩子之前不要显示父母，并且避免在多行历史记录中混合显示提交 --reverse # 以相反顺序输出选择显示的提交。不能与之结合 --walk-reflogs对象遍历： --no-walk[&#x3D;(sorted|unsorted)] # 只显示给定的提交，但不要遍历其祖先。如果指定了范围，则这不起作用。如果提供了参数 unsorted， 则提交按照它们在命令行上的顺序显示。否则（如sorted没有给参数），提交按提交时间以反向时间顺序显示。不能与之结合--graph --do-walk # 覆盖以前--no-walk提交格式： --pretty[&#x3D;&lt;format&gt;], --format&#x3D;&lt;format&gt; # 漂亮地打印在提交日志的内容在给定的格式，其中&lt;格式&gt;可以是一个ONELINE，短，中等，充分，更全面的，电子邮件，原料，格式：&lt;字符串&gt; 和tformat：&lt;字符串&gt; --abbrev-commit # 不显示完整的40字节十六进制提交对象名称，只显示部分前缀 --no-abbrev-commit # 显示完整的40字节十六进制提交对象名称。这种否定 --abbrev-commit和暗示它的选项如“--oneline” --oneline # 这是一起使用的“--pretty &#x3D; oneline --abbrev-commit”的缩写 --encoding&#x3D;&lt;encoding&gt; # 提交对象在其编码头中记录用于日志消息的编码; 这个选项可以用来告诉命令在用户首选的编码中重新编写提交日志消息 --expand-tabs&#x3D;&lt;n&gt;, --expand-tabs, --no-expand-tabs # 在输出中显示日志消息之前，执行一个选项卡扩展（将每个选项卡用足够的空格替换，以填充日志消息中的倍数为&lt;n&gt;的下一个显示列） --notes[&#x3D;&lt;treeish&gt;] # 在显示提交日志消息时，显示注释提交的注释 --no-notes # 不要显示笔记 --show-signature # 通过签名传递gpg --verify并显示输出来检查签名提交对象的有效性 --relative-date # 的同义词--date&#x3D;relative --date&#x3D;&lt;format&gt; # 仅对以人可读格式显示的日期生效，例如在使用时--pretty。log.dateconfig变量为log命令的--date选项设置一个默认值 --parents # 也打印提交的父母（以“commit parent ...”的形式） --children # 也打印提交的子代（以“commit child ...”的形式） --left-right # 标记可以从中提交提交的对称差异的哪一侧。来自左侧的提交将以前面的&lt;和前面的提交&gt;。如果合并--boundary，那些提交前缀为- --graph # 在输出的左侧绘制提交历史记录的基于文本的图形表示 --show-linear-break[&#x3D;&lt;barrier&gt;] # 当不使用--graph时，所有历史分支都会变平，这使得很难看到两个连续的提交不属于线性分支区分格式： -c # 使用此选项，合并提交的差异输出会同时显示每个父级与合并结果的差异，而不是显示父级与每次结果之间的pairwise差异 --cc # 这个标志意味着这个-c选项，并通过省略父母内容只有两个变体的无趣hunk来进一步压缩补丁输出，并且合并结果不加修改地选择其中的一个 -m # 这个标志使得合并提交显示了像常规提交一样的完整差异; 对于每个合并父项，会生成一个单独的日志条目和diff -r # 显示递归差异 -t # 在diff输出中显示树对象。这意味着-r stash 命令1234567891011121314151617181920212223242526语法： git stash list [&lt;options&gt;] git stash show [&lt;stash&gt;] git stash drop [-q|--quiet] [&lt;stash&gt;] git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;] git stash branch &lt;branchname&gt; [&lt;stash&gt;] git stash [push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet] [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;] [--] [&lt;pathspec&gt;…​]] git stash clear git stash create [&lt;message&gt;] git stash store [-m|--message &lt;message&gt;] [-q|--quiet] &lt;commit&gt;选项： push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet] [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;] [--] [&lt;pathspec&gt;…​] # 将您的本地修改保存到新的存储条目中，并将它们回滚到HEAD（在工作树和索引中） list [&lt;options&gt;] # 列出您当前拥有的存储条目 show [&lt;stash&gt;] # 显示存储条目中记录的更改，作为隐藏内容和提交首次创建存储条目时的提交之间的差异 pop [--index] [-q|--quiet] [&lt;stash&gt;] # 从存储列表中删除一个单独的存储状态并将其应用于当前工作树状态的顶部，即进行反操作git stash push。工作目录必须与索引匹配 apply [--index] [-q|--quiet] [&lt;stash&gt;] # 喜欢pop，但不要从存储列表中删除状态。不像pop， &lt;stash&gt;可能是任何看起来像由stash pushor 创建的提交 stash create branch &lt;branchname&gt; [&lt;stash&gt;] # 创建并检出&lt;branchname&gt;从&lt;stash&gt;最初创建的提交开始的新分支，将记录的更改应用&lt;stash&gt;到新的工作树和索引 clear # 删除所有的存储条目 drop [-q|--quiet] [&lt;stash&gt;] # 从存储条目列表中删除单个存储条目。如果没有&lt;stash&gt;给出，它将删除最新的一个 create # 创建一个存储条目（这是一个常规的提交对象）并返回它的对象名称，而不将它存储在ref命名空间的任何位置 store # 在存储引用中存储通过git stash create（这是一个悬挂的合并提交）创建的给定存储，更新存储引用日志 tag 命令1234567891011121314151617181920212223242526272829303132333435语法： git tag [-a | -s | -u &lt;keyid&gt;] [-f] [-m &lt;msg&gt; | -F &lt;file&gt;] [-e] &lt;tagname&gt; [&lt;commit&gt; | &lt;object&gt;] git tag -d &lt;tagname&gt;…​ git tag [-n[&lt;num&gt;]] -l [--contains &lt;commit&gt;] [--no-contains &lt;commit&gt;] [--points-at &lt;object&gt;] [--column[&#x3D;&lt;options&gt;] | --no-column] [--create-reflog] [--sort&#x3D;&lt;key&gt;] [--format&#x3D;&lt;format&gt;] [--[no-]merged [&lt;commit&gt;]] [&lt;pattern&gt;…​] git tag -v [--format&#x3D;&lt;format&gt;] &lt;tagname&gt;…​选项： -a, --annotate # 制作一个未签名的带注释的标签对象 -s, --sign # 使用默认的电子邮件地址密钥创建一个GPG签名的标签 -u &lt;keyid&gt;, --local-user&#x3D;&lt;keyid&gt; # 使用给定的密钥创建一个GPG签名的标签 -f, --force # 用给定名称替换现有标签（而不是失败） -d, --delete # 用给定名称删除现有标签 -v, --verify # 验证给定标签名称的GPG签名 -n&lt;num&gt; # &lt;num&gt;指定在使用-l时打印多少行（如果有）。意味着--list -l, --list # 列表标签 --sort&#x3D;&lt;key&gt; # 根据给定的关键字进行排序。前缀-按值的降序进行排序 -i, --ignore-case # 排序和过滤标签不区分大小写 --column[&#x3D;&lt;options&gt;], --no-column # 在列中显示标签列表 --contains [&lt;commit&gt;] # 只列出包含指定提交的标签（如果未指定，则为HEAD）。意味着--list --no-contains [&lt;commit&gt;] # 只列出不包含指定提交的标签（如果未指定，则为HEAD）。意味着--list --merged [&lt;commit&gt;] # 仅列出可从提交的提交（HEAD如果未指定）可访问的列表标记，与之不兼容--no-merged --no-merged [&lt;commit&gt;] # 仅列出其提交无法从指定提交（HEAD如果未指定）到达的标记，与之不兼容--merged --points-at &lt;object&gt; # 只列出给定对象的标签（HEAD，如果未指定）。意味着--list -m &lt;msg&gt;, --message&#x3D;&lt;msg&gt; # 使用给定的标签消息（而不是提示） -F &lt;file&gt;, --file&#x3D;&lt;file&gt; # 从给定的文件中获取标签消息。使用-从标准输入中读取消息。 -e, --edit # 从带有-F和命令行的 文件中获取的消息-m通常用作未经修改的标记消息 --cleanup&#x3D;&lt;mode&gt; # 该选项设置标签消息的清理方式 --create-reflog # 为标签创建一个reflog &lt;tagname&gt; # 要创建，删除或描述的标记的名称 &lt;commit&gt;, &lt;object&gt; # 新标签将引用的对象，通常是提交。默认为HEAD &lt;format&gt; # %(fieldname)从显示的标记ref和指向的对象中插入一个字符串 worktree 命令12345678910111213141516171819202122232425262728293031语法： git worktree add [-f] [--detach] [--checkout] [--lock] [-b &lt;new-branch&gt;] &lt;path&gt; [&lt;commit-ish&gt;] git worktree list [--porcelain] git worktree lock [--reason &lt;string&gt;] &lt;worktree&gt; git worktree move &lt;worktree&gt; &lt;new-path&gt; git worktree prune [-n] [-v] [--expire &lt;expire&gt;] git worktree remove [--force] &lt;worktree&gt; git worktree unlock &lt;worktree&gt;选项： add &lt;path&gt; [&lt;commit-ish&gt;] # 创建&lt;path&gt;并签&lt;commit-ish&gt;出 list # 列出每个工作树的详细信息 lock # 如果工作树位于便携式设备或网络共享上，且该共享并非始终挂载，请将其锁定以防止其管理文件被自动修剪 move # 将工作树移到新位置 prune # 修剪$ GIT_DIR &#x2F; worktrees中的修剪树信息 remove # 删除一棵工作树。只有干净的工作树（没有未跟踪的文件，并且没有修改跟踪的文件）可以被删除 unlock # 解锁一个工作树，允许它被修剪，移动或删除 -f, --force # 默认情况下，add拒绝创建一个新的工作树，当它 &lt;commit-ish&gt;是一个分支名称并且已经被另一个工作树签出并remove拒绝删除不干净的工作树时 -b &lt;new-branch&gt;, -B &lt;new-branch&gt; # 用add，创建一个名为&lt;new-branch&gt;起始处 的新分支&lt;commit-ish&gt;，并检查&lt;new-branch&gt;新的工作树 --detach # 随着add，在新的工作树中分离HEAD --[no-]checkout # 默认情况下，add检查出来&lt;commit-ish&gt;，但--no-checkout可以用来抑制，以进行自定义，如配置稀疏结帐结帐 --[no-]guess-remote # 与worktree add &lt;path&gt;没有，&lt;commit-ish&gt;而不是创建从HEAD一个新的分支，如果存在在恰好一个远程匹配的 基本名称的跟踪分支&lt;path&gt;，立足于远程跟踪分支的新分支，并标记远程跟踪分支为“上游”来自新的分支 --[no-]track # 创建新分支时，如果&lt;commit-ish&gt;是分支，则将其标记为新分支中的“上游” --lock # 创建后保持工作树锁定 -n, --dry-run # 随着prune，不要删除任何东西; 只是报告它会删除什么 --porcelain # 使用list，输出脚本的易于解析的格式 -v, --verbose # 随着prune，报告所有清除 --expire &lt;time&gt; # 使用时prune，只会使&lt;age&gt;以前的未使用的工作树过期 --reason &lt;string&gt; # 随着lock，为什么工作树被锁定的解释 &lt;worktree&gt; # 工作树可以通过相对路径或绝对路径来标识 fetch 命令12345678910111213141516171819202122232425262728293031323334353637383940语法： git fetch [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…​]] git fetch [&lt;options&gt;] &lt;group&gt; git fetch --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)…​] git fetch --all [&lt;options&gt;]选项： --all # 取回所有遥控器 -a, --append # 追加refs的ref名称和对象名称到现有的内容.git&#x2F;FETCH_HEAD。 --depth&#x3D;&lt;depth&gt; # 将提取限制为从每个远程分支历史记录的提示中指定的提交数量 --deepen&#x3D;&lt;depth&gt; # 与--depth相似，只是它指定了来自当前浅边界而不是每个远程分支历史记录的提示的提交数 --shallow-since&#x3D;&lt;date&gt; # 加深或缩短浅储存库的历史记录，以便在&lt;date&gt;之后包含所有可访问的提交 --shallow-exclude&#x3D;&lt;revision&gt; # 加深或缩短浅储存库的历史记录，以排除可从指定的远程分支或标记访问的提交 --unshallow # 如果源存储库已完成，请将浅层存储库转换为完整存储库，以消除浅存储库施加的所有限制 --update-shallow # 默认情况下，从浅仓库中获取时， git fetch拒绝需要更新.git&#x2F;shallow的引用 --dry-run # 显示将做什么，不做任何改变 -f, --force # 当git fetch与&lt;rbranch&gt;:&lt;lbranch&gt; refspec一起使用时，它拒绝更新本地分支， &lt;lbranch&gt;除非&lt;rbranch&gt;它获取的远程分支是子孙的后代&lt;lbranch&gt; -k, --keep # 保持下载的包 --multiple # 允许指定多个&lt;repository&gt;和&lt;group&gt;参数 -p, --prune # 在提取之前，请删除远程不再存在的所有远程跟踪参考 -P, --prune-tags # 在获取之前，删除--prune已启用的远程不再存在的所有本地标记 -n, --no-tags # 默认情况下，指向从远程存储库下载的对象的标签将在本地​​获取并存储 --refmap&#x3D;&lt;refspec&gt; # 在获取命令行中列出的ref时，使用指定的refspec（可以多次提供）将ref映射到远程跟踪分支，而不是remote.*.fetch远程存储库的配置变量的值 -t, --tags # 从远程获取所有标签（即，将远程标签获取 refs&#x2F;tags&#x2F;*到具有相同名称的本地标签中），除此之外的任何其他内容都将被提取 --recurse-submodules[&#x3D;yes|on-demand|no] # 此选项控制是否以及在什么条件下也应提取填充的子模块的新提交 -j, --jobs&#x3D;&lt;n&gt; # 用于提取子模块的并行子项的数量 --no-recurse-submodules # 禁用递归获取子模块（这与使用该--recurse-submodules&#x3D;no选项具有相同的效果） --submodule-prefix&#x3D;&lt;path&gt; # 在信息消息（如“获取子模块foo”）中打印路径前加上&lt;path&gt; --recurse-submodules-default&#x3D;[yes|on-demand] # 此选项在内部用于为--recurse-submodules选项临时提供非负的默认值 -u, --update-head-ok # 默认情况下，git fetch拒绝更新与当前分支对应的头部 --upload-pack &lt;upload-pack&gt; # 当给定时，并且从git fetch-pack处理要从中获取的存储库，--exec&#x3D;&lt;upload-pack&gt;将传递给该命令以指定在另一端运行的命令的非默认路径 -q, --quiet # 通过 - 安静的git-fetch-pack和沉默任何其他内部使用的git命令 -v, --verbose # 详细 --progress # 当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定-q -4, --ipv4 # 仅使用IPv4地址，忽略IPv6地址 -6, --ipv6 # 仅使用IPv6地址，忽略IPv4地址 &lt;repository&gt; # 作为提取或拉取操作源的“远程”存储库 &lt;group&gt; # 名称指的是存储库列表，作为配置文件中的远程数据&lt;group&gt;的值 &lt;refspec&gt; # 指定要获取哪些引用以及哪些本地引用要更新 pull 命令123456789101112131415161718192021222324252627282930313233343536373839404142434445语法： git pull [options] [&lt;repository&gt; [&lt;refspec&gt;…​]]选项： -q, --quiet # 这被传递给底层的git-fetch，以便在传输过程中压制报告，并在合并过程中将潜在的git-merge压制成静噪输出 -v, --verbose # 通过--verbose git-fetch和git-merge --[no-]recurse-submodules[&#x3D;yes|on-demand|no] # 该选项控制是否应该提取和更新所有已填充子模块的新提交与合并有关的选项： --commit， --no-commit # 执行合并并提交结果 -e, --edit, --no-edit # 在提交成功的机械合并之前调用编辑器来进一步编辑自动生成的合并消息，以便用户可以解释并验证合并 --ff # 当合并解析为快进时，只更新分支指针，而不创建合并提交。这是默认行为 --no-ff # 即使合并解析为快进，也可以创建合并提交 --ff-only # 拒绝合并并以非零状态退出，除非电流HEAD已经是最新的或合并可以解决为快进 --log[&#x3D;&lt;n&gt;], --no-log # 除了分支名称之外，还可以用来自至多&lt;n&gt;实际提交的单行描述来填充日志消息 --stat, -n, --no-stat # 在合并结束时显示diffstat。diffstat也由配置选项merge.stat控制 --squash, --no-squash # 生成工作树和索引状态，就像发生真正的合并（合并信息除外）一样，但实际上并未进行提交， 移动HEAD或记录$GIT_DIR&#x2F;MERGE_HEAD （以导致下一个git commit命令创建合并提交） -s &lt;strategy&gt;, --strategy&#x3D;&lt;strategy&gt; # 使用给定的合并策略; 可以多次提供，以按照他们应该尝试的顺序指定它们 -X &lt;option&gt;, --strategy-option&#x3D;&lt;option&gt; # 将合并策略特定选项传递给合并策略 --verify-signatures, --no-verify-signatures # 验证被合并的分支的提示提交是否使用有效密钥进行签名，即具有有效uid的密钥：在默认信任模型中，这意味着签名密钥已由可信密钥签名 --allow-unrelated-histories # 默认情况下，git merge命令拒绝合并不共享祖先的历史记录 -r, --rebase[&#x3D;false|true|preserve|interactive] # 如果为true，则在获取后重新绑定上游分支顶部的当前分支 --no-rebase # 早先覆盖--rebase --autostash, --no-autostash # 在开始rebase之前，如果需要，将局部修改隐藏起来，并在完成时应用存储条目与抓取相关的选项: --all # 取回所有遥控器 -a, --append # 追加refs的ref名称和对象名称到现有的内容.git&#x2F;FETCH_HEAD --depth&#x3D;&lt;depth&gt; # 将提取限制为从每个远程分支历史记录的提示中指定的提交数量 --deepen&#x3D;&lt;depth&gt; # 与--depth相似，只是它指定了来自当前浅边界而不是每个远程分支历史记录的提示的提交数 --shallow-since&#x3D;&lt;date&gt; # 加深或缩短浅储存库的历史记录，以便在&lt;date&gt;之后包含所有可访问的提交 --shallow-exclude&#x3D;&lt;revision&gt; # 加深或缩短浅储存库的历史记录，以排除可从指定的远程分支或标记访问的提交 --unshallow # 如果源存储库已完成，请将浅层存储库转换为完整存储库，以消除浅存储库施加的所有限制 --update-shallow # 默认情况下，从浅仓库中获取时， git fetch拒绝需要更新.git&#x2F;shallow的引用 -f, --force # 当git fetch与&lt;rbranch&gt;:&lt;lbranch&gt; refspec一起使用时，它拒绝更新本地分支，&lt;lbranch&gt;除非&lt;rbranch&gt;它获取的远程分支是子孙的后代&lt;lbranch&gt; -k, --keep # 保持下载的包 --no-tags # 默认情况下，指向从远程存储库下载的对象的标签将在本地​​获取并存储 -u, --update-head-ok # 默认情况下，git fetch拒绝更新与当前分支对应的头部 --upload-pack &lt;upload-pack&gt; # 当给定时，并且从git fetch-pack处理要从中获取的存储库，--exec&#x3D;&lt;upload-pack&gt;将传递给该命令以指定在另一端运行的命令的非默认路径 --progress # 当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定-q -4, --ipv4 # 仅使用IPv4地址，忽略IPv6地址 -6, --ipv6 # 仅使用IPv6地址，忽略IPv4地址 &lt;repository&gt; # 作为提取或拉取操作源的“远程”存储库 &lt;refspec&gt; # 指定要获取哪些引用以及哪些本地引用要更新 push 命令123456789101112131415161718192021222324252627282930313233343536语法： git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack&#x3D;&lt;git-receive-pack&gt;] [--repo&#x3D;&lt;repository&gt;] [-f | --force] [-d | --delete] [--prune] [-v | --verbose] [-u | --set-upstream] [--push-option&#x3D;&lt;string&gt;] [--[no-]signed|--signed&#x3D;(true|false|if-asked)] [--force-with-lease[&#x3D;&lt;refname&gt;[:&lt;expect&gt;]]] [--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…​]]选项： &lt;repository&gt; # 作为推送操作目标的“远程”存储库 &lt;refspec&gt;…​ # 用什么源对象指定要更新的目标引用 --all # 推送所有分支（即参考下refs&#x2F;heads&#x2F;）; 不能与其他&lt;refspec&gt;一起使用 --prune # 删除没有本地副本的远程分支 --mirror # 代替命名每个裁判推的，指定了下的所有参考文献refs&#x2F;（包括但不限于refs&#x2F;heads&#x2F;，refs&#x2F;remotes&#x2F;和refs&#x2F;tags&#x2F;）被镜像到远程存储库 -n, --dry-run # 除了实际发送更新之外，请做其他事 --porcelain # 生成机器可读的输出 --delete # 所有列出的ref都从远程存储库中删除 --tags # refs&#x2F;tags除了在命令行中明确列出的refspecs之外，所有refs 都将被推送 --follow-tags # 推送所有没有此选项时将被推送的引用，并且推送refs&#x2F;tags远程引用中缺少的带注释的标签，但指向可从所推送的引用访问的提交标识 --[no-]signed, --signed&#x3D;(true|false|if-asked) # GPG-签署推送请求以更新接收端的refs，以便通过钩子检查和&#x2F;或记录 --[no-]atomic # 如果可用，请在远程端使用原子事务 -o &lt;option&gt;, --push-option&#x3D;&lt;option&gt; # 将给定的字符串传送给服务器，服务器将它们传递给预接收以及接收后挂接 --receive-pack&#x3D;&lt;git-receive-pack&gt;, --exec&#x3D;&lt;git-receive-pack&gt; # 远程端上git-receive-pack程序的路径 --[no-]force-with-lease, --force-with-lease&#x3D;&lt;refname&gt;, --force-with-lease&#x3D;&lt;refname&gt;:&lt;expect&gt; # 如果远程ref的当前值是期望值，则此选项将覆盖此限制 -f, --force # 通常，该命令拒绝更新远程ref，该远程ref不是用于覆盖它的本地ref的祖先 --repo&#x3D;&lt;repository&gt; # 该选项等同于&lt;repository&gt;参数。如果两者都指定，则命令行参数优先 -u, --set-upstream # 对于最新或成功推送的每个分支，添加无参数git-pull [1]和其他命令使用的上游（跟踪）引用 --[no-]thin # 这些选项被传递给git-send-pack [1] -q, --quiet # 抑制所有输出，包括更新的引用列表，除非发生错误 -v, --verbose # 运行详细 --progress # 当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定-q --no-recurse-submodules, --recurse-submodules&#x3D;check|on-demand|only|no # 可用于所有子模块提交的修改被推到远程跟踪分支上 --[no-]verify # 切换预推钩。默认值：验证，使钩子有机会阻止推送 -4, --ipv4 # 仅使用IPv4地址，忽略IPv6地址 -6, --ipv6 # 仅使用IPv6地址，忽略IPv4地址 remote 命令123456789101112131415161718192021222324252627语法： git remote [-v | --verbose] git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror&#x3D;&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt; git remote rename &lt;old&gt; &lt;new&gt; git remote remove &lt;name&gt; git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;) git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…​ git remote get-url [--push] [--all] &lt;name&gt; git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;] git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt; git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt; git remote [-v | --verbose] show [-n] &lt;name&gt;…​ git remote prune [-n | --dry-run] &lt;name&gt;…​ git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]选项： -v, --verbose # 稍微详细一点，并在名称后显示远程URL add # 在&lt;url&gt;处添加一个名为&lt;名称&gt;的存储库 rename # 将名为&lt;old&gt;的远程重命名为&lt;new&gt;。远程的所有远程跟踪分支和配置设置都会更新 rm, remove # 删除名为&lt;名称&gt;的远程。远程的所有远程跟踪分支和配置设置均被删除 set-head # 设置或删除refs&#x2F;remotes&#x2F;&lt;name&gt;&#x2F;HEAD指定远程的默认分支（即symbolic-ref的目标） set-branches # 更改已命名远程所跟踪分支的列表 get-url # 检索远程的URL set-url # 更改远程的URL show # 给出关于远程&lt;名称&gt;的一些信息 prune # 删除与&lt;名称&gt;关联的陈旧引用 update # 按遥控器&lt;group&gt;的定义，获取存储库中一组指定遥控器的更新 submodule 命令1234567891011121314151617181920212223242526272829303132语法： git submodule [--quiet] add [&lt;options&gt;] [--] &lt;repository&gt; [&lt;path&gt;] git submodule [--quiet] status [--cached] [--recursive] [--] [&lt;path&gt;…​] git submodule [--quiet] init [--] [&lt;path&gt;…​] git submodule [--quiet] deinit [-f|--force] (--all|[--] &lt;path&gt;…​) git submodule [--quiet] update [&lt;options&gt;] [--] [&lt;path&gt;…​] git submodule [--quiet] summary [&lt;options&gt;] [--] [&lt;path&gt;…​] git submodule [--quiet] foreach [--recursive] &lt;command&gt; git submodule [--quiet] sync [--recursive] [--] [&lt;path&gt;…​] git submodule [--quiet] absorbgitdirs [--] [&lt;path&gt;…​]选项： -q, --quiet # 只打印错误消息 --all # 该选项仅对deinit命令有效。取消注册工作树中的所有子模块 -b, --branch # 将存储库的分支添加为子模块 -f, --force # 该选项仅适用于添加，删除和更新命令。在运行add时，允许添加一个否则忽略的子模块路径。 --cached # 该选项仅对状态和汇总命令有效。些命令通常使用在子模块HEAD中找到的提交，但使用此选项时，将使用存储在索引中的提交。 --files # 该选项仅对汇总命令有效。当使用此选项时，此命令会将索引中的提交与子模块HEAD中的提交进行比较。 -n, --summary-limit # 该选项仅对汇总命令有效。限制摘要大小（总共显示的提交数量） --remote # 该选项仅对更新命令有效。使用子模块的远程跟踪分支的状态，而不是使用超级项目的已记录的SHA-1来更新子模块 -N, --no-fetch # 该选项仅对更新命令有效。不要从远程站点获取新的对象。 --checkout # 该选项仅对更新命令有效。检查子模块中分离的HEAD上超级项目中记录的提交。 --merge # 该选项仅对更新命令有效。将超级项目中记录的提交合并到子模块的当前分支中。 --rebase # 该选项仅对更新命令有效。将当前分支重新映射到超级项目中记录的提交。 --init # 该选项仅对更新命令有效。在更新之前，初始化尚未调用“git子模块初始化”的所有子模块。 --name # 该选项仅对add命令有效。它将子模块的名称设置为给定字符串，而不是默认其路径。 --reference &lt;repository&gt; # 该选项仅适用于添加和更新命令。这些命令有时需要克隆远程存储库。 --recursive # 此选项仅适用于foreach，更新，状态和同步命令。递归地遍历子模块。 --depth # 该选项对添加和更新命令有效。创建一个 历史记录截断为指定修订版数的浅表副本。 --[no-]recommend-shallow # 该选项仅对更新命令有效。默认情况下，子模块的初始克隆将使用submodule.&lt;name&gt;.shallow由.gitmodules文件提供的建议 。 -j &lt;n&gt;, --jobs &lt;n&gt; # 该选项仅对更新命令有效。与多个作业并行克隆新子模块。默认为submodule.fetchJobs选项。 &lt;path&gt;…​ # 子模块的路径。指定时，将限制该命令仅对在指定路径中找到的子模块进行操作。 show 命令1234567891011121314语法： git show [options] [&lt;object&gt;…​]选项： &lt;object&gt;…​ # 要显示的对象的名称（默认为HEAD） --pretty[&#x3D;&lt;format&gt;], --format&#x3D;&lt;format&gt; # 漂亮地打印在提交日志的内容在给定的格式 --abbrev-commit # 不显示完整的40字节十六进制提交对象名称，只显示部分前缀 --no-abbrev-commit # 显示完整的40字节十六进制提交对象名称 --oneline # 这是一起使用的“--pretty &#x3D; oneline --abbrev-commit”的缩写 --encoding&#x3D;&lt;encoding&gt; # 提交对象在其编码头中记录用于日志消息的编码; 这个选项可以用来告诉命令在用户首选的编码中重新编写提交日志消息 --expand-tabs&#x3D;&lt;n&gt;, --expand-tabs, --no-expand-tabs # 在输出中显示日志消息之前，执行一个选项卡扩展（将每个选项卡用足够的空格替换，以填充日志消息中的倍数为&lt;n&gt;的下一个显示列） --notes[&#x3D;&lt;treeish&gt;] # 在显示提交日志消息时，显示注释提交的注释（请参阅git-notes [1]） --no-notes # 不要显示笔记 --show-signature # 通过签名传递gpg --verify并显示输出来检查签名提交对象的有效性 shortlog 命令12345678910111213语法： git log --pretty&#x3D;short | git shortlog [&lt;options&gt;] git shortlog [&lt;options&gt;] [&lt;revision range&gt;] [[\\--] &lt;path&gt;…​]选项： -n, --numbered # 根据每个作者的提交数量而不是作者字母顺序对输出进行排序 -s, --summary # 禁止提交描述并仅提供提交计数摘要 -e, --email # 显示每位作者的电子邮件地址 --format[&#x3D;&lt;format&gt;] # 使用一些其他信息来描述每个提交，而不是提交主题 -c, --committer # 收集并显示提交者身份而不是作者 -w[&lt;width&gt;[,&lt;indent1&gt;[,&lt;indent2&gt;]]] # 通过包装每行的输入线来包装输出width &lt;revision range&gt; # 仅显示指定修订范围内的提交 [\\--] &lt;path&gt;…​ # 只考虑足以解释如何匹配指定路径的文件的提交 describe 命令1234567891011121314151617181920语法： git describe [--all] [--tags] [--contains] [--abbrev&#x3D;&lt;n&gt;] [&lt;commit-ish&gt;…​] git describe [--all] [--tags] [--contains] [--abbrev&#x3D;&lt;n&gt;] --dirty[&#x3D;&lt;mark&gt;] git describe &lt;blob&gt;选项： &lt;commit-ish&gt;…​ # 提交对象名称来描述。如果省略，则默认为HEAD --dirty[&#x3D;&lt;mark&gt;], --broken[&#x3D;&lt;mark&gt;] # 描述工作树的状态。当工作树与HEAD匹配时，输出与“git describe HEAD”相同 --all # 不要只使用带注释的标签，而应使用refs&#x2F;名称空间中的任何参考 --tags # 不要只使用带注释的标签，而要使用refs&#x2F;tags名称空间中的任何标签 --contains # 不是找到提交之前的标签，而是找到提交之后的标签，因此包含它。自动暗示 - 标签 --abbrev&#x3D;&lt;n&gt; # 使用默认的7位十六进制数字作为缩写对象名称，而不是使用&lt;n&gt;数字或根据需要的数字来组成一个唯一的对象名称 --candidates&#x3D;&lt;n&gt; # 而不是只考虑最近的10个标签作为描述输入提交的候选者，而是考虑到候选者 --exact-match # 只输出完全匹配（一个标签直接引用提供的提交）。这是--candidates &#x3D; 0的同义词。 --debug # 精确地显示正在使用的搜索策略的信息以标准错误。标签名称仍将打印到标准输出。 --long # 即使与标签匹配，始终输出长格式（标签，提交数量和缩写提交名称） --match &lt;pattern&gt; # 只考虑与给定glob(7)模式匹配的标签，不包括“refs&#x2F;tags&#x2F;”前缀 --exclude &lt;pattern&gt; # 不要考虑与给定glob(7)模式匹配的标签，不包括“refs&#x2F;tags&#x2F;”前缀 --always # 显示唯一缩写的提交对象作为后备 --first-parent # 在查看合并提交后，只跟踪第一个父提交 apply 命令123456789101112131415161718192021222324252627282930313233343536373839语法： git apply [--stat] [--numstat] [--summary] [--check] [--index] [--3way] [--apply] [--no-add] [--build-fake-ancestor&#x3D;&lt;file&gt;] [-R | --reverse] [--allow-binary-replacement | --binary] [--reject] [-z] [-p&lt;n&gt;] [-C&lt;n&gt;] [--inaccurate-eof] [--recount] [--cached] [--ignore-space-change | --ignore-whitespace] [--whitespace&#x3D;(nowarn|warn|fix|error|error-all)] [--exclude&#x3D;&lt;path&gt;] [--include&#x3D;&lt;path&gt;] [--directory&#x3D;&lt;root&gt;] [--verbose] [--unsafe-paths] [&lt;patch&gt;…​]选项： &lt;patch&gt;…​ # 从中读取补丁的文件。 -可用于从标准输入读取 --stat # 输出diffstat代替输入补丁。关闭“适用”。 --numstat # --stat与之类似，但显示十进制表示法中添加和删除的行数以及不带缩写的路径名，以使其更加机器友好 --summary # 输出从git diff扩展头获取的信息的精简摘要，而不是应用该修补程序。关闭“适用”。 --check # 而不是应用修补程序，查看修补程序是否适用于当前工作树和&#x2F;或索引文件并检测错误。关闭“适用”。 --index # 何时--check生效或应用修补程序，请确保修补程序适用于当前索引文件记录的内容 --cached # 在不接触工作树的情况下应用补丁 -3, --3way # 如果修补程序不能干净地应用，如果修补程序记录它应该应用的斑点的标识，则回退到3路合并， 并且我们在本地可以使用这些斑点，可能会在工作树中的文件中留下冲突标记供用户解决 --build-fake-ancestor&#x3D;&lt;file&gt; # 较新的git diff输出已经 为每个blob 嵌入了索引信息，以帮助识别修补程序适用的原始版本 -R, --reverse # 反向应用补丁 --reject # 对于原子性，git默认应用会失败整个修补程序，并且在某些不适用的情况下不会触及工作树 -z # 何时--numstat给出，请勿使用路径名，但使用NUL终止的机器可读格式 -p&lt;n&gt; # 从传统差异路径中删除&lt;n&gt;引导斜杠。默认值是1。 -C&lt;n&gt; # 确保每次更改之前和之后至少有&lt;n&gt;行周围环境匹配 --unidiff-zero # 默认情况下，git apply期望所应用的修补程序是一个至少包含一行上下文的统一差异 --apply # 如果您使用上面标记为“关闭应用 ”的任何选项 ，则git应用读取并输出所请求的信息，而不实际应用修补程序 --no-add # 应用修补程序时，忽略修补程序添加的内容 --allow-binary-replacement, --binary # 从历史上看，我们不允许在未经用户明确许可的情况下应用二进制补丁，并且此标志是实现此目的的方式 --exclude&#x3D;&lt;path-pattern&gt; # 不要将更改应用于与给定路径模式匹配的文件 --include&#x3D;&lt;path-pattern&gt; # 将更改应用于与给定路径模式匹配的文件 --ignore-space-change, --ignore-whitespace # 应用修补程序时，如果需要，请忽略上下文行中空白的更改 --whitespace&#x3D;&lt;action&gt; # 应用修补程序时，检测具有空白错误的新行或修改过的行 --inaccurate-eof # 在某些情况下，diff的某些版本不能在文件末尾正确检测到缺失的新行 -v, --verbose # 将进展报告给stderr。默认情况下，只会打印有关当前正在应用的修补程序的消息 --recount # 不要相信大块头中的行数，但通过检查补丁来推断它们 --directory&#x3D;&lt;root&gt; # 将&lt;root&gt;加入所有文件名。如果还传递了“-p”参数，则在应用新根之前应用该参数 --unsafe-paths # 默认情况下，影响工作区域以外的补丁被拒绝为错误 cherry-pick 命令12345678910111213141516171819202122232425语法： git cherry-pick [--edit] [-n] [-m parent-number] [-s] [-x] [--ff] [-S[&lt;keyid&gt;]] &lt;commit&gt;…​ git cherry-pick --continue git cherry-pick --quit git cherry-pick --abort选项： &lt;commit&gt;…​ # 要获得一个更完整的拼写方法列表 -e, --edit # 使用这个选项，git cherry-pick会让你在提交之前编辑提交信息 -x # 在记录提交时，附加一条线，该行表示“(cherry从提交…)”到原始的提交消息，以指示该更改是从哪个提交的 -r # 它曾经是命令默认做-x 了上面描述，并且-r是禁用它 -m parent-number, --mainline parent-number # 通常你不能选择合并，因为你不知道合并的哪一边应该被认为是主线 -n, --no-commit # 通常，该命令会自动创建一系列提交 -s, --signoff # 在提交消息的末尾添加Signed-off-by行 -S[&lt;keyid&gt;], --gpg-sign[&#x3D;&lt;keyid&gt;] # GPG标志提交 --ff # 如果当前的HEAD与樱桃挑选的提交的父对象相同，则将执行快速转发此提交 --allow-empty # 默认情况下，樱桃选择一个空的提交将失败，表明需要显式调用git commit --allow-empty --allow-empty-message # 默认情况下，用空信息挑选提交将失败 --keep-redundant-commits # 如果在当前的历史中，如果提交的是cherry选择了重复提交，那么它将变为空的 --strategy&#x3D;&lt;strategy&gt; # 使用给定的合并策略。只能使用一次 -X&lt;option&gt;, --strategy-option&#x3D;&lt;option&gt; # 将合并策略特定选项传递给合并策略 --continue # 继续使用.git&#x2F;sequencer中的信息进行操作 --quit # 忘记当前正在进行的操作 --abort # 取消操作并返回到预序列状态 rebase 命令12345678910111213141516171819202122232425262728293031323334353637383940414243语法： git rebase [-i | --interactive] [options] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;] [&lt;upstream&gt; [&lt;branch&gt;]] git rebase [-i | --interactive] [options] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;] --root [&lt;branch&gt;] git rebase --continue | --skip | --abort | --quit | --edit-todo | --show-current-patch 选项： --onto &lt;newbase&gt; # 创建新提交的起点 &lt;upstream&gt; # 上游分支进行比较。可以是任何有效的提交，而不仅仅是现有的分支名称。默认为当前分支的配置上游 &lt;branch&gt; # 工作分部; 默认为HEAD --continue # 解决了合并冲突后重新启动重新绑定过程 --abort # 中止rebase操作并将HEAD重置为原始分支 --quit # 放弃rebase操作，但HEAD不会重置回原始分支。索引和工作树也因此保持不变 --keep-empty # 在结果中保留不改变父项的任何提交 --allow-empty-message # 默认情况下，重新绑定提交空信息将失败 --skip # 通过跳过当前补丁重新启动重新绑定过程 --edit-todo # 在交互式重新绑定期间编辑待办事项列表 --show-current-patch # 在交互式底图中显示当前的补丁，或者由于冲突而停止底牌。这相当于 git show REBASE_HEAD -m, --merge # 使用合并策略来重新分配 -s &lt;strategy&gt;, --strategy&#x3D;&lt;strategy&gt; # 使用给定的合并策略 -X &lt;strategy-option&gt;, --strategy-option&#x3D;&lt;strategy-option&gt; # 将&lt;strategy-option&gt;传递给合并策略 -S[&lt;keyid&gt;], --gpg-sign[&#x3D;&lt;keyid&gt;] # GPG标志提交 -q, --quiet # 安静。意味着 - 无统计 -v, --verbose # 详细。意味着--stat -stat # 显示自上次rebase以来上游变化的差异。diffstat也由配置选项rebase.stat控制 -n, --no-stat # 不要将diffstat显示为rebase过程的一部分 --no-verify # 此选项绕过预先重新绑定钩子 --verify # 允许预重贴挂钩运行，这是默认设置 -C&lt;n&gt; # 确保每次更改之前和之后至少有&lt;n&gt;行周围环境匹配 -f, --force-rebase # 即使当前分支是最新的，并且--force没有做任何事情的命令也不会返回，强制重新分配 --fork-point, --no-fork-point # 计算&lt;branch&gt;引入的提交时，使用reflog可以在&lt;upstream&gt;和&lt;branch&gt;之间找到更好的共同祖先 --ignore-whitespace, --whitespace&#x3D;&lt;option&gt; # 这些标志被传递给应用该补丁的git apply程序。与--interactive选项不兼容 --committer-date-is-author-date, --ignore-date # 这些标志被传递给git am以轻松地改变重新发布的提交的日期。与--interactive选项不兼容。 --signoff # 这个标志被传递给git am签署所有重新提交的提交。与--interactive选项不兼容。 -i, --interactive # 列出将要重新分配的提交列表。让用户在重新绑定之前编辑该列表 -p, --preserve-merges # 重新创建合并提交，而不是通过重播合并提交引入的提交来平坦化历史 -x &lt;cmd&gt;, --exec &lt;cmd&gt; # 在每行在最终历史记录中创建提交后附加“exec &lt;cmd&gt;”。&lt;cmd&gt;将被解释为一个或多个shell命令 --root # 重新规划从&lt;branch&gt;可访问的所有提交，而不是用&lt;upstream&gt;限制它们 --autosquash, --no-autosquash # 当提交日志消息以“squash！...”（或“fixup！...”）开始时，并且在待办事项列表中已经有一个与之相匹配的提交时...， 会自动修改rebase -i的待办事项列表，以便被标记为压扁的提交在提交被修改后立即出现，并将被提交的提交的操作从（或）pick改为 --autostash, --no-autostash # 在操作开始之前自动创建临时存储条目，并在操作结束后应用它 --no-ff # 与-interactive，cherry-pick所有基于rebased的提交，而不是快速转发到未更改的 revert 命令12345678910111213141516171819语法： git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&lt;keyid&gt;]] &lt;commit&gt;…​ git revert --continue git revert --quit git revert --abort选项： &lt;commit&gt;…​ # 承诺恢复。有关拼写提交名称的更完整列表 -e, --edit # 使用这个选项，git revert可以让你在提交恢复之前编辑提交信息 -m parent-number, --mainline parent-number # 通常您无法恢复合并，因为您不知道合并的哪一方应被视为主线 --no-edit # 使用这个选项，git revert不会启动提交消息编辑器 -n, --no-commit # 通常，该命令会自动创建一些提交日志消息，提交哪些提交已恢复 -S[&lt;keyid&gt;], --gpg-sign[&#x3D;&lt;keyid&gt;] # GPG标志提交。该keyid参数是可选的，并且默认为提交者身份; 如果指定，它必须粘贴到选项没有空格。 -s, --signoff # 在提交消息的末尾添加Signed-off-by行 --strategy&#x3D;&lt;strategy&gt; # 使用给定的合并策略 -X&lt;option&gt;, --strategy-option&#x3D;&lt;option&gt; # 将合并策略特定选项传递给合并策略 --continue # 继续使用.git&#x2F;sequencer中的信息进行操作 --quit # 忘记当前正在进行的操作。可用于在失败的cherry-pick或还原后清除排序器状态 --abort # 取消操作并返回到预序列状态 bisect 命令1234567891011121314151617语法： git bisect &lt;subcommand&gt; &lt;options&gt; git bisect start [--term-&#123;old,good&#125;&#x3D;&lt;term&gt; --term-&#123;new,bad&#125;&#x3D;&lt;term&gt;] [--no-checkout] [&lt;bad&gt; [&lt;good&gt;...]] [--] [&lt;paths&gt;...] git bisect (bad|new|&lt;term-new&gt;) [&lt;rev&gt;] git bisect (good|old|&lt;term-old&gt;) [&lt;rev&gt;...] git bisect terms [--term-good | --term-bad] git bisect skip [(&lt;rev&gt;|&lt;range&gt;)...] git bisect reset [&lt;commit&gt;] git bisect (visualize|view) git bisect replay &lt;logfile&gt; git bisect log git bisect run &lt;cmd&gt;... git bisect help选项： --no-checkout # 在平分过程的每次迭代中，不要签出新的工作树 blame 命令123456789101112131415161718192021222324252627282930313233语法： git blame [-c] [-b] [-l] [--root] [-t] [-f] [-n] [-s] [-e] [-p] [-w] [--incremental] [-L &lt;range&gt;] [-S &lt;revs-file&gt;] [-M] [-C] [-C] [-C] [--since&#x3D;&lt;date&gt;] [--progress] [--abbrev&#x3D;&lt;n&gt;] [&lt;rev&gt; | --contents &lt;file&gt; | --reverse &lt;rev&gt;..&lt;rev&gt;] [--] &lt;file&gt;选项： -b # 显示边界提交的空白SHA-1。这也可以通过blame.blankboundary配置选项来控制 --root # 不要将根提交视为边界。这也可以通过blame.showRoot配置选项来控制 --show-stats # 在责备输出结尾包含更多统计数据 -L &lt;start&gt;, &lt;end&gt;, -L :&lt;funcname&gt; # 仅注释给定的线范围。可以多次指定。重叠范围是允许的 -l # 显示长时间（默认：关闭） -t # 显示原始时间戳（默认值：关闭） -S &lt;revs-file&gt; # 使用revs-file中的修订版而不是调用git-rev-list [1] --reverse &lt;rev&gt;..&lt;rev&gt; # 前进而不是后退。它不是显示一行出现的修订，而是显示一行存在的最后修订 -p, --porcelain # 以设计用于机器消耗的格式显示 --line-porcelain # 显示porcelain格式，但输出每行的提交信息，而不仅仅是第一次引用提交 --incremental # 以设计用于机器消耗的格式逐步显示结果 --encoding&#x3D;&lt;encoding&gt; # 指定用于输出作者姓名和提交摘要的编码。将其设置为none使责备输出未转换的数据 --contents &lt;file&gt; # 当未指定&lt;rev&gt;时，该命令注释从工作树副本向后开始的更改 --date &lt;format&gt; # 指定用于输出日期的格式 --[no-]progress # 当连接到终端时，默认情况下标准错误流会报告进度状态 -M[&lt;num&gt;] # 检测文件中移动或复制的行 -C[&lt;num&gt;] # 除了-M检测从同一提交中修改的其他文件移动或复制的行之外 -h # 显示帮助信息 -c # 使用与git-annotate [1]相同的输出模式（默认值：关闭） --score-debug # 包含与文件之间的行移动有关的调试信息和文件中移动的行 -f, --show-name # 在原始提交中显示文件名 -n, --show-number # 在原始提交中显示行号（默认值：关闭） -s # 从输出中抑制作者姓名和时间戳 -e, --show-email # 显示作者电子邮件而不是作者姓名（默认：关闭） -w # 在比较父版本和子版本时，忽略空白，并找出这些行来自哪里 --abbrev&#x3D;&lt;n&gt; # 使用默认的7 + 1十六进制数字作为缩写对象名称，而不是使用&lt;n&gt; +1个数字 grep 命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465语法： git grep [-a | --text] [-I] [--textconv] [-i | --ignore-case] [-w | --word-regexp] [-v | --invert-match] [-h|-H] [--full-name] [-E | --extended-regexp] [-G | --basic-regexp] [-P | --perl-regexp] [-F | --fixed-strings] [-n | --line-number] [-l | --files-with-matches] [-L | --files-without-match] [(-O | --open-files-in-pager) [&lt;pager&gt;]] [-z | --null] [-c | --count] [--all-match] [-q | --quiet] [--max-depth &lt;depth&gt;] [--color[&#x3D;&lt;when&gt;] | --no-color] [--break] [--heading] [-p | --show-function] [-A &lt;post-context&gt;] [-B &lt;pre-context&gt;] [-C &lt;context&gt;] [-W | --function-context] [--threads &lt;num&gt;] [-f &lt;file&gt;] [-e] &lt;pattern&gt; [--and|--or|--not|(|)|-e &lt;pattern&gt;…​] [--recurse-submodules] [--parent-basename &lt;basename&gt;] [ [--[no-]exclude-standard] [--cached | --no-index | --untracked] | &lt;tree&gt;…​] [--] [&lt;pathspec&gt;…​]选项： --cached # 在平分过程的每次迭代中，不要签出新的工作树 --no-index # 搜索当前目录中不受Git管理的文件 --untracked # 除了在工作树中跟踪文件中搜索外，还可以在未跟踪文件中搜索 --no-exclude-standard # 通过不尊重.gitignore 机制来搜索被忽略的文件。只用于--untracked --exclude-standard # 不要关注通过.gitignore 机制指定的忽略文件，仅在使用当前目录搜索文件时有用--no-index --recurse-submodules # 递归搜索已在存储库中初始化并检出的每个子模块 -a, --text # 像处理文本一样处理二进制文件 --textconv # 尊重textconv过滤器设置 --no-textconv # 不要兑现textconv过滤器设置。这是默认设置 -i, --ignore-case # 忽略模式和文件之间的大小写区别 -I # 不匹配二进制文件中的模式 --max-depth &lt;depth&gt; # 对于命令行中给出的每个&lt;pathspec&gt;，最多下降&lt;depth&gt;级别的目录 -w, --word-regexp # 仅在字边界处匹配模式 -v, --invert-match # 选择不匹配的行 -h, -H # 默认情况下，该命令显示每个匹配的文件名 --full-name # 从子目录运行时，该命令通常会输出相对于当前目录的路径 -E, --extended-regexp, -G, --basic-regexp # 对于模式使用POSIX扩展&#x2F;基本正则表达式。默认是使用基本的正则表达式 -P, --perl-regexp # 为模式使用Perl兼容的正则表达式 -F, --fixed-strings # 使用固定字符串模式 -n, --line-number # 在行号前加上匹配的行 -l, --files-with-matches, --name-only, -L, --files-without-match # 不显示每条匹配的行，只显示包含（或不包含）匹配的文件的名称 -O[&lt;pager&gt;], --open-files-in-pager[&#x3D;&lt;pager&gt;] # 打开寻呼机中的匹配文件（不是grep的输出） -z, --null # 输出\\ 0而不是通常跟在文件名后的字符 -c, --count # 显示匹配的行数，而不是显示每条匹配的行 --color[&#x3D;&lt;when&gt;] # 显示彩色的比赛。该值必须始终（默认），永不，或自动 --no-color # 关闭匹配突出显示，即使配置文件将默认设置为彩色输出。和...一样--color&#x3D;never --break # 在不同文件的匹配之间打印空行 --heading # 在文件的上方显示文件名，而不是在每个显示的行的开头 -p, --show-function # 显示包含匹配函数名称的上一行，除非匹配行是函数名称本身 -&lt;num&gt;, -C &lt;num&gt;, --context &lt;num&gt; # 显示&lt;num&gt;前导和尾部线条，并放置包含--连续的匹配组之间的线条 -A &lt;num&gt;, --after-context &lt;num&gt; # 显示&lt;num&gt;尾随线，并--在连续的匹配组之间放置一行 -B &lt;num&gt;, --before-context &lt;num&gt; # 显示&lt;num&gt;引出线，并--在相邻的匹配组之间放置一行 -W, --function-context # 显示前一行中包含函数名称的周围文本，直到下一个函数名称之前的文本，从而有效地显示找到匹配的整个函数 --threads &lt;num&gt; # 要使用的grep工作线程数 -f &lt;file&gt; # 从&lt;file&gt;中读取模式，每行一个 -e # 下一个参数是模式 --and, --or, --not, ( …​ ) # 指定如何使用布尔表达式组合多个模式 --all-match # 将多个模式表达式结合使用时--or，会指定此标志以将匹配限制为具有与其匹配的所有行的文件 -q, --quiet # 不输出匹配的行 &lt;tree&gt;…​ # 而不是在工作树中搜索跟踪文件，搜索给定树中的斑点 -- # 表示选项结束; 其余的参数是&lt;pathspec&gt;限制器 &lt;pathspec&gt;…​ # 如果给定，则将搜索限制为至少匹配一个模式的路径","categories":[{"name":"git","slug":"git","permalink":"https://hengxincheung.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hengxincheung.github.io/tags/git/"}]},{"title":"有状态和无状态登录","slug":"web/有状态和无状态登录","date":"2020-05-26T05:23:34.000Z","updated":"2020-05-29T11:28:23.458Z","comments":true,"path":"web/有状态和无状态登录/","link":"","permalink":"https://hengxincheung.github.io/web/%E6%9C%89%E7%8A%B6%E6%80%81%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95/","excerpt":"","text":"在一个系统中，用户的登录状态的维护是不可跨越的重要问题。根据登录状态保存在服务器端抑或客户端可以将其区分为:有状态登录无状态登录 有状态登录有状态登录指登录状态存储在服务器端，其一般通过session机制保持会话，是一种用空间换时间的策略。流程如下：第一次请求时，服务器产生session对象，并将该session-id写入http协议的header中，回发给客户端；客户端接收到session-id，将其保存在cookie中，每次向服务器发送请求时都将携带着标识其身份的session-id；服务器接收到客户端的请求时，根据其携带的session-id检索对应的session对象中是否含有用户信息，若存在则判断已登录；否则判断未登录。说明：一般在客户端向服务器第一次请求时，服务器会自动生成session-id并将其添加到请求头部(request-header)。 缺点及解决方案有状态登录会导致如下问题：服务器端保存大量数据，会占用服务器大量内存，在高并发时格外突出影响性能；服务器端保存用户状态，无法进行水平扩展；客户端请求依赖服务端，多次请求必须访问同一台机器（针对集群或分布式），需要在多个服务器中共享用户登录信息(可以理解为session)。针对以上问题，我们可以将session存储到redis数据库中（这只是一种解决方式，也可以将session同步复制到每一个服务器上），可以有效减少服务器的内存压力。分布式或集群的时候，先通过查询redis数据库来得到对应的session对象，进而查询用户状态。 无状态登录无状态登录指服务器不保存用户的登录信息，客户端的每次请求必须具备自描述信息，服务器通过这些信息识别客户端身份。与有状态登录对比，是一种用时间换空间的策略。微服务集群中的每个服务，对外提供的都是rest风格的接口。而rest风格的一个最重要的规范就是：服务的无状态性。 优点客户端请求不依赖服务端的信息，任何多次的请求不需要必须访问到同一台服务器；服务端的集群和状态对客户端是透明的 （p.s.计算机中的透明一词高深莫测）；服务端可以任意的迁移和伸缩；减小服务端的存储压力。 实现无状态登录无状态登录的流程如下：当客户端第一次请求服务时，服务端对用户进行信息认证（登录）；认证通过，使用密钥将用户身份信息（不含密码，一般就是用户名）进行加密形成token（令牌），返回给客户端，作为登录凭证；客户端以后的每次请求都携带认证的token，一般为用户名+用户名的密文；服务端使用密钥对token的用户名部分进行加密（也可以反过来对密文进行解密），若加密或解密出来的部分与携带来的信息一致则判断已登录；否则判断未登录。在这种模式中，token是识别客户端身份的唯一标识，其安全性的保障是至关重要的。一般来说，推荐使用RSA非对称加密。因为客户端已知明文及其对应的密文，若使用对称加密的方式，容易被推导出密钥。那么现在可以解答为什么说无状态登录是一种用时间换空间的策略：因为无状态服务每次都需要对用户身份信息进行加密或解密操作，需要花费时间去计算，但无需将身份信息存储。 思考能否将验证通过的用户信息及其密文存储到redis数据库中，那么在之后的验证就不需要进行加密解密运算了，只是在数据库中去寻找是否存在一致的用户信息，若存在则判断已登录。但好像这样是多此一举的，如果使用redis服务器，直接保存session-id和session对象就好。貌似使用RSA产生的token（令牌）并不会比使用session-id的方式安全很多。","categories":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/categories/web/"}],"tags":[{"name":"登录","slug":"登录","permalink":"https://hengxincheung.github.io/tags/%E7%99%BB%E5%BD%95/"},{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/tags/web/"}]},{"title":"RESTful简介","slug":"web/RESTful简介","date":"2020-05-26T05:22:00.000Z","updated":"2020-05-27T07:28:01.304Z","comments":true,"path":"web/RESTful简介/","link":"","permalink":"https://hengxincheung.github.io/web/RESTful%E7%AE%80%E4%BB%8B/","excerpt":"","text":"什么是RESTful?REST(Representational State Transfer, 表达性状态传递)。首先我们先了解一下涉及的一些概念:Resources(资源): 这里的资源指的是网络上的每一个实体，而每一个实体都有着d对应的URI(统一资源标识符),如果要访问这个资源，需要通过访问它的URI。Representation(表现层): 简单来说就是资源的表现形式，比如图片、HTML、文本等。State Transfer(状态转换): 客户端可以通过GET, POST, PUT, DELETE这些HTTP动词来操作资源。REST是从资源的角度来审视整个网络，将分布在网络中的某个节点（或资源）通过URI进行标识。而客户端和服务器传递的是资源的某种表现形式，并且客户端可以通过HTTP动词对服务器上的资源进行操作，实现“表达性状态转换”。满足以上约束条件和原则的应用程序或设计就是RESTful。换言之，RESTful就是一种架构的约束和规范。 RESTful API对于API的设计，RESTful是如今最常见的设计规范，通常用于Web数据接口的设计。 URI设计原则1：动词+宾语客户端通过“动词+宾语”的形式来操作服务器资源，动词指的是HTTP动词，宾语指的是资源。HTTP动词对应了服务器资源的一种操作：GET: 相当于数据库操作的SELECT，从服务器取出一项或多项资源。POST: 相当于数据库操作的CREATE，在服务器新建一个资源。PUT: 相当于数据操作的UPDATE，更新服务器资源（由客户端提供改变后的全部资源）。PATCH: 相当于数据库操作的UPDATE，更新服务器资源（由客户端提供改变的属性）。DELETE: 相当于数据库操作的DELETE，删除服务器资源。原则2：宾语必须是名词由于宾语是API中的URI，是HTTP动词作用的对象，所以宾语应该使用名词，而不是动词。原则3：复数URI对于URI建议使用复数。原则4：避免多级的URI HTTP状态码客户端的每一次请求，服务器都会给出响应，而响应包括HTTP状态码和数据两部分。下面给出HTTP状态码的含义：1xx: 相关信息2xx: 操作成功3xx: 重定向4xx: 客户端(请求)错误5xx: 服务器错误 服务器响应原则原则1：不要返回纯文本API返回的数据格式，不应该是一个纯文本，应该是一个JSON对象，这样才符合结构化流程。同样，服务器响应的HTTP头部信息中的Content-Type属性也应该设置为application/json。原则2：发生错误时，不要返回200状态码在发生错误时，不应该返回一个200状态码，然后把错误信息放在数据体里，因为这样会导致需要解析完数据才能知道操作失败。","categories":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/tags/web/"},{"name":"RESTful","slug":"RESTful","permalink":"https://hengxincheung.github.io/tags/RESTful/"}]},{"title":"08-其他命令","slug":"linux快速入门/08-其他命令","date":"2020-05-25T17:38:28.000Z","updated":"2020-05-27T07:26:10.657Z","comments":true,"path":"linux快速入门/08-其他命令/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/08-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查找文件：find软链接：ln打包和压缩：tar软件安装：apt-get 查找文件find命令十分强大，通常用来在特定目录下搜索符合条件的文件。1234find [路径] -name filename# 如果省略路径，表示在当前文件夹下查找# find命令可以搭配通配符使用，如find -name \"*.py\"# find命令的其他选项请自行用man或help查阅学习 软链接12# 建立文件的软链接，类似于windos下的快捷方式ln -s 被链接的源文件 链接文件注意：若没有-s选项建立的是硬链接文件。源文件要使用绝对路径，不能使用相对路径。这样方便移动链接文件后仍能正常使用。使用ls -l查看软链接文件会看到后面又-&gt;link_resource_src在Linux中，文件名和文件的数据是分开存储的。硬链接相当于文件数据的另一个文件名，故在Linux中只有文件的硬链接数==0才是真正被删除。在现实工作中几乎不会建立文件的硬链接。 打包压缩在不同的操作系统，常用的打包压缩方式是不同的：windows常用rarMac常用zipLinux常用tar.gz 打包/解包tar 是linux中最常用的备份工具，此命令可以把一系列文件打包到一个大文件中，也可以把一个打包的大文件恢复成一系列文件。tar命令只负责打包，而不负责压缩。12345# 打包文件tar -cvf 打包文件.rar 被打包文件/路径# 解包文件tar -xvf 打包文件.rar选项说明c生成档案文件，创建打包文件x解开档案文件v列出归档接档文件的详细过程，显示进度f指定档案文件名称，f后面一定是.tar文件，所以此须在最后注意：-f必须在最后，其他顺序随意 压缩/解压缩1)gziptat和gzip命令结合可以实现文件的打包和压缩，其扩展名一般用xxx.tar.gz在tar命令中有一个选项-z可以调用gzip,从而更方便实现压缩和解压缩的功能。12345678# 压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件/路径# 解压缩文件tar -zxvf 打包文件.tar.gz# 解压缩到指定路径tar -zxvf 打包文件.tar.gz -C 指定的路径-C选项解压缩到指定目录，要注意的是指定的路径必须存在2）bzip2tat和bzip2命令结合可以实现文件的打包和压缩，其扩展名一般用xxx.tar.bz2在tar命令中有一个选项-j可以调用bzip2,从而更方便实现压缩和解压缩的功能。12345# 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩的文件/路径# 解压缩文件tar -jxvf 打包文件.tar.bz2 软件安装 通过apt安装/卸载软件apt是Advanced Packaging Tool，是linux下一款安装包管理工具。通过apt可以在终端方便的安装/卸载/更新软件包。1234567891011121314# 安装软件$ sudo apt install 软件包# 卸载软件$ sudo apt remove 软件包# 更新已安装的软件$ sudo apt upgrate# 示例# 一个小火车提示 sl$ sudo apt install sl# 一个比较漂亮的查看当前进程排名的软件 htop$ sudo apt install htopsl示意图htop示例图 设置软件源可以通过设置镜像源，选择一个访问网速更快的服务器，使得下载/安装服务更加快速。所谓镜像源，就是所有服务器的内容是相同的（镜像），但是根据你所处的地理位置不同，不同的服务器对你的响应和下载速度不一样，国内的服务器速度会更快一些。要修改的文件/etc/apt/sources.list查看原资源文件cat /etc/apt/sources.list备份原来的源：1$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup使用脚本更改为aliyun的镜像源：123456789101112Codename&#x3D;$( (lsb_release -a)|awk &#39;&#123;print $2&#125;&#39;|tail -n 1 )echo &quot;\\deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename main multiverse restricted universedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-backports main multiverse restricted universedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-proposed main multiverse restricted universedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-security main multiverse restricted universedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-updates main multiverse restricted universedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename main multiverse restricted universedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-backports main multiverse restricted universedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-proposed main multiverse restricted universedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-security main multiverse restricted universedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-updates main multiverse restricted universe &quot;&gt;sources.list记得修改完镜像源之后要更新软件源：1234# 更新软件源sudo apt-get update# 更新软件sudo apt-get upgrade","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"07-系统信息","slug":"linux快速入门/07-系统信息","date":"2020-05-25T17:37:35.000Z","updated":"2020-05-27T07:25:01.493Z","comments":true,"path":"linux快速入门/07-系统信息/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/07-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/","excerpt":"","text":"系统信息的相关命令为了方便通过终端维护服务器时，查看服务器当前的系统日期和时间/磁盘空间占用情况/程序执行情况 目标时间和日期datecal磁盘和目录空间dfdu进程信息pstopkill 时间和日期命令作用date查看系统时间calcalendar 查看日历，-y选项可以查看一年的日历 磁盘信息命令作用df -hdisk free显示磁盘剩余空间du -h [目录名]disk usage 显示目录下文件的大小-h以人性化的方式显示文件大小，如4096将会被显示会4K 进程信息所谓进程，通俗地讲就是当前正在执行的一个程序命令作用ps auxprocess status 查看进程的详细信息top动态显示运行中的进程并排序kill [-9] 进程代号终止指定代号的进程，-9代表强制终止ps默认只会显示当前用户通过终端启动的应用程序ps选项说明：选项含义a显示终端上所有进程，包括其他用户的进程u显示进程的详细信息x显示没有控制终端的信息使用kill命令尽可能只杀死自己开启的进程，而不要杀死属于root的进程，以防止系统崩溃。要退出top可以直接输入q","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"06-用户权限","slug":"linux快速入门/06-用户权限","date":"2020-05-25T17:35:27.000Z","updated":"2020-05-27T07:24:58.489Z","comments":true,"path":"linux快速入门/06-用户权限/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/06-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/","excerpt":"","text":"用户和权限的基本概念 基本概念用户是Linux系统工作中重要的一环，用户管理包括用户和组管理不同的用户对于不同的系统资源都有着不同的使用权限在Linux中，可以指定每一个用户针对不同的文件或目录的不同权限对文件/目录的权限包括权限英文缩写数字代号读readr4写writew2执行excutex1 组在实际应用中，可以预先针对组设置好权限，然后将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限。 ls -l扩展ls -l可以查看文件的详细信息，从左到右依次是：权限：如果第一个字符是d表示目录，拥有者权限、组权限、其他人权限硬链参数：由多少种方式可以访问当当前的目录文件拥有者：文件的拥有人组大小时间名称 chmod简单使用chmod可以修改用户/组对文件/目录的权限。命令格式如chmod +/-rwx 文件名|目录名注：上述方式会一次性修改拥有者/组的权限 超级用户Linux系统中的root账户通常用于系统的维护和管理，对操作系统所有资源具有所有权限。不推荐直接使用root账号登陆，以保证系统的安全在Linux安装过程中，系统会自动创建一个用户账号，而这个默认用户就称为标准用户sudosu是substitute user的缩写，表示使用另一个用户身份sudo命令表示以其他身份来执行命令，预设的身份是root用户使用sudo时，必须先输入密码，之后有5分钟的有效期，超过期限需重新输入密码若未经授权用户企图使用sudo，则会发出警告邮件给管理员 组管理 终端命令提示：创建/删除组的终端命令都需要通过sudo执行命令作用groupadd 组名添加组groupdel 组名删除组cat /etc/group确认组信息chgrp 组名 文件/目录名修改文件/目录的所属组，选项-R递归修改提示：组信息保存在/etc/group文件中/etc目录是专门用来保存系统配置信息的目录 用户管理 终端命令命令作用说明useradd -m -g 组 新建用户名添加新用户- m:创建家目录;-g 指定用户所在组，默认同名passwd 用户名设置用户密码如果是普通用户，直接用passwd修改密码userdel -r 用户名删除用户-r 会自动删除用户家目录cat /etc/passwd|grep 用户名确认用户信息新建用户后，信息保存在/etc/passwd文件中创建用户时，如果忘记添加-m选项，需要手动为该用户创建家目录。最好的方法是删除该用户再新建。创建用户时，默认会创建一个和用户名同名的组名用户信息保存在/etc/passwd/文件中 查看用户信息命令作用id [用户名]查看用户uid和gid信息who查看当前所有登陆的用户列表whoami查看当前登陆用户的账户名 passwd文件/etc/passwd文件存放的是用户信息，由6个分号组成7个信息：1.用户名2.密码（x表示加密的密码）3.uid（用户标识）4.gid（组标识）5.用户全名或本地账号6.家目录7.登陆使用的shell，就是登陆之后使用的终端命令，ubuntu默认是dash1234# 示例$ cat -n /etc/passwd | grep zhangsan# 49 zhangsan:x:1001:1001::/home/zhangsan:# x表示密码加密无法查看，第一个1001表示用户id，第二个1001表示所在组id，最后是该用户名的家目录绝对路径 usermod 设置用户主组/附加组usermod可以用于设置用户的主组/附加组和登陆shell。主组：通常在新建用户时指定，在etc/passwd的第4列gid对用的组附加组：在etc/passwd中最后一列表示该组的用户列表，用于指定用户的附加权限。添加附加组后，需要重新登陆才能生效。12345678# 修改用户的主组usermod -g 组 用户名# 修改用户的附加组usermod -G 组 用户名# 修改用户登陆shellusermod -s &#x2F;bin&#x2F;bash默认使用useradd添加的用户没有权限使用sudo和以root身份执行命令，可以使用以下命令添加用户到sudo附加组中usermod -G sudo 用户名 which 查看执行命令位置/etc/passwd用于保存用户信息的文件/usr/bin/passwd是用于修改密码的程序which命令可以查看执行命令的所在位置，例如12345$ which ls# 输出：/bin/ls$ which useradd# 输出：/usr/sbin/useraddbin和sbin在Linux中，绝大多数的可执行文件都是保存在/bin、/sbin、/usr/bin、usr/sbin/bin(binary)是二进制执行文件目录，主要用于具体应用/sbin(system binary)是系统管理员专用的二进制代码存放目录，主要用于系统管理/usr/bin(user command for applications)后期安装的软件/usr/sbin(super user command for applications)超级用户的一些管理程序注：cd是内置在linux内核中的终端命令，因此使用which无法找到 切换用户命令作用说明su - 用户名切换用户，并切换目录- 可以切换到用户家目录，否则保持位置不变exit退出当前登陆用户su不写用户名，可以切换到root，不推荐使用 修改文件权限命令作用chown修改拥有者chgrp修改组chmod修改权限命令格式如下：12345678# 修改文件\\目录的拥有者$ chown 用户名 文件名|目录名# 递归修改文件|目录的组$ chgrp -R 组名 文件名|目录名# 递归修改文件权限，读是4，写是2，执行是1$ chmod -R 755 文件名|目录名chmod在设置权限时，可以简单地使用三个数字分别对应拥有者、组和其他用户的权限，12# 直接修改文件|目录的读|写|执行权限，不能精确到拥有者|组|其他用户$ chmmod +/-rwx 文件名|目录名常见的数字组合：777—&gt;u=rwx,g=rwx,o=rwx755—&gt;u=rwx,g=-rx,o=-rx644—&gt;u=rw-,g=r–,o=r–","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"05-远程管理命令","slug":"linux快速入门/05-远程管理命令","date":"2020-05-25T17:33:36.000Z","updated":"2020-05-30T13:20:26.027Z","comments":true,"path":"linux快速入门/05-远程管理命令/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/05-%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/","excerpt":"","text":"关机/重启 shutdownshutdown命令可以安全关闭或者重启操作系统选项含义-r重新启动-c取消计划不指定选项和参数，默认表示一分钟之后关闭电脑远程维护服务器时，最好不要关闭系统，而应该重启系统常用命令示例：12345678910# 马上重启系统$ shutdown -r now# 立即关机$ shutdown now# 在今天20：30关机$ shutdown 20:30# 系统再过十分钟关闭系统$ shutdown +10# 取消关机/重启任务$ shutdown -c 查看或配置网卡信息命令英文作用ifconfigconfigure a network interface查看/配置计算机当前的网卡信息ping ipping检测目标ip地址连接是否正常 网卡和ip地址网卡网卡是一个负责网络通讯的硬件设备ip地址是设置在网卡上的地址信息（相当于门牌，别人根据这个ip在网路上找到你），ip地址是以网络号和主机号来标示网络上的主机ip地址每台联网的电脑上都有ip地址，是保证电脑之间正常通讯的重要设置。ip地址不能相同（这里指的是公网，许多计算机的本地ip相同这是由于子网等措施，详细查看《计算机网络》） ifconfigifconfig可以查看/配置计算机当前的网卡信息12345# 查看网卡配置信息$ ifconfig# 查看网卡对应的ip地址ifconfig | grep inet一台计算机有可能有一个物理地址和多个虚拟网卡，Linux中物理网卡的名字通常以ensXX表示。127.0.0.1被称为本地回环/环回地址，一般用来测试本机网卡是否正常。 ping1234# 检测目标主机是否连接正常$ ping 地址# 检测本地网卡是否正常$ ping 127.0.0.1在Linux中，想要终止一个终端程序的执行，绝大多数都可以使用CTRL + C 远程登陆和复制文件命令英文作用ssh 用户名@ipsecure shell远程管理scp 用户名@ip:文件名或路径secure copy远程复制文件 ssh基础在Linux中SSH是非常常用的工具，通过SSH客户端我们就可以连接到运行了SSH服务器的机器上。ssh是目前较可靠，专为远程登陆会话和其他网络服务提供安全性的协议。数据传输是加密的、压缩的，防止了信息泄露和提高了传输速度，有效抵抗了DNS欺骗和IP欺骗1)域名和端口号域名是ip地址的别名，方便用户记忆，由一串用点分隔的名字组成，如www.baidu.com通过ip地址可以找到网路上的计算机，而通过端口号则可以找到计算机上运行的应用程序。SSH服务器的默认端口号是22，如果是默认端口号，连接的时候，可以忽略。常见的服务器端口号列表：端口号服务22ssh服务器80web服务器443HTTPS21FTP服务器3306mysql程序8080tomcat容器2)ssh客户端的简单使用123ssh [-p port] user@remote# 例子ssh -p 22 root@127.0.0.1user是远程机器上的用户名，如果不指定默认为当前用户remote是远程机器上的地址，可以是ip/域名port是SSH Server监听的端口，如果不指定默认为22提示：使用exit退出当前用户的登陆注意：如果在windows系统中，可以安装PuTTY或者XShell客户端软件即可。 scpscp是一个Linux下用于进行远程拷贝文件的命令。它的地址格式与ssh基本相同，需要注意的是，在指定端口时用的是大写的-P，而不是小写的。12345678910111213# 把本地目录下的1.txt文件复制到远程的家目录下的Desktop/1.txt# 注意：':'后面的路径如果不是绝对路径，则以用户的家目录作为参考路径scp -P port 1.txt user@remote:Desktop/1.txt# 把远程的家目录下的Desktop/1.txt复制到本地当前目录的2.txtscp -P port user@remote:Desktop/1.txt 2.txt# 加上-r选项可以传递文件夹# 把当前目录下的demo文件夹复制到远程的家目录下Desktopscp -r demo user@remote:Desktop# 把远程家目录下的demo文件夹复制到当前目录下scp -r user@remote:Desktop/demo .选项含义-r若给出的源文件是目录文件，则scp将递归复制该目录下的所有子目录和文件，目标文件必须是一个目录名-P指定端口号 SSH高级有关的sshp配置信息都保存在家目录下.ssh目录下 免密码登陆配置公钥执行ssh-keygen即可生成ssh钥匙，一路回车即可。上传公钥到服务器执行ssh-copy-id -p port user@remote,可以让远程服务器记住我们的公钥。 配置别名每次都输入ssh -p port user@remote，时间长了就觉得麻烦，特别是经常访问同一主机时。而配置别名可以让我们进一步偷懒，可以用ssh linux来替代上面的一长串。在~/.ssh/config（若原先不存在，请用touch命令创建）里面追加以下内容：1234Host linux HostName ip地址 User root Port 22保存之后，即可用ssh linux实现远程登陆了，scp也同样可以。","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"04-文件与目录","slug":"linux快速入门/04-文件与目录","date":"2020-05-25T17:30:58.000Z","updated":"2020-05-27T07:24:48.458Z","comments":true,"path":"linux快速入门/04-文件与目录/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/04-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/","excerpt":"","text":"文件和目录常用命令查看目录内容:ls切换目录:cd创建和删除操作:touch、rm、mkdir拷贝和移动文件:cp、mv查看文件内容:cat、more、grep其他echo重定向&gt;和&gt;&gt;管道| ls命令说明ls是单词list的缩写，其功能是列出目录的内容，是用户最常见的命令之一。 Linux下文件和目录的特点文件和目录名称最长可以有256个字符以.开头的文件为隐藏文件，需要使用-a参数才能显示.代表当前目录..代表上一级目录 ls常用选项参数命令-aall，显示指定目录的所有文件，包括隐藏文件-llong，以列表方式显示文件的详细信息-h需要配合-l使用(ls -lh或ls -l -h)，以人性化的方式显示文件大小 ls与通配符配合如果目录中的文件十分之多，可以借助通配符快速定位所需的文件或目录。注：其实通配符可以运用到大多数的command，如rm等。通配符含义*代表任意个数个字符?代表任意一个字符，至少一个[]表示可以匹配字符组中的任一个[abc]、[a~z]匹配a、b、c中任意一个；匹配从a到f范围内的任意一个字符 切换目录cd是change diretory的简写，其功能是更改当前的工作目录，也是用户最常用的命令之一。注意：Linux下的所有目录和文件的都是大小写敏感的。命令含义cd切换回当前用户的家目录cd ~切换回当前用户的家目录cd .切换回当前目录cd ..切换回上一级目录cd -在最近两次的目录间切换 相对路径和绝对路径相对路径：直接输入目录，表示相对当前目录所在的目录位置绝对路径：输入路径时，最前面是/或~，表示从根目录或家目录开始的具体目录位置 创建和删除目录 touch创建文件或修改文件时间如果文件不存在，可以创建一个空白文件如果文件已经存在，可以修改文件的末次修改时间 mkdir创建一个新的目录选项含义-p递归创建目录新建的目录的名称不能与当前目录中已有的目录或文件同名 rm删除文件或目录使用rm命令要小心，文件删除后不能恢复选项含义-f强制删除，忽略不存在的文件，无需提示-r递归删除目录下的内容，删除文件夹必须加此参数 拷贝和移动文件命令对应英文功能tree [目录名]tree以树状图列出文件目录结构cp 源文件 目标文件copy复制文件或目录mv 源文件 目标文件move移动文件或目录/文件或目录重命名 treetree命令可以以树状图列出文件的目录结构。选项含义-d只显示目录 cpcp命令可以将给出的文件或目录复制到另一个文件或目录中。选项含义-f已经存在的目标文件直接覆盖，不会提示-i覆盖文件前提示-r若源文件是目录，将递归复制该目录下所有的子目录和文件，目标必须是一个目录 mvmv移动文件或目录或为文件或目录重命名。选项含义-i覆盖文件前提示重命名时候建议添加-i的选项以防止覆盖已存在的文件。 查看文件内容命令对应英文作用cat 文件名concatenate查看文件内容、创建文件、文件合并、追加文件内容等more 文件名more分屏显示文件内容grep 搜索文本 文件名grep搜索文本文件内容 catcat会一次性显示所有内容，适合查看内容较少的文本文件选项含义-b对非空输出行编号-n对输出的所有行编号Linux中的 nl 命令和 cat -b 等价 moremore会分屏显示文本内容，每次只显示一页，适合查看内容较多的文本文件 grepgrep允许对文本文件进行模式查找，即正则表达式。选项含义-v显示不包含匹配文本的所有行，相当于求反-n显示匹配及行号-i忽略大小写参数含义^a行首，搜索以a开头的行ke$行尾，搜索以ke结束的行 其他 echo 文字内容echo会在终端中显示参数指定的文字，通常会和重定向联合使用 重定向&gt;和&gt;&gt;Linux允许将命令执行结果重定向到一个文件将本应显示在终端上的内容输出/追加到指定文件中其中&gt;表示输出，会覆盖文件原有的内容&gt;&gt; 表示追加，会将内容追加到已有文件的末尾 管道 |Linux允许将一个命令的输出通过管道作为另一个命令的输入这里的|就是管道（从一头塞进去另一头拿出来），|分为左右两部分，左端写，右端读常用的管道命令有：more：分屏显示内容grep：在命令执行结果的基础上查询指定的文本","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"03-linux命令与小技巧","slug":"linux快速入门/03-linux命令与小技巧","date":"2020-05-25T17:29:18.000Z","updated":"2020-05-27T07:24:40.979Z","comments":true,"path":"linux快速入门/03-linux命令与小技巧/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03-linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"Linux终端命令格式1command [-options] [parameter][]代表可选说明:command:命令名，相应功能的英语单词或单词缩写[-options]:选项，可用于对命令进行控制，也可以忽略[parameter]:传给命令的参数，可以是零个、一个或多个 常用的Linux命令的基本使用命令英文功能lslist查看当前文件夹下的内容pwdprint work directory查看当前所在文件夹cd[目录名]change directorychange directorytouch[文件名]touch如果文件不存在则创建文件mkdir[目录名]make directory创建目录rm[文件名]remove删除指定的文件名clearclear清屏 使用终端时的小技巧ctrl + shift + =放大终端窗口字体显示ctrl + -缩小终端窗口字体显示 自动补全在敲出文件/目录/命令的前几个字母，按下Tab，如果输入没有歧义，系统会自动补全。如果存在多个同前缀的命令，再按一次Tab会提示存在的命令 使用曾经用过的命令按住上或下可以在曾经使用过的命令间切换如果想要退出选择，并且不想执行当前选中的命令，可以按Ctrl + c 查询命令帮助信息 help命令1command --help说明：显示command命令的帮助信息 man命令1man command说明：查询command的使用手册。man是mannual的缩写，是Linux提供的手册，包含了绝大多数命令、函数的详细使用说明。使用man时候的操作键：操作键功能空格键显示手册的下一屏Enter键一次滚动手册页的一行b回滚一屏f前滚一屏q退出/word搜索word字符串","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"02-文件系统简介","slug":"linux快速入门/02-文件系统简介","date":"2020-05-25T17:27:34.000Z","updated":"2020-05-27T07:24:35.154Z","comments":true,"path":"linux快速入门/02-文件系统简介/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/","excerpt":"","text":"文件和目录 单用户和多用户操作系统单用户操作系统：一台计算机同一时间只能由一个用户使用，一个用户独享计算机的全部硬件和软件资源。多用户操作系统：一台计算机同一时间可以由多个用户使用，所有用户共享计算机的硬件和软件资源。 文件系统Windows下的文件系统是一个个的驱动器盘符，每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形：而linux没有盘符的概念，只有一个根目录/，所有的文件都在它的下面。每个用户在/home目录下都有其自己（用户名）的目录，一般来说用户只能操作属于自己的目录。 linux主要目录速查表/：根目录，在linux只有一个根目录，所有的东西都从这里开始。输入/home，其实是告诉电脑先从/目录开始，在进入到home目录/bin、/usr/bin：可执行二进制文件的目录，如常用的命令ls 、tar、mv、cat等/boot：放置linux系统启动时用到的一些文件，如linux的内核文件：/boot/vmlinux，系统引导管理器：/boot/grub/dev：存放linux系统下的设备文件，访问该目录下的某个文件，相当于访问某个设备，常用的是挂载光驱：mount /dev/cdrom/mnt/etc：系统配置文件的存放的目录，不建议在此目录存放可执行文件，重要的配置文件有：/etc/inittab/etc/fstab/etc/init.d/etc/sysconfig/home:系统默认的用户目录/lib、usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助/lost+fount：系统异常产生错误时，会将一些遗失的片段放置到该目录下/mnt、/media：光盘默认挂载点，通常光盘挂载到/mnt/cdrom下/opt：给主机额外安装软件所摆放的目录/proc：此目录的数据都在内存中，如系统核心、外部设备、网络状态等，不占用空间/root：系统管理员root的家目录","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"01-操作系统","slug":"linux快速入门/01-操作系统","date":"2020-05-25T17:25:58.000Z","updated":"2020-05-27T07:24:28.086Z","comments":true,"path":"linux快速入门/01-操作系统/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"操作系统（Operation System, OS） 操作系统的概念操作系统是一套特定的软件，是用户和硬件的接口和桥梁。没有安装操作系统的计算机，通常被称为裸机如果想在裸机上运行程序，必须使用机器语言书写程序如果计算机上安装了操作系统，就可以在操作系统上安装支持的高级语言环境，使用高级语言开发程序 不同应用领域的主流操作系统桌面操作系统：Windows、macOS、linux服务器操作系统：linux（安全免费，占有率高）、windows server（收费，占有率低）嵌入式操作系统：linux移动设备操作系统：ios、Android、塞班 虚拟机虚拟机（Virtual Machine）指通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统虚拟系统通过生成现有操作系统的全新虚拟镜像，具有真实操作系统完全一样的功能虚拟系统不会对真正的系统产生任何影响，且能随意切换 操作系统的发展历史 Unix1969年Ken Thompson用一个月的时间，使用汇编语言写出了Unix原型。1970年以BCPL语言为基础，设计出很简单且很接近硬件的B语言，并用B语言写出了第一个unix操作系统。1972年，Dennis M.Ritchie 改造B语言（跨平台性较差）设计出了C语言。1973年，C语言主体完成，两人使用C语言完全重写了现在大名鼎鼎的unix操作系统。Unix操作系统是多用户的，允许多用户在同一时间登陆到同一个电脑上。 Minix因为unix操作系统源码的私有化，Andrew教授为了能在课堂上教授学生操作系统的运行细节，自行开发了与unix兼容的操作系统，以小型unix之意，取名minix。 linux1991年Linus对unix产生浓厚兴趣，尝试在minix上做开发，编写了磁盘驱动程序和文件系统。这些成为了linux第一个内核的雏形。linus将其开源，得到全世界程序员的贡献，linux操作系统愈加完善。 Linux内核及发行版内核(Kernel)是系统的心脏，是运行程序和管理硬件设备的核心程序。它提供了一个裸设备与应用程序间的抽象层。发行版是基于内核包装了各种各样的应用程序。常见发行版有：UbuntuRedhatDebianCentOSDeepin","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"15-IO","slug":"numpy教程/15-IO","date":"2020-05-25T16:37:46.000Z","updated":"2020-05-27T07:27:52.563Z","comments":true,"path":"numpy教程/15-IO/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/15-IO/","excerpt":"","text":"Numpy 可以读写磁盘上的文本数据或二进制数据。NumPy 为ndarray对象引入了一个简单的文件格式：npy。npy文件用于存储重建ndarray所需的数据、图形、dtype 和其他信息。常用的 IO 函数有：load()和save()函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中。savze()函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npz的文件中。loadtxt()和savetxt()函数处理正常的文本文件(.txt等) numpy.save()和numpy.load()numpy.save()函数将数组保存到以.npy为扩展名的文件中。在这里我们可以使用load()函数来读取数据。1234567891011numpy.save(file, arr, allow_pickle=True, fix_imports=True)# file：要保存的文件，扩展名为.npy，如果文件路径末尾没有扩展名.npy，该扩展名会被自动加上# arr: 要保存的数组# allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python中的pickle用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化# fix_imports: 可选，为了方便Pyhton2中读取Python3保存的数据a = np.array([1,2,3,4,5]) # 保存到 outfile.npy 文件上np.save('outfile.npy',a)b = np.load('outfile.npy') np.savez()numpy.savez()函数将多个数组保存到以npz为扩展名的文件中。123456789101112131415161718numpy.savez(file, *args, **kwds)# file：要保存的文件，扩展名为.npz，如果文件路径末尾没有扩展名.npz，该扩展名会被自动加上# args: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为arr_0, arr_1, …。# kwds: 要保存的数组使用关键字名称import numpy as np a = np.array([[1,2,3],[4,5,6]])b = np.arange(0, 1.0, 0.1)c = np.sin(b)# c 使用了关键字参数 sin_arraynp.savez(\"out.npz\", a, b, sin_array = c)r = np.load(\"out.npz\") print(r.files) # 查看各个数组名称print(r[\"arr_0\"]) # 数组 aprint(r[\"arr_1\"]) # 数组 bprint(r[\"sin_array\"]) # 数组 c savetxt()和loadtxt()savetxt()函数是以简单的文本文件格式存储数据，对应的使用loadtxt()函数来获取数据。123456789np.loadtxt(FILENAME, dtype=int, delimiter=' ')np.savetxt(FILENAME, a, fmt=\"%d\", delimiter=\",\")# 参数delimiter可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等import numpy as np a=np.arange(0,10,0.5).reshape(4,-1)np.savetxt(\"out.txt\", a, fmt=\"%d\", delimiter=\",\") # 改为保存为整数，以逗号分隔b = np.loadtxt(\"out.txt\", dtype=int, delimiter=\",\") # load时也要指定为逗号分隔","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"14-线性代数","slug":"numpy教程/14-线性代数","date":"2020-05-25T16:37:14.000Z","updated":"2020-05-27T07:27:48.692Z","comments":true,"path":"numpy教程/14-线性代数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/14-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","excerpt":"","text":"NumPy 提供了线性代数函数库linalg，该库包含了线性代数所需的所有功能，可以看看下面的说明：函数描述dot两个数组的点积，即元素对应相乘vdot两个向量的点积inner两个数组的内积matmul两个数组的矩阵积determinant数组的行列式solve求解线性矩阵方程inv计算矩阵的乘法逆矩阵","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"13-矩阵库","slug":"numpy教程/13-矩阵库","date":"2020-05-25T16:36:15.000Z","updated":"2020-05-27T07:27:45.310Z","comments":true,"path":"numpy教程/13-矩阵库/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/13-%E7%9F%A9%E9%98%B5%E5%BA%93/","excerpt":"","text":"NumPy 中包含了一个矩阵库numpy.matlib，该模块中的函数返回的是一个矩阵，而不是ndarray对象。一个m∗nm*nm∗n的矩阵是一个由mmm行（row）nnn列（column）元素排列成的矩形阵列。矩阵里的元素可以是数字、符号或数学式。{123456789}\\left\\{ \\begin{matrix} 1&amp;2&amp;3\\\\ 4&amp;5&amp;6\\\\ 7&amp;8&amp;9 \\end{matrix} \\right\\}⎩⎨⎧​147​258​369​⎭⎬⎫​ matlib.empty()matlib.empty()函数返回一个新的矩阵，语法格式为：12345678910numpy.matlib.empty(shape, dtype, order)# shape: 定义新矩阵形状的整数或整数元组# Dtype: 可选，数据类型# order: C（行序优先） 或者 F（列序优先）import numpy.matlib import numpy as np print (np.matlib.empty((2,2)))# 填充为随机数据 numpy.matlib.zeros()numpy.matlib.zeros()函数创建一个以 0 填充的矩阵。1print (np.matlib.ones((2,2))) numpy.matlib.eye()numpy.matlib.eye()函数返回一个矩阵，对角线元素为 1，其他位置为零。123456numpy.matlib.eye(n, M,k, dtype)# n: 返回矩阵的行数# M: 返回矩阵的列数，默认为 n# k: 对角线的索引# dtype: 数据类型print (np.matlib.eye(n = 3, M = 4, k = 0, dtype = float)) numpy.matlib.identity()numpy.matlib.identity()函数返回给定大小的单位矩阵。单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。12# 大小为 5，类型位浮点型print (np.matlib.identity(5, dtype = float)) numpy.matlib.rand()numpy.matlib.rand()函数创建一个给定大小的矩阵，数据是随机填充的。1print (np.matlib.rand(3,3)) matrix与ndarray转换矩阵总是二维的，而ndarray是一个 n 维数组。两个对象都是可互换的。123i = np.matrix('1,2;3,4') j = np.asarray(i) k = np.asmatrix (j)","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"12-副本和视图","slug":"numpy教程/12-副本和视图","date":"2020-05-25T16:35:03.000Z","updated":"2020-05-27T07:27:42.471Z","comments":true,"path":"numpy教程/12-副本和视图/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/12-%E5%89%AF%E6%9C%AC%E5%92%8C%E8%A7%86%E5%9B%BE/","excerpt":"","text":"副本是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。视图是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。视图一般发生在：numpy 的切片操作返回原数据的视图。调用 ndarray 的 view() 函数产生一个视图。副本一般发生在：Python 序列的切片操作，调用deepCopy()函数。调用 ndarray 的 copy() 函数产生一个副本。 无复制简单的赋值不会创建数组对象的副本。相反，它使用原始数组的相同id()来访问它。id()返回 Python 对象的通用标识符，类似于 C 中的指针。此外，一个数组的任何变化都反映在另一个数组上。例如，一个数组的形状改变也会改变另一个数组的形状。 视图或浅拷贝ndarray.view()方会创建一个新的数组对象，该方法创建的新数组的维数更改不会更改原始数据的维数。 副本或深拷贝ndarray.copy()函数创建一个副本。对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"11-排序、条件刷选函数","slug":"numpy教程/11-排序、条件刷选函数","date":"2020-05-25T16:33:52.000Z","updated":"2020-05-27T07:27:38.269Z","comments":true,"path":"numpy教程/11-排序、条件刷选函数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/11-%E6%8E%92%E5%BA%8F%E3%80%81%E6%9D%A1%E4%BB%B6%E5%88%B7%E9%80%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"NumPy 提供了多种排序的方法。这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。种类速度最坏情况工作空间稳定性quicksort 快速排序1O(n^2)0否mergesort 归并排序2O(n*log(n))~n/2是heapsort 堆排序3O(n*log(n))0否 numpy.sort()numpy.sort()函数返回输入数组的排序副本。函数格式如下：12345678910111213141516171819# a: 要排序的数组# axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=0 按列排序，axis=1 按行排序# kind: 默认为'quicksort'（快速排序）# order: 如果数组包含字段，则是要排序的字段numpy.sort(a, axis, kind, order)# 实例import numpy as np a = np.array([[3,7],[9,1]]) print ('调用 sort() 函数：')print (np.sort(a))print ('按列排序：')print (np.sort(a, axis = 0))# 在 sort 函数中排序字段 dt = np.dtype([('name', 'S10'),('age', int)]) a = np.array([(\"raju\",21),(\"anil\",25),(\"ravi\", 17), (\"amar\",27)], dtype = dt) print ('按 name 排序：')print (np.sort(a, order = 'name')) numpy.argsort()numpy.argsort()函数返回的是数组值从小到大的索引值。1234567891011import numpy as np x = np.array([3, 1, 2]) print ('对 x 调用 argsort() 函数：')y = np.argsort(x) print (y)print ('以排序后的顺序重构原数组（从小到大排序）：')print (x[y])print ('使用循环重构原数组（从小到大排序）：')for i in y: print (x[i], end=\" \") numpy.lexsort()numpy.lexsort()用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取……这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。12345678910import numpy as np nm = ('raju','anil','ravi','amar') dv = ('f.y.', 's.y.', 's.y.', 'f.y.') ind = np.lexsort((dv,nm)) print ('调用 lexsort() 函数：') print (ind) print ('\\n') print ('使用这个索引来获取排序后的数据：') print ([nm[i] + \", \" + dv[i] for i in ind]) 其他函数函数描述msort(a)数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相等于 np.sort(a, axis=0)。sort_complex(a)对复数按照先实部后虚部的顺序进行排序。partition(a, kth[, axis, kind, order])指定一个数，对数组进行分区argpartition(a, kth[, axis, kind, order])可以通过关键字 kind 指定算法沿着指定轴对数组进行分区numpy.argmax()和 numpy.argmin()分别沿给定轴返回最大和最小元素的索引。numpy.nonzero()返回输入数组中非零元素的索引numpy.where()返回输入数组中满足给定条件的元素的索引numpy.extract()根据某个条件从数组中抽取元素，返回满条件的元素","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"10-统计函数","slug":"numpy教程/10-统计函数","date":"2020-05-25T16:31:45.000Z","updated":"2020-05-27T07:27:35.579Z","comments":true,"path":"numpy教程/10-统计函数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/10-%E7%BB%9F%E8%AE%A1%E5%87%BD%E6%95%B0/","excerpt":"","text":"NumPy 提供了很多统计函数，用于从数组中查找最小元素，最大元素，百分位标准差和方差等。 计算最小值和最大值numpy.amin()用于计算数组中的元素沿指定轴的最小值。numpy.amax()用于计算数组中的元素沿指定轴的最大值。12345678910111213import numpy as np a = np.array([[3,7,5],[8,4,3],[2,4,9]]) print (np.amin(a,1))# 结果：[3 3 2]print (np.amin(a,0))# 结果：[2 4 3]print (np.amax(a))# 结果：9print (np.amax(a, axis = 0))# 结果：[8 7 9]numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。12345678910import numpy as np a = np.array([[3,7,5],[8,4,3],[2,4,9]]) print (np.ptp(a))# 结果：7print (np.ptp(a, axis = 1))# 结果：[4 5 7]print (np.ptp(a, axis = 0))# 结果：[6 3 6] 百分位数百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数numpy.percentile()接受以下参数。1234numpy.percentile(a, q, axis)# a: 输入数组# q: 要计算的百分位数，在 0 ~ 100 之间# axis: 沿着它计算百分位数的轴首先明确百分位数：第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。1234567891011import numpy as np a = np.array([[10, 7, 4], [3, 2, 1]])# 50% 的分位数，就是 a 里排序之后的中位数print (np.percentile(a, 50)) # axis 为 0，在纵列上求print (np.percentile(a, 50, axis=0)) # axis 为 1，在横行上求print (np.percentile(a, 50, axis=1)) # 保持维度不变print (np.percentile(a, 50, axis=1, keepdims=True)) 中位数numpy.median()函数用于计算数组a中元素的中位数（中值）。12345678import numpy as np a = np.array([[30,65,70],[80,95,10],[50,90,60]]) print (np.median(a))# 沿轴 0 调用 median() 函数print (np.median(a, axis = 0))# 沿轴 1 调用 median() 函数print (np.median(a, axis = 1)) 算术平均值numpy.mean()函数返回数组中元素的算术平均值。如果提供了轴，则沿其计算。算术平均值是沿轴的元素的总和除以元素的数量。123456789import numpy as np a = np.array([[1,2,3],[3,4,5],[4,5,6]]) print ('调用 mean() 函数：')print (np.mean(a))print ('沿轴 0 调用 mean() 函数：')print (np.mean(a, axis = 0))print ('沿轴 1 调用 mean() 函数：')print (np.mean(a, axis = 1)) 加权平均值numpy.average()函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。该函数可以接受一个轴参数。如果没有指定轴，则数组会被展开。加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。即通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。123456789101112import numpy as np a = np.array([1,2,3,4]) print ('调用 average() 函数：')# 不指定权重时相当于 mean 函数print (np.average(a))# 权重数组wts = np.array([4,3,2,1]) print (np.average(a,weights = wts))# 如果 returned 参数设为 true，则返回权重的和 print ('权重的和：')print (np.average([1,2,3, 4],weights = [4,3,2,1], returned = True)) 标准差标准差是一组数据平均值分散程度的一种度量。标准差是方差的算术平方根。标准差公式如下：$$std=\\sqrt{mean((x-\\bar{x})^2)}$$123import numpy as np print (np.std([1,2,3,4])) 方差统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即mean((x−xˉ)2)mean((x-\\bar{x})^2)mean((x−xˉ)2)。换句话说，标准差是方差的平方根。123import numpy as np print (np.var([1,2,3,4]))","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"09-算术函数","slug":"numpy教程/09-算数函数","date":"2020-05-25T16:31:01.000Z","updated":"2020-05-27T07:27:32.683Z","comments":true,"path":"numpy教程/09-算数函数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/09-%E7%AE%97%E6%95%B0%E5%87%BD%E6%95%B0/","excerpt":"","text":"简单的加减乘除NumPy 算术函数包含简单的加减乘除:add()，subtract()，multiply()和divide()。需要注意的是数组必须具有相同的形状或符合数组广播规则。12345678910111213141516import numpy as np a = np.arange(9, dtype = np.float_).reshape(3,3) b = np.array([10,10,10]) print ('两个数组相加：')print (np.add(a,b))print ('两个数组相减：')print (np.subtract(a,b))print ('两个数组相乘：')print (np.multiply(a,b))print ('两个数组相除：')print (np.divide(a,b) 计算数组元素的倒数numpy.reciprocal()函数返回参数逐元素的倒数。如 1/4 倒数为 4/1。1234import numpy as np a = np.array([0.25, 1.33, 1, 100]) print (np.reciprocal(a)) 计算数组的幂numpy.power()函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。12345678910import numpy as np a = np.array([10,100,1000]) print (np.power(a,2))# 结果：[ 100 10000 1000000]b = np.array([1,2,3]) print (np.power(a,b))# 结果：[ 10 10000 1000000000] 计算数组的余数numpy.mod()计算输入数组中相应元素的相除后的余数。 函数 numpy.remainder()也产生相同的结果。1234567import numpy as np a = np.array([10,20,30]) b = np.array([3,5,7]) print (np.mod(a,b))print (np.remainder(a,b))# 结果：[1 0 2]","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"08-数学函数","slug":"numpy教程/08-数学函数","date":"2020-05-25T16:23:55.000Z","updated":"2020-05-27T07:27:30.144Z","comments":true,"path":"numpy教程/08-数学函数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/08-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/","excerpt":"","text":"NumPy 包含大量的各种数学运算的函数，包括三角函数，算术运算的函数，复数处理函数等。 三角函数NumPy 提供了标准的三角函数：sin()、cos()、tan()。arcsin，arccos，和arctan函数返回给定角度的sin，cos和tan的反三角函数。这些函数的结果可以通过numpy.degrees()函数将弧度转换为角度。1234567891011121314151617181920212223242526272829303132333435import numpy as np a = np.array([0,30,45,60,90]) print ('含有正弦值的数组：')sin = np.sin(a*np.pi/180) print (sin)print ('\\n')print ('计算角度的反正弦，返回值以弧度为单位：')inv = np.arcsin(sin) print (inv)print ('\\n')print ('通过转化为角度制来检查结果：')print (np.degrees(inv))print ('\\n')print ('arccos 和 arctan 函数行为类似：')cos = np.cos(a*np.pi/180) print (cos)print ('\\n')print ('反余弦：')inv = np.arccos(cos) print (inv)print ('\\n')print ('角度制单位：')print (np.degrees(inv))print ('\\n')print ('tan 函数：')tan = np.tan(a*np.pi/180) print (tan)print ('\\n')print ('反正切：')inv = np.arctan(tan) print (inv)print ('\\n')print ('角度制单位：')print (np.degrees(inv)) 舍入函数numpy.around()函数返回指定数字的四舍五入值。12345678910# 格式# a:数组；decimals:舍入的小数位数，默认值为0。如果为负，整数将四舍五入到小数点左侧位置numpy.around(a,decimals)# 实例import numpy as npa = np.array([1.0,5.55, 123, 0.567, 25.532])print (np.around(a))print (np.around(a, decimals = 1))print (np.around(a, decimals = -1))numpy.floor()返回数字的下舍整数。12345import numpy as np a = np.array([-1.7, 1.5, -0.2, 0.6, 10])print (np.floor(a))# 修改后的数组：[-2. 1. -1. 0. 10.]numpy.ceil()返回数字的上入整数。12345import numpy as np a = np.array([-1.7, 1.5, -0.2, 0.6, 10]) print (np.ceil(a))# 修改后的数组：[-1. 2. -0. 1. 10.]","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"07-位运算","slug":"numpy教程/07-位运算","date":"2020-05-25T16:23:12.000Z","updated":"2020-05-27T07:27:26.723Z","comments":true,"path":"numpy教程/07-位运算/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/07-%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"NumPy 位运算bitwise_开头的函数就是位运算函数。NumPy 位运算包括以下几个函数：函数描述bitwise_and对数组元素执行位与操作bitwise_or对数组元素执行位或操作invert按位取反left_shift向左移动二进制标志的位right_shift向右移动二进制表示的位注：也可以使用&amp;、~、|和^等操作符进行计算 bitwise_andbitwise_and()函数对数组中整数的二进制形式执行位与运算。与运算只要有一个0结果就为0,只有两个1的情况下结果才是1。123456789import numpy as np print ('13 和 17 的二进制形式：')a,b = 13,17print (bin(a), bin(b))print ('\\n') print ('13 和 17 的位与：')print (np.bitwise_and(13, 17)) bitwise_orbitwise_or()函数对数组中整数的二进制形式执行位或运算。或运算只要有一个1结果就为1,只有两个0的情况下结果才是0。12345678import numpy as np a,b = 13,17 print ('13 和 17 的二进制形式：')print (bin(a), bin(b)) print ('13 和 17 的位或：')print (np.bitwise_or(13, 17)) invertinvert()函数对数组中整数进行位取反运算，即0变成1，1变成0。对于有符号整数，取该二进制数的补码，然后+1。二进制数，最高位为0表示正数，最高位为1表示负数。看看~1的计算步骤：将1(这里叫：原码)转二进制 ＝ 00000001按位取反 ＝ 11111110发现符号位(即最高位)为1(表示负数)，将除符号位之外的其他数字取反 ＝ 10000001末位加1取其补码 ＝ 10000010转换回十进制 ＝ -212345678910111213import numpy as np print ('13 的位反转，其中 ndarray 的 dtype 是 uint8：')print (np.invert(np.array([13], dtype = np.uint8)))print ('\\n')# 比较 13 和 242 的二进制表示，我们发现了位的反转 print ('13 的二进制表示：')print (np.binary_repr(13, width = 8))print ('\\n') print ('242 的二进制表示：')print (np.binary_repr(242, width = 8)) left_shift 和 right_shiftleft_shift()函数将数组元素的二进制形式向左移动到指定位置，右侧附加相等数量的0。right_shift()函数将数组元素的二进制形式向右移动到指定位置，左侧附加相等数量的0。123456# 左移一位相当于乘2，右移一位相当于除以2print ('将 10 左移两位：')print (np.left_shift(10,2))print ('将 4 右移两位：')print (np.right_shift(4,2))","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"06-数组操作","slug":"numpy教程/06-数组操作","date":"2020-05-25T16:21:58.000Z","updated":"2020-05-27T07:27:22.815Z","comments":true,"path":"numpy教程/06-数组操作/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/06-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"NumPy 数组操作 修改数组形状函数描述reshape不改变数据的条件下修改形状flat数组元素迭代器flatten返回一份数组拷贝，对拷贝所作的修改不会影响原始数组ravel返回展开数组12345678910111213141516171819202122# numpy.reshape函数可以在不改变数据的条件下修改形状,，格式如下：# arr:要修改形状的数组；newshape:整数或者整数数组，新形状应该兼容原有形状；order:C-按行，F-按列，A-原顺序，k-在内存中的顺序numpy.reshape(arr, newshape,order='C')a = np.arange(8)b = a.reshape(4,2)# numpy.ndarray.flat 是一个数组元素迭代器a = np.arange(9).reshape(3,3)#对数组中每个元素都进行处理，可以使用flat属性，该属性是一个数组元素迭代器：for element in a.flat: print (element)# numpy.ndarray.flatten返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，格式如下：ndarray.flatten(order='C')a = np.arange(8).reshape(2,4)b = a.flatten(order='F')# numpy.ravel()展平的数组元素，顺序通常是\"C风格\"，返回的是数组视图（view，有点类似C/C++引用reference的意味），修改会影响原始数组。# 该函数接收两个参数：numpy.ravel(a, order='C')a = np.arange(8).reshape(2,4)a.ravel(order = 'F') 翻转数组函数描述transpose转置，对换数组的维度ndarray.T转置rollaxis向后滚动指定的轴swapaxes对换数组的两个轴1234567891011121314151617181920# numpy.transpose 函数用于对换数组的维度，格式如下：# arr：要操作的数组；axes：整数列表，对应维度，通常所有维度都会对换numpy.transpose(arr, axes)a = np.arange(12).reshape(3,4)# 下面两条语句效果一样np.transpose(a)a.T# numpy.rollaxis函数向后滚动特定的轴到一个特定位置，格式如下：# arr：数组;axis：要向后滚动的轴，其它轴的相对位置不会改变;start：默认为零，表示完整的滚动。会滚动到特定位置。numpy.rollaxis(arr, axis, start)# 创建三维的ndarraya = np.arange(8).reshape(2,2,2)np.rollaxis(a,2,1)# numpy.swapaxes函数用于交换数组的两个轴，格式如下：numpy.swapaxes(arr, axis1, axis2)a = np.arange(8).reshape(2,2,2)# 现在交换轴 0（深度方向）到轴 2（宽度方向）np.swapaxes(a, 2, 0) 修改数组维度维度描述broadcast产生模仿广播的对象broadcast_to将数组广播到新形状expand_dims扩展数组的形状squeeze从数组的形状删除一维条目1234567891011121314151617181920# numpy.broadcast用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。x = np.array([[1], [2], [3]])y = np.array([4, 5, 6])# 对 y 广播 xb = np.broadcast(x,y) # numpy.broadcast_to函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。numpy.broadcast_to(array, shape, subok)a = np.arange(4).reshape(1,4)np.broadcast_to(a,(4,4))# numpy.expand_dims函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下:numpy.expand_dims(arr, axis)x = np.array(([1,2],[3,4]))y = np.expand_dims(x, axis = 0)# numpy.squeeze函数从给定数组的形状中删除一维的条目，函数格式如下：numpy.squeeze(arr, axis)x = np.arange(9).reshape(1,3,3)y = np.squeeze(x) 连接数组函数描述concatenate连接沿现有轴的数组序列stack沿着新的轴加入一系列数组hstack水平堆叠序列中的数组（列方向）vstack竖直堆叠序列中的数组（行方向）12345678910111213141516# numpy.concatenate函数用于沿指定轴连接相同形状的两个或多个数组，格式如下：numpy.concatenate((a1, a2, ...), axis)a = np.array([[1,2],[3,4]])b = np.array([[5,6],[7,8]])np.concatenate((a,b),axis = 1)# numpy.stack 函数用于沿新轴连接数组序列，格式如下：numpy.stack(arrays, axis)a = np.array([[1,2],[3,4]])b = np.array([[5,6],[7,8]])np.stack((a,b),1)# numpy.hstack是numpy.stack函数的变体，它通过水平堆叠来生成数组# numpy.vstack是numpy.stack函数的变体，它通过垂直堆叠来生成数组np.hstack((a,b))np.vstack((a,b)) 分隔数组函数数组及操作split将一个数组分割为多个子数组hsplit将一个数组水平分割为多个子数组（按列）vsplit将一个数组垂直分割为多个子数组（按行）12345678910111213141516171819# numpy.split函数沿特定的轴将数组分割为子数组，格式如下：# ary：被分割的数组# indices_or_sections：果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭# axis：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分numpy.split(ary, indices_or_sections, axis)a = np.arange(9)# 将数组分为三个大小相等的子数组b = np.split(a,3)# 将数组在一维数组中表明的位置分割b = np.split(a,[4,7])# numpy.hsplit函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组harr = np.floor(10 * np.random.random((2, 6)))np.hsplit(harr, 3)# numpy.vsplit沿着垂直轴分割，其分割方式与hsplit用法相同a = np.arange(16).reshape(4,4)b = np.vsplit(a,2) 数组元素的添加与删除函数元素及描述resize返回指定形状的数组append将值添加到数组末尾insert沿指定轴将值添加到指定下标之前delete删除某个轴的子数组，并返回删除后的新数组unique查找数组内的唯一元素123456789101112131415161718192021222324252627282930313233343536373839404142# numpy.resize 函数返回指定大小的新数组# 如果新数组大小大于原始大小，则包含原始数组中的元素的副本# arr：要修改大小的数组;shape：返回数组的新形状numpy.resize(arr, shape)a = np.array([[1,2,3],[4,5,6]])b = np.resize(a, (3,2))# numpy.append函数在数组的末尾添加值# 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError# append 函数返回的始终是一个一维数组# arr：输入数组;values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）# axis：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）numpy.append(arr, values, axis=None)a = np.array([[1,2,3],[4,5,6]])b = np.append(a, [7,8,9])# numpy.insert函数在给定索引之前，沿给定轴在输入数组中插入值# 如果值的类型转换为要插入，则它与输入数组不同。插入没有原地的，函数会返回一个新数组。此外，如果未提供轴，则输入数组会被展开。numpy.insert(arr, obj, values, axis)a = np.array([[1,2],[3,4],[5,6]])# 未传递 Axis 参数。 在插入之前输入数组会被展开np.insert(a,3,[11,12])# 传递了 Axis 参数。 会广播值数组来配输入数组np.insert(a,1,[11],axis = 0)# numpy.delete函数返回从输入数组中删除指定子数组的新数组。与 insert()函数的情况一样，如果未提供轴参数，则输入数组将展开。Numpy.delete(arr, obj, axis)a = np.arange(12).reshape(3,4)# 删除第二列np.delete(a,1,axis = 1)# numpy.unique函数用于去除数组中的重复元素# arr：输入数组，如果不是一维数组则会展开# return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储# return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储# return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数numpy.unique(arr, return_index, return_inverse, return_counts)a = np.array([5,2,6,2,7,5,6,8,2,9])# 去重值和去重数组的索引数组u,indices = np.unique(a, return_index = True)# 返回去重元素的重复数量u,indices = np.unique(a,return_counts = True)","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"05-广播与迭代","slug":"numpy教程/05-广播与迭代","date":"2020-05-25T16:04:37.000Z","updated":"2020-05-27T07:27:19.762Z","comments":true,"path":"numpy教程/05-广播与迭代/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/05-%E5%B9%BF%E6%92%AD%E4%B8%8E%E8%BF%AD%E4%BB%A3/","excerpt":"","text":"NumPy 广播（Broadcast）广播(Broadcast)是numpy对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。如果两个数组 a 和 b 形状相同，即满足a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。广播的规则：让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。输出数组的形状是输入数组形状的各个维度上的最大值。如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。**简单理解：**对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足数组拥有相同形状。当前维度的值相等。当前维度的值有一个是 1。若条件不满足，抛出ValueError: frames are not aligned异常。12345678import numpy as np # 4x3 的二维数组与长为 3 的一维数组相加，等效于把数组 b 在二维上重复 4 次再运算a = np.array([[ 0, 0, 0], [10,10,10], [20,20,20], [30,30,30]])b = np.array([1,2,3])print(a + b) NumPy 迭代数组NumPy迭代器对象numpy.nditer提供了一种灵活访问一个或者多个数组元素的方式。迭代器最基本的任务的可以完成对数组元素的访问。12345678910# 用 arange() 函数创建一个 2X3 数组，并使用 nditer 对它进行迭代。import numpy as npa = np.arange(6).reshape(2,3)print ('原始数组是：')print (a)print ('\\n')print ('迭代输出元素：')for x in np.nditer(a): print (x, end=\", \" )print ('\\n')以上实例不是使用标准C或者Fortran顺序，选择的顺序是和数组内存布局一致的，这样做是为了提升访问的效率，默认是行序优先（row-major order，或者说是C-order）。这反映了默认情况下只需访问每个元素，而无需考虑其特定顺序。 控制遍历顺序for x in np.nditer(a, order='F'):Fortran order，即是列序优先；for x in np.nditer(a.T, order='C'):C order，即是行序优先； 修改数组中元素的值nditer对象有另一个可选参数op_flags。 默认情况下，nditer将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。12345678910import numpy as npa = np.arange(0,60,5) a = a.reshape(3,4) print ('原始数组是：')print (a)print ('\\n')for x in np.nditer(a, op_flags=['readwrite']): x[...]=2*x print ('修改后的数组是：')print (a) 使用外部循环nditer类的构造器拥有flags参数，它可以接受下列值：参数描述c_index可以跟踪C顺序的索引f_index可以跟踪Fortran顺序的索引multi-index每次迭代可以跟踪一种索引类型external_loop给出的值是具有多个值的一维数组，而不是零维数组123456789import numpy as np a = np.arange(0,60,5) a = a.reshape(3,4) print ('原始数组是：')print (a)print ('\\n')print ('修改后的数组是：')for x in np.nditer(a, flags = ['external_loop'], order = 'F'): print (x, end=\", \" ) 广播迭代如果两个数组是可广播的，nditer组合对象能够同时迭代它们。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。1234567891011121314import numpy as np a = np.arange(0,60,5) a = a.reshape(3,4) print ('第一个数组为：')print (a)print ('\\n')print ('第二个数组为：')b = np.array([1, 2, 3, 4], dtype = int) print (b)print ('\\n')print ('修改后的数组为：')for x,y in np.nditer([a,b]): print (\"%d:%d\" % (x,y), end=\", \" )","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"04-切片与索引","slug":"numpy教程/04-切片与索引","date":"2020-05-25T16:03:19.000Z","updated":"2020-05-27T07:27:14.782Z","comments":true,"path":"numpy教程/04-切片与索引/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/04-%E5%88%87%E7%89%87%E4%B8%8E%E7%B4%A2%E5%BC%95/","excerpt":"","text":"NumPy 切片和索引ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中list的切片操作一样。ndarray数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的slice函数，并设置start, stop及step参数进行，从原数组中切割出一个新数组。我们可以通过冒号分隔切片参数start:stop:step来进行切片操作：12345678import numpy as np a = np.arange(10)# 从索引 2 开始到索引 7 停止，间隔为2s = slice(2,7,2) print (a[s])# 从索引 2 开始到索引 7 停止，间隔为 2b = a[2:7:2] 冒号:的解释(重点)如果只放置一个参数，如[2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如[2:7]，那么则提取两个索引(不包括停止索引)之间的项。1234567import numpy as npa = np.arange(10) # [0 1 2 3 4 5 6 7 8 9]b = a[5] # 5a[2:] # [2 3 4 5 6 7 8 9]a[2:5] # [2 3 4]a = np.array([[1,2,3],[3,4,5],[4,5,6]])a[1:] # [[3 4 5] [4 5 6]]切片还可以包括省略号…，来使选择元组的长度与数组的维度相同。如果在行位置使用省略号，它将返回包含行中元素的ndarray。1234a = np.array([[1,2,3],[3,4,5],[4,5,6]])print (a[...,1]) # 第2列元素print (a[1,...]) # 第2行元素print (a[...,1:]) # 第2列及剩下的所有元素 NumPy 高级索引NumPy比一般的 Python 序列提供更多的索引方式。除了之前看到的用整数和切片的索引外，数组可以由整数数组索引、布尔索引及花式索引。 整数数组索引以下实例获取数组中(0,0)，(1,1)和(2,0)位置处的元素。1234567import numpy as np x = np.array([[1, 2], [3, 4], [5, 6]]) y = x[[0,1,2], [0,1,0]] print (y)# 输出结果# [1 4 5]以下实例获取了 4X3 数组中的四个角的元素。 行索引是 [0,0] 和 [3,3]，而列索引是 [0,2] 和 [0,2]。12345678910111213141516import numpy as np x = np.array([[ 0, 1, 2],[ 3, 4, 5],[ 6, 7, 8],[ 9, 10, 11]]) print ('我们的数组是：' )print (x)print ('\\n')rows = np.array([[0,0],[3,3]]) cols = np.array([[0,2],[0,2]]) y = x[rows,cols] print ('这个数组的四个角元素是：')print (y)''' 结果如下：[[ 0, 2], [ 9, 11]]'''可以借助切片:或…与索引数组组合。如下面例子：1234567import numpy as np a = np.array([[1,2,3], [4,5,6],[7,8,9]])b = a[1:3, 1:3] # 取2、3行的第2、3列c = a[1:3,[1,2]] # 取2、3行的第2和3个元素d = a[...,1:] # 取第2列和后面的所有列 布尔索引我们可以通过一个布尔数组来索引目标数组。布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。123456789101112131415import numpy as np # 获取大于 5 的元素x = np.array([[ 0, 1, 2],[ 3, 4, 5],[ 6, 7, 8],[ 9, 10, 11]]) print ('我们的数组是：')print (x)print ('\\n')# 现在我们会打印出大于 5 的元素 print ('大于 5 的元素是：')print (x[x &gt; 5])# 使用了 ~（取补运算符）来过滤 NaNa = np.array([np.nan, 1,2,np.nan,3,4,5]) print (a[~np.isnan(a)])# 从数组中过滤掉非复数元素a = np.array([1, 2+6j, 5, 3.5+5j])a[np.iscomplex(a)] 花式索引花式索引指的是利用整数数组进行索引。花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。花式索引跟切片不一样，它总是将数据复制到新数组中。1234567891011import numpy as np # 传入顺序索引数组x=np.arange(32).reshape((8,4))print (x[[4,2,1,7]])# 传入倒序索引数组x=np.arange(32).reshape((8,4))print (x[[-4,-2,-1,-7]])# 传入多个索引数组（要使用np.ix_）x=np.arange(32).reshape((8,4))print (x[np.ix_([1,5,7,2],[0,3,1,2])])","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"03-数组","slug":"numpy教程/03-数组","date":"2020-05-25T16:01:51.000Z","updated":"2020-05-27T07:27:11.193Z","comments":true,"path":"numpy教程/03-数组/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/03-%E6%95%B0%E7%BB%84/","excerpt":"","text":"NumPy数组属性NumPy 数组的维数称为秩（rank），一维数组的秩为 1，二维数组的秩为 2，以此类推。在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作。NumPy 的数组中比较重要ndarray对象属性有：属性说明ndarray.ndim秩，即轴的数量或维度的数量ndarray.shape数组的维度，对于矩阵，n行m列ndarray.size数组元素的总个数,n*mndarray.dtypendarray对象的元素类型ndarray.itemsizendarray对象中每个元素的大小，以字节为单位ndarray.flagsndarray对象的内部信息ndarray.realndarray元素的实部ndarray.imagndarray元素的虚部ndarray.data包含实际数组元素的缓冲区，一般通过数组索引获取元素，所以不需要使用这个属性 NumPy创建数组ndarray数组除了可以使用底层ndarray构造器来创建外，也可以通过以下几种方式来创建。 numpy.emptynumpy.empty方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：123456789# 格式numpy.empty(shape, dtype=float, order='C')# 实例x = numpy.empty([3,2],dtype=int)''' 结果如下：里面的数据将会随机生成[[ 5.11798224e-307 3.44897992e-307] [ 1.24610383e-306 1.37961709e-306] [ 1.29057883e-306 1.24610927e-306]]'''参数说明：参数说明shape数组形状dtype数据类型，可选order有’C’和’F’两个选项，分别代表行优先和列优先，在计算机内存中存储元素的顺序注意 数组元素为随机值，因为它们未初始化 numpy.zeros创建指定大小的数组，数组元素以 0 来填充：1234567891011# 格式numpy.zeros(shape, dtype=float, order='C')# 实例# 默认为浮点数x = numpy.zeros(5) # 1*5的矩阵y = numpy.zeros([2,3],dtype=np.int) # 2*3的矩阵''' 结果如下:[ 0. 0. 0. 0. 0.][[ 0. 0. 0.] [ 0. 0. 0.]]''' numpy.ones创建指定形状的数组，数组元素以 1 来填充：12345678# 格式numpy.ones(shape, dtype = None, order = 'C')# 实例x = np.ones([2,2], dtype = int)''' 结果如下：[[1 1] [1 1]]''' NumPy从已有的数组创建数组 numpy.asarray12345# 格式numpy.asarray(a, dtype = None, order = None)# 实例x = [[1,2,3],[4,5,6]]a = numpy.asarray(x)参数说明参数描述a任意形式的输入参数，可以是列表、元组、多维数组等dtype数据类型，可选order可选，有&quot;C&quot;和&quot;F&quot;两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。 numpy.frombuffernumpy.frombuffer用于实现动态数组。numpy.frombuffer接受buffer输入参数，以流的形式读入转化成ndarray 对象。123456# 格式numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)# 实例s = b'Hello World' a = numpy.frombuffer(s, dtype = 'S1') print (a)注意 buffer是字符串的时候，Python3 默认str是Unicode类型，所以要转成bytestring在原str前加上 b。参数说明参数说明buffer可以是任意对象，会以流的形式读入。dtype可选，数据类型count读取的数据数量，默认为-1，读取所有数据offset读取的起始位置，默认为0 numpy.fromiternumpy.fromiter方法从可迭代对象中建立 ndarray`对象，返回一维数组。123456789# 格式numpy.fromiter(iterable, dtype, count=-1)# 实例# 使用 range 函数创建列表对象 list=range(5)it=iter(list) # 使用迭代器创建 ndarray x=numpy.fromiter(it, dtype=float)参数说明iterable可迭代对象dtype返回的数组的数据类型count读取的数据量，默认为-1，读取所有数据 NumPy 从数值范围创建数组 numpy.arangenumpy包中的使用arange函数创建数值范围并返回ndarray对象，函数格式如下：12345678numpy.arange(start, stop, step, dtype)# 实例：生成 0 到 5 的数组x = numpy.arange(5)# 指定数据类型x = numpy.arange(5, dtype=float)# 设置起始值、终止值和步长x = numpy.arange(10, 20, 2)根据start与stop指定的范围以及step 设定的步长，生成一个ndarray。参数说明：参数说明start起始值，默认为0stop终止值（不包含）step步长，默认为1dtype返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型 numpy.linspacenumpy.linspace函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下：12345678910numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)# 实例# 设置起始点为 1 ，终止点为 10，数列个数为 10a = numpy.linspace(1,10,10)''' 结果如下[ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10.]'''# 设置10个全是1的数列a = numpy.linspace(1,1,10)参数说明：参数说明start起始值，默认为0stop终止值，如果endpoint为true，该值包含在数列中num要生成的等步长的样本数量，默认为50endpoint是否包含终止值，默认为Trueretstep如果为True，生成的数组中会显示间距，反之不显示dtypendarray的数据类型 numpy.logspacenumpy.logspace函数用于创建一个于等比数列di=baseid_i=base^idi​=basei。格式如下：1234567numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)# 实例# 默认底数是 10a = numpy.logspace(1.0,2.0,num=10)# 设置底数是2a = numpy.logspace(0,9,10,base=2)参数描述start序列的起始值为：base**startstop序列终止值为：base**stop。如果endpoint为true，该值包含在序列中num要生成的等步长的样本数量，默认为50endpoint是否包含终止值，默认为Truebase对数log的底数dtypendarray的数据类型","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"02-数据对象","slug":"numpy教程/02-数据对象","date":"2020-05-25T16:01:10.000Z","updated":"2020-05-27T07:26:32.491Z","comments":true,"path":"numpy教程/02-数据对象/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/02-%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"Numpy数据类型numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型。名称描述bool_布尔型数据类型（True或者False）int8/16/32/64整数unit8/16/32/64无符号整数float16/32/64半/单/双精度浮点数complex64/128复数numpy 的数值类型实际上是dtype对象的实例，并对应唯一的字符，包括np.bool_，np.int32，np.float32等等。 数据类型对象(dtype)数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：数据的类型（整数，浮点数或者Python对象）数据的大小（例如整数用多少字节存储）数据的字节顺序（小端法或大端法）在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分如果数据类型是子数组，它的形状和数据类型字节顺序是通过对数据类型预先设定&lt;或&gt;来决定的。&lt;意味着小端法（最小值存储在最小的地址，即低位放前面）。&gt;意味着大端法（最重要的字节存储在最小的地址，即高位组放在最前面）。dtype对象是使用以下语法构造的：1numpy.dtype(object, align, copy)object-要转换为的数据类型对象align-如果为true,填充字段使其类似C的结构体copy-复制dtype对象，如果为false，则是内置数据类型对象的引用","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"01-numpy导论","slug":"numpy教程/01-numpy导论","date":"2020-05-25T15:24:43.000Z","updated":"2020-05-27T07:25:34.154Z","comments":true,"path":"numpy教程/01-numpy导论/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/01-numpy%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"什么是 NumPyNumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。NumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含：一个强大的 NNN 维数组对象ndarray广播功能函数整合 C/C++/Fortran 代码的工具线性代数、傅里叶变换、随机数生成等功能 NumPy Ndarray对象NumPy 最重要的一个特点是其N维数组对象ndarray，它是一系列同类型数据的集合，以0下标为开始进行集合中元素的索引。ndarray对象是用于存放同类型元素的多维数组。ndarray中的每个元素在内存中都有相同存储大小的区域。ndarray内部由以下内容组成：一个指向数据（内存或内存映射文件中的一块数据）的指针。数据类型或dtype，描述在数组中的固定大小值的格子。一个表示数组形状（shape）的元组，表示各维度大小的元组。一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要&quot;跨过&quot;的字节数。跨度可以是负数，这样会使数组在内存中后向移动，切片中obj[::-1]或obj[:,::-1]就是如此。 创建ndarray对象1numpy.array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)参数说明:名称描述object数组或嵌套的数列dtype数据元素的数据类型，可选copy对象是否需要复制，可选order创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）subok默认返回一个与基本类型一致的数组ndmin指定生成数组的最小维度下面给出示例代码创建实例：123import numpy as npa = np.array([[1,2,3],[4,5,6]])b = np.array([1,2,3],dtype=complex,ndmin=2)ndarray对象由计算机内存的连续一维部分组成，并结合索引模式，将每个元素映射到内存块中的一个位置。内存块以行顺序(C样式)或列顺序(FORTRAN或MatLab风格，即前述的F样式)来保存元素。","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"06-访问权限控制","slug":"Java编程思想/06-访问权限控制","date":"2020-05-25T15:15:28.000Z","updated":"2020-05-27T07:24:19.015Z","comments":true,"path":"Java编程思想/06-访问权限控制/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/06-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/","excerpt":"","text":"访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关。重构即重写代码，以使它更可读、更易理解、更高效，并因此而更具可维护性。但在这种修改和完善代码的愿景之下，也存在着巨大的压力。第一是资源（主要指时间、开发效率）浪费，二是客户端程序员需要你的代码在某些方面（即调用的接口方法）保持不变。因此你想改变代码，而他们却想让代码保持不变。这对于类库（library）而言尤其重要。为了解决这个问题，Java提供了访问权限修饰词，以供类库开发人员向客户端程序员指明哪些是可用的，哪些不可用。访问权限修饰词等级从权限最大到权限最小依次为：publicprotected包访问权限（默认不加访问权限关键词）private你会尽可能将一切方法都定为private，而仅向客户端程序员公开你愿意让他们使用的方法。对于如何将构件捆绑到一个内聚的类库单元的问题，Java用关键字package加以控制，而访问权限会因为类是否存在于相同的包中受到影响。 包：库单元包内包含有一组类，它们在单一的名字空间之下被组织在了一起。例如，在Java标准发布中有一个工具库，它被组织在java.util名字空间之下。java.util中存在有一个叫ArrayList的类，那么使用ArrayList类的一种方式是使用其全限定名字:java.util.ArrayList。1java.util.ArrayList list = new java.util.ArrayList();这会使得程序变得十分冗长，因此Java提供了import关键字帮助我们去简化。使用import关键字的意思是将全限定名字与简单名字(simple-name)做一个绑定，因此可以下面的代码编写中使用简单名字去替代全限定名字。123456import java.util.ArrayList;public class Test&#123; public static main(String[] args)&#123; ArrayList list = new ArrayList(); &#125;&#125;但是这样做，java.util中的其他类仍旧是不可用简单名字的。要想导入其中所有的类，只需要使用*，如import java.util.*。但个人并不推荐这种方式，应该是使用一个类并导入其对应的全限定名字，这样会使程序更稳健快速（因为在不同的名字空间下有许多相同的类名）。我们之所以要导入，就是要提供一个管理名字空间的机制。所有类成员的名称都是彼此隔离的。当编写一个Java源文件时，此文件通常被称为编译单元（或转译单元）。每个编译单元都必须有一个后缀名.java，而在编译单元中最多可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，不包括后缀名.java）。每个编译单元只能有一个public类，否则编译器会提示出错。如果在编译单元之中还有其他额外的类的话，那么在包之外的世界是无法看见这些类的（因为不加关键字默认是包访问权限），它们主要是为主public类提供支持。 代码组织当编译一个.java文件时，在.java文件中的每个类都会有一个输出文件，而该输出文件的名称与每个类的名称相同，只是多了一个后缀名.class。一般来说，编译型语言的编译流程如下：对于编译器根据编译单元产生一个中间文件（通常是obj文件），然后再将中间文件通过链接器（用以创建一个可执行文件）或类库产生器（librarian，用以创建一个类库）产生的其他同类文件捆绑起来。但这并不是Java的工作方式。Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR）的.class文件。Java解释器负责这些文件的查找、装载和解释。类库实际上是一组类文件。其中每个文件都有一个public类，一人任意数量的非public类。因此每个文件都有一个构件，如果希望这些构件从属于同一个群组，就可以使用关键字package。package语句必须是文件除注释以外的第一句程序代码。package和import关键字允许你做的是，将单一的全局名字空间分割开，使得无论多少人使用Internet和Java开始编写类，都不会出现名称冲突的情况。 创建独一无二的包名一种合乎逻辑的做法就是将特定包的所有.class文件都置于一个目录下。也就是说，利用操作系统的层次化的文件结构来解决混乱问题。将所有的同一类文件收入一个子目录还可以解决另外两个问题：怎样创建独一无二的名称怎么查找有可能隐藏于目录结构中某处的类这些任务是通过将.class文件所在的路径位置编码成package的名称来实现的。Java解释器的运行过程如下：首先找到环境变量CLASSPATH；CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，以从CLASSPATH跟中产生一个目录名称。得到的路径会与CLASSPATH的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类名称相关的.class文件。 定制工具库现在可以创建自己的工具库来减少或消除重复的程序代码，并可以使用一个更具可读性的静态import语句来导入：123456package cn.hengxin.utilpublic class Print&#123; public static void print(Object obj)&#123; System.out.println(obj); &#125;&#125;123456import cn.hengxin.util.Printpublic class PrintTest&#123; public static void main(String[] args)&#123; Print(\"Available from now on!\"); &#125;&#125; 用import改变行为Java没有C的条件编译功能，该功能可以使你不必更改任何程序代码，就能切换开关并产生不同的行为。Java去掉功能的原因可能是因为C在绝大多数情况下是用此功能来解决跨平台问题，即程序代码的不同部分是根据不同的平台来编译。由于Java本身可以自动跨越不同的平台，因此这个功能对Java而言是没有必要的。 Java访问权限修饰词 包访问权限默认访问权限没有任何关键字，但通常是指包访问权限（或friendly），这意味着当前包的所有其他类对那个成员都有访问权限，但对于这个包之外的所有类，这个成员却是private。包访问权限允许将包内所有相关的类组合起来，以使它们彼此之间可以轻松地相互作用。 public：接口访问权限使用关键字public就意味着之后紧跟的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。 private：你无法访问关键字private的意思是，除了包含该成员的类之外，其他任何类都无法访问这个成员，等于说是自己隔离了自己。private的使用是十分重要的，在多线程环境下更是如此。任何可以肯定是该类的一个“助手”都可以把它指定为private，以确保不会在包内的其他地方误用它，于是也就防止了你会去改变或删除这个方法。 protected：继承访问权限关键字protected处理的是继承的概念，通过继承可以利用一个现有类（称之为基类），然后将新成员添加到该现有类中而不必碰现有类，还可以改变该类的现有成员的行为。 接口和实现访问权限的控制常被称为是具体实现的隐藏。封装常被认为是：把数据和方法包装进类中，以及具体实现的隐藏。其结果是一个同时带有特征和行为的数据类型。访问权限控制将边界划在了数据类型内部：设定客户端程序员可以使用和不可以使用的界限将接口和具体实现进行分离 类的访问权限在Java中，访问权限修饰词也可以用于确定库中的哪些类对于该库的使用者是可用的。如果希望某个类可以为某个客户端程序员所用，就可以通过把关键字public作用在整个类的定义来达到目的。为了控制某个类的访问权限，**修饰词必须出现在关键字class之前。额外的限制：每个编译单元（文件）都只能有一个public类public类的名称必须完全与编译单元的文件名相匹配，包括大小写类即不可以是private也不可以是protected的。所以对于类的访问权限，仅有两个选择：包访问权限或者是public。如果不希望其他任何人对类拥有访问权限，可以将所有构造器都指定为private。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"05-初始化与清理","slug":"Java编程思想/05-初始化与清理","date":"2020-05-25T15:13:29.000Z","updated":"2020-05-27T07:24:10.247Z","comments":true,"path":"Java编程思想/05-初始化与清理/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/05-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/","excerpt":"","text":"随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。**初始化（initialize）和清理（cleanup）**正是涉及安全的两个问题。许多C程序的错误都源于程序员忘记初始化变量。清理也是一个特殊问题，当使用完一个元素时，容易把它忘掉，以至于这个元素占用的资源一直得不到释放，结果是计算机资源（特别是内存）用尽。C++引入了构造器（constructor）的概念，这是一个在创建对象时被自动调用的特殊方法。Java也采用了构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。 用构造器确保初始化在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果类具有构造器，Java就会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。考虑到编译器会在初始化期间自动调用构造器，构造器采用与类相同的名称。假设我们拥有以下这样一个类：12345class Rock&#123; Rock()&#123; System.out.println(\"I'm Rock!\"); &#125;&#125;现在，在创建对象时new Rock()，将会为对象分配存储空间，并调用相应的构造器。这就确保了在你能操作对象之前，它已经被恰当地初始化了。注意：构造器也是一个方法，但是这个方法与其他方法不一样的地方在于，不需要为其声明任何返回类型。不接受任何参数的构造器叫做默认构造器，Java文档中通常使用术语无参构造器。和其他方法一样，构造器也能带有形式参数，以便指定如何创建对象。1234567891011class Speaker&#123; // 这是无参构造器 Speaker()&#123; System.out.println(\"Sorry, I don't know who you are!\"); &#125; // 这是有参构造器 Speaker(String name)&#123; System.out.println(\"Hello\" + name + \"!\"); &#125;&#125;从概念上讲，“初始化”与“创建”是彼此独立的。但在Java中，“初始化”与“创建”捆绑在一起，两者不能分离。**构造器是一种特殊类型的方法，因为它没有返回值（不是指void，带有void的方法实际上返回的是一个void类型的变量）。**需要注意的是，new表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值。正如上述所说，其实这里是两步：创建对象与调用该对象的构造器方法（初始化），只是Java在我们new一个对象时，会自动帮我们调用其构造器方法。 方法重载任何程序设计语言都具备的一项重要特性就是名字的运用。当创建一个对象时，也就给此对象分配到的存储空间取了一个名字。所谓方法则是给某个动作取的名字。通过使用名字，你可以引用所有的对象和方法。在Java和C++里，构造器是强制重载方法名的一个重要原因。因为构造器必须与类同名，但我们又想为用户提供多种初始化的方式。为了让方法名相同而形式参数不同的构造器同时存在，必须用到方法重载，同时其亦可用于其他方法且用法相同。12345678910111213141516171819class Speaker&#123; // 这是无参构造器 Speaker()&#123; System.out.println(\"Sorry, I don't know who you are!\"); &#125; // 重载：这是有参构造器 Speaker(String name)&#123; System.out.println(\"Hello\" + name + \"!\"); &#125; // 方法sayHello() void sayHello()&#123; System.out.println(\"Hello world\"); &#125; // 重载方法sayHello(),向具体的人 void sayHello(String name)&#123; System.out.println(\"Hello\" + name + \"!\"); &#125;&#125; 区分重载方法每个重载的方法都必须有一个有一个独一无二的参数类型列表。在Java中，编译器是通过方法名+参数列表作为唯一的方法签名去识别具体调用哪个方法。 涉及基本类型的重载基本类型能从一个“较小”的类型自动提升至一个“较大”的类型，此类型一旦牵涉到重载，可能会造成一些混淆。1234567891011class PrimitiveOverloading&#123; // void f1(char x)&#123;System.out.println(\"char\");&#125; // void f1(byte x)&#123;System.out.println(\"byte\");&#125; void f1(int x)&#123;System.out.println(\"int\");&#125; void f1(float x)&#123;System.out.println(\"float\");&#125; // void f1(double x)&#123;System.out.println(\"double\");&#125;&#125;// 下面的输出是:intnew PrimitiveOverloading().f1('c');// 下面会编译器报错new PrimitiveOverloading().f1(5.0D);从上面的代码可以得出结论：如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际参数类型会被提升；如果传入的实际参数较大，就得手动通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。 以返回值区分重载方法在Java中，根据方法的返回值来区分重载方法是行不通的。因为Java是通过**方法签名（方法名+参数列表）**来标识和区分不同的方法的。 默认构造器默认构造器（又名“无参”构造器）是没有形式参数的–它的作用是创建一个“默认对象”。如果你的类中没有构造器，则编译器会自动帮你创建一个默认构造器。1class Bird&#123;&#125;上面的类中并未明确定义构造器，但你创建其对象时仍会触发默认构造器的方法，因为编译器会为你自动添加一个默认构造器。**但是，如果你已经定义了一个构造器（无论有无参数），编译器就不会帮你自动创建默认构造器。**因为编译器会认为你只允许用户由该“入口”创建并初始化该对象。 this关键字为了能用简便、面向对象的语法来编写代码–即“发送消息给对象”。在你调用对象方法时候，编译器会做一些幕后的工作，它暗自把“所操作对象的引用”作为第一个参数传递给方法。12345Person person = new Person();// 你调用sayHello()方法person.sayHello();// 实际在内部的表达形式如下Person.sayHello(person);假设你希望在方法的内部获得对当前对象的引用，可以使用关键字this。因为这个引用是由编译器“偷偷”传入的，所以没有标识符可用。**this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。**一般来说，只有当需要明确指出对当前对象的引用时，才需要使用this关键字。例如，当需要返回对当前对象的引用时，就常常在return语句里这样写:1234567public class Leaf&#123; int i = 0; Leaf increament()&#123; i++; return this; &#125;&#125; 在构造器中调用构造器可能为一个类写了多个构造器，有时可能想在一个构造器中调用另一个构造器，以避免重复代码。可以用this关键字做到这一点：123456789101112131415public class Person&#123; private String name; private String email; public Person(String name)&#123; // 如果传入参数与对象内部参数同名，需要使用this关键字加以区分 this.name = name; &#125; public Person(String name, String email)&#123; // 调用其他的构造器方法 this(name)； this.email = email; &#125;&#125;注意：构造器中调用构造器通过this(...)的方法，但该条语句必须是构造器的第一行代码。 static的含义**static（静态）方法是没有this的方法，在static方法内部不能调用非静态方法。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。**这实际正是static方法的主要用途。Java禁止全局方法，但你可以在类中置入static方法就可以访问其他static方法和static域（这句话我觉得有点问题）。1234567public class Person&#123; public static void sayHello()&#123; System.out.println(\"Hello world!\"); &#125;&#125;Person.sayHello();在上面的代码中，我们为Person类声明了一个sayHello()的静态方法。在外部，我们可以通过类名直接调用该方法，而不需要初始化该对象。 清理：终结处理和垃圾回收程序员常常忘记十分重要的清理工作。在使用程序时，把一个对象用完就“弃之不理”的做法是不安全的。当然，Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：假定你的对象（并非使用new创建）获得了一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存。为了应对这种情况，Java允许在类中定义一个名为finalize()的方法。finalize()的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。换言之，只有当“垃圾回收”发生时（不能保证一定会发生），finalize()才会得到调用。 finalize()用途何在不应该将finalize()作为通用的清理方法。请先记住下面这一点：垃圾回收只与内存有关：也就是说，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是finalize()方法），它们也必须同内存及其回收有关。之所以要有finalize()是由于分配内存时候可能采用了类似C语言的做法，而非Java中的通常做法。这种情况主要发生在使用**“本地方法”**的情况下，本地方法是一种在Java中调用非Java代码的方式。本地方法目前只支持C和C++，但它们可以调用其他语言的代码，所以实际上可以调用任何代码。 你必须实施清理要清理一个对象，用户必须在需要清理的时刻调用执行清理动作的方法。Java不允许创建局部对象，必须使用new创建对象。在Java中，也没有用于释放对象的delete，因为垃圾回收器会帮助你释放存储空间。但你现在需要知道垃圾回收器的存在并不能完全替代析折函数（而且绝对不能直接调用finalize（），这不是一种解决方案）。记住，无论是“垃圾回收”还是“终结”，都不一定保证会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存。 终结条件通常不能指望finalize()，必须创建其他的&quot;清理&quot;方法，并且明确调用它们。不过，finalize()还有一个有趣的用法，它并不依赖于每次都要对finalize()进行调用，这就是对象终结条件的验证。12345678910111213141516171819202122class Book&#123; boolean checkedOut = true; void checkIn()&#123; checkedOut = false; &#125; protected void finalize()&#123; if(checkedOut)&#123; throw new Exception(\"Error!\"); &#125; &#125; public static void main(String[] args)&#123; Book novel = new Book(); novel.checkIn(); // 忘记清理 new Book(); // 强制发生垃圾回收 System.gc(); &#125;&#125;所有的Book对象在被当作垃圾回收器前都应该被签入(check in)，在上面代码中的第二个Book对象未被签入，在发生垃圾回收时会导致异常错误。注意：System.gc()用于强制进行终止动作。 垃圾回收器如何工作在以前的程序语言中，在堆上分配对象的代价十分高昂。然而，垃圾回收器对于提高对象的创建速度，却具有明显的效果。这意味着，Java从堆分配空间的速度，可以和其他语言从堆栈上分配空间的速度相媲美。C里面的堆可以想象成一个院子，里面每个对象都负责管理自己的地盘。一段时间以后，对象可能会被销毁，但地盘必须加以重用。在某些Java虚拟机中，堆的实现截然不同：它更像一个传送带，每分配一个对象，它就往前移动一格。这就意味着对象存储空间的分配速度非常快。**Java的“堆指针”只是简单地移动到尚未分配的区域，其效率比得上C在堆栈上分配空间的效率。**但更重要的原因在于垃圾回收器的介入。当它工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样“堆指针”就可以很容易移动到更靠近传送带的开始处，也就尽量避免了页面错误。通过垃圾回收器对对象重新排列，实现了一种高速的、有无限空间可供分配的堆模型。 如何寻找垃圾引用计数是一种简单但速度很慢的垃圾回收技术。每个对象都含有一个引用计数器，当有引用连接到对象时，引用计数加1。当引用离开作用域或者置为null时，引用计数减1。垃圾回收器会在含有全部对象的列表上遍历，当发现某个对象的引用计数为0时，就释放其占有的空间。这种方法有个缺陷，如果对象之间存在循环引用，可能会出现“对象应被回收，但引用计数却不为零”的情况。如下面的代码所示：123456789101112131415class Teacher&#123; Student student;&#125;class Student&#123; Teacher teacher;&#125;class Test&#123; public static void main(String[] args)&#123; // 两个对象循环引用 Teacher teacher = new Teacher(); Student student = new Student(); teacher.student = student; student.teacher = teacher; &#125;&#125;在一些更快的模式，垃圾回收器使用可达路径，依据的思想是：对任何“活”对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。这条引用链条可能会穿过数个对象层次。由此，如果从堆栈和静态存储区开始，遍历所有的引用，就能找到所有“或的对象”。对于发现的每个引用，必须追踪到它所引用的对象，然后是此对象包含的所有引用，如此反复进行，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。在这种方式下，Java虚拟机将采用一种自适应的垃圾回收技术。 如何处理垃圾如何处理找到的存活的对象，取决于不同的Java虚拟机的实现。有一种做法叫做停止-复制（stop-and-copy）。显然这意味着，先暂停程序的运行（所以这不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有复制的全部都是垃圾。当对象复制到新堆时，它们是一个挨着一个的，所以新堆保持紧凑排列。当把对象从一处搬到一处时，所有指向它的那些引用都必须修正。位于堆或静态存储区的引用可以直接修正，但可能还有其他指向这些对象的引用，它们在遍历过程中才能被找到（可以想象有个表格，将旧地址映射到新地址）。对于这种“复制式回收器”而言，效率会降低。这有两个原因：首先，得有两个堆，然后得在这两个分离的堆上来回折腾，从而维护比实际需要多一倍的空间。某些Java虚拟机对此处理的方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块的内存之间。第二个问题在于复制。程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。此时复制回收器仍将会将所有内存自一处复制到另一处，这很浪费。为了避免上述情形，一些Java虚拟机会进行检查：要是没有新垃圾产生，就会自适应转换到另一种工作模式：标记-清扫（mark-and-sweep）（Sun公司早期版本的Java虚拟机使用该技术）。标记-清扫所依据的思路是：从堆栈和静态存储区出发，遍历所用引用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象设一个标记，这个过程不会发生任何回收对象。只有当所有标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将会被释放，不会发生复制动作。所以剩下的堆空间是不连续的。垃圾回收器如果希望得到连续空间的话，就得重新整理剩下的对象。 自适应技术如前文所述，在这里所讨论的Java虚拟机中，内存分配以较大的**“块”**为单位。如果对象较大，它会占用单独的块。严格来说，“停止-复制”要求在释放旧有对象之前，必须先把所有存活对象从旧堆复制到新堆。有了块之后，垃圾回收器在回收的时候就可以往废弃的块里拷贝对象。每个块有相应的**代数（generation count）**来记录它是否还存活。通常，如果块在某处被引用，其代数会增加；垃圾回收器会定期进行完整的清理动作–大型对象仍然不会被复制（只是其代数会增加），内含小对象的那些快则被复制斌整理。自适应技术：Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低，就会切换到“标记-清扫”方式。同样，Java虚拟机会跟踪“标记-清扫”的效果，如果堆里面出现很多碎片，就会切换为“停止-复制”方式。可以给一个罗嗦的称呼：“自适应的、分代的、停止-复制、标记-清扫”式垃圾回收器。 即时编译技术Java虚拟机有许多附加技术用以提升速度。尤其是与加载器操作有关的，被称为即时编译器技术（Just-In-Time，JIT）。这种技术可以把程序全部或部分翻译成本地机器码（这本来是Java虚拟机的工作），程序运行速度因此得到提升。当需要装载某个类（通常是在为该类创建第一个对象时），编译器为找到其.class文件，然后将该类的字节码装入内存。此时有两种方案可供选择：一是让即时编译器编译所有代码。但存在以下两种缺陷：加载动作散落在整个程序生命周期内，累加起来花更多时间；增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），将导致页面调度，从而降低程序速度二是惰性评估（lazy evaluation），意思是即时编译器只在必要的时候才编译代码。这样从不会被执行的代码也许就压根不会被JIT所编译。新版JDK中的Java HotSpot技术采用了类似方法，代码每次被执行都会做一些优化，所以执行次数越多速度就越快。 成员初始化所有变量在使用前都应得到恰当的初始化。对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。唯一有点例外的是，类的每个基本类型数据成员保证都会得到一个初始值。数据类型初始值booleanfalsechar0byte0short0int0long0float0.0double0.0referencenull 构造器初始化可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初值，这让编程变得更灵活。但需要注意：无法阻止自动初始化的进行，它将在构造器被调用前发生。123456class Test&#123; int i; test()&#123; i = 1; &#125;&#125;代码解读：变量i会先被初始化为0，再赋值为1。 初始化顺序在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。 静态数据的初始化无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准值；如果它是一个对象引用，那么它的默认初始值就是null。静态初始化只有在必要时刻才会进行，只有在第一个类对象被创建（或第一次访问静态数据）时候，它们才会被初始化。此后，静态对象不会再次被初始化，每次引用的都是同一个对象。初始化的顺序是先静态对象，而后是“非静态”对象。 显式的静态初始化Java允许将多个静态初始化动作组织成一个特殊的“静态子块”（也可称为“静态代码块”）。如：123456class Teacher&#123; static Student student; static&#123; student = new Student(); &#125;&#125; 非静态实例初始化Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量。例如：12345678public class Mugs&#123; Mug mug1; Mug mug2; &#123; mug1 = new Mug(); mug2 = new Mug(); &#125;&#125;这种语法对于支持**“匿名内部类”**的初始化时必须的，但是它也使得你可以保证无论调用哪个显式构造器，某些操作都会发生。这个代码块也是会在调用构造器执行。 数组初始化**数组是相同类型、用一个标识符名称封装到一起的一个对象序列或基本数据类型序列。**数组是通过方括号下标操作符[]来定义和使用的。要定义一个数组，只需在类型名后加上一对空括号即可：1234int[] a1;// 实际上也可以将方括号放在变量名后int a2[];// 但是后面这种方式不利于识别是一个数组对于数组，你不能直接在引用上指定大小。为了给数组创建相应的存储空间，必须写初始化表达式。对于数组，初始化动作可以出现在代码的任何地方，但也可以用一种特殊的初始化表达式，它必须在创建数组的地方出现。这种特殊的初始化是由一对花括号{}括起来的值组成。在这种情况下，存储空间的分配（等价于使用new）将由编译器负责。例如：1234// 直接给数组赋int[] a1 = &#123;1,2,3,4,5&#125;;// 开辟一个大小为5的int数组int[] a2 = new int[5];所有数组（无论它们的元素是对象还是基本类型）都有一个固定成员–length，可以通过它获知数组内包含了多少元素，但不能对其修改。与C和C++类似，Java数组计数也是从第0个元素开始，所以能使用的最大下标数是length-1。一旦你访问下标越界，就会出现运行时错误（异常，indexOfBoundException）。 可变参数列表JAVA SE5提供了一种方便的语法来创建对象并调用方法，以获得与C的**可变参数列表（varages）**一样的效果。这可以应用于参数个数或类型未知的场合。由于所有的类都直接或间接继承于Object类。123456789void printArray(Object... objects)&#123; for(Object object:objects)&#123; System.out.println(object); &#125;&#125;public static void main(String[] args)&#123; printArray(new Integer(47), new Float(3.4), new Double(11.11))&#125;打印一个类只会出现类的名称以及后面紧接着一个@符号以及多个十六进制数字，因为默认行为（没有定义toString()方法）就是打印类的名字和对象的地址。有了可变参数，就不用再显式地编写数组方法了，当你指定参数的时候，编译器实际上会为你去填充数组。获取的仍旧是一个数组。如果该参数列表中没有任何元素，那么转变成的数据的尺寸为0。 枚举类型在Java SE5中添加了一个看似很小的特性，即enum关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便的处理。在此之前，你需要创建一个静态常量集，但是这些枚举值并不会必然地将其自身的取值限制在这个常量集的范围之内，因此显得更有风险，且难使用。枚举的出现正是为了解决这个问题。123public enum Spiciness&#123; NOT,MILD,MEDIUM,HOT,FLAMING;&#125;上述的代码创建了一个名为Spiciness的枚举类型，它具有5个具名值。由于枚举类型的实例是常量，因此按照命名惯例都用大写字母表示。当你创建enum时，编译器会自动添加一些有用的特性。例如，它会创建toString()方法，以便你可以很方便地显示某个enum实例的名字。编译器还会创建ordinal()方法，用来表示某个特定的enum常量的声明顺序；以及static values()方法，用来按照enum常量声明顺序，产生由这些常量值构成的数组。123456789101112131415public class EnumTest&#123; public static void main(String[] args)&#123; for(Spiciness s:Spiciness.values())&#123; System.out.println(s + \"：\" + s.ordinal()); &#125; &#125;&#125;/** output:* NOT:0* MILD:1* MEDIUM:2* HOT:3* FLAMING:4*/尽管enum看起来像是一种新的数据类型，但是这个关键字只是为enum生成对应类时，产生了某些编译器行为，因为你可以将enum当作一般的类来处理，只是具有某些特别的方法。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"04-控制执行流程","slug":"Java编程思想/04-控制执行流程","date":"2020-05-25T15:12:36.000Z","updated":"2020-05-27T07:24:00.646Z","comments":true,"path":"Java编程思想/04-控制执行流程/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/04-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/","excerpt":"","text":"程序必须在执行过程中控制它的世界，并做出选择。在Java中，涉及的关键字包括：if-else,while,do-while,for,return,break以及选择语句switch。goto不做介绍。 true和false所有条件语句都利用条件表达式的真或假来决定执行路径。即若条件表达式为真时，执行该条件语句的代码块；若为假，则不执行。注意：Java不允许我们将一个数字作为布尔值使用，虽然这在C和C++里允许。 if-elseif-else语句是控制程序流程的最基本形式。其中else是可选的，所以可按下述两种形式来使用if：123456789if(Boolean-expression)&#123; statement;&#125;if(Boolean-expression)&#123; statement;&#125;else&#123; statement;&#125;布尔表达式必须产生一个布尔结果，statement指用分号结尾的简单语句，或复合语句（封闭在花括号内的一组简单语句）。在中间可以看到一个或多个else if，那并非新的关键字，而仅仅只是一个else后面紧跟另一个新的if语句。1234567if(Boolean-expression)&#123; statement;&#125;else if(Boolean-expression)&#123; statement;&#125;else&#123; statement;&#125; 迭代while、do-while和for用来控制循环，有时也将它们划分为迭代语句（iteration statement）。代码块会重复执行，直到起控制作用的**布尔表达式（Boolean Expression）**得到“假”的结果为止。while循环的格式如下：123while(Boolean-expression)&#123; statement;&#125;在循环刚开始时，会计算一次布尔表达式的值；而在代码块的下一次迭代开始前会在计算一次。 do-whiledo-while的格式如下：123do&#123; statement;&#125;while(Boolean-expression);while和do-while唯一的区别是do-while中的语句至少会执行一次，即便布尔表达式第一次就被计算为false。但在实际应用中，while更常用一些。 forfor循环可能是最经常使用的迭代形式，这种在第一次迭代之前要进行初始化。随后它会进行条件测试。而且在每一次迭代结束时，进行某种形式的“步进”。for循环的格式如下：123for(initialization;Boolean-expression;step)&#123; statement;&#125;初始化(initialization)、布尔表达式（BooleanExprssion）、步进（step）运算都可以为空。每次迭代前都会测试布尔表达式。若获得的结果是true就执行代码块内语句。每次循环结束，会执行一次步进。下面以在一个数组内遍历寻找一个数为例：12345678// 在数组中寻找到数字3,并返回其下标int[] arr = new int[]&#123;1,2,3,4,5&#125;;for(int i=0;i&lt;arr.length;i++)&#123; if(arr[i] == 3)&#123; return i; &#125;&#125;return -1; 逗号操作符Java里唯一用到逗号操作符的地方就是for循环的控制表达式。在控制表达式的初始化和步进控制部分，可以使用一系列由逗号分隔的语句，而且那些语句均会被独立执行。通过使用逗号操作符，可以在for语句内定义多个变量，但是它们必须具有相同的类型。1234for(int i=1,j=j+10;i&lt;5;i++,j=i*2)&#123; System.out.println(\"i=\" + i); System.out.println(\"j=\" + j);&#125;在初始化部分可以拥有任意数量的具有相同类型的变量定义，这种能力只限于for循环，在其他任何选择或迭代语句中都不能使用这种方式。 Foreach语句Java SE5引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。假如拥有一个float数组，我们要选取该数组中的每一个元素：1234float[] arr = new float[]&#123;1.0f, 1.1f, 1.2f, 1.5f&#125;;for(float f:arr)&#123; System.out.println(f);&#125;上面的语句定义了一个float类型的变量f，继而将每一个arr的元素赋值给f。 return在Java中有多个关键词表示无条件分支，它们只是表示这个分支无需任何测试即可发生，这些关键词包括return、break、continue。return关键词有两方面的用途：一方面指定一个方法返回什么值，另一方面会导致当前的方法退出，并返回那个值。 break和continue在任何迭代语句的主体部分，都可以用break和continue控制循环的流程。其中，break用于强行退出循环，不执行剩下的循环。而continue则停止执行当前的迭代，不再执行当前循环剩下的语句而马上开始下一次循环。无尽循环有两种方式：while(true)和for(;;)，对于这两者只有通过break语句才能退出循环。注意：break会中断for循环，而且在抵达for循环的末尾之前，递增表达式不会执行。其实Java中存在着带标签的continue和break，但并不提倡使用这种语法，故不在此记录。 switchswitch有时也被划分为一种选择语句，选择使用其的原因一般是因为if-else if的结构十分复杂，这时我们选择使用switch来替代它，来使我们的程序结构更加清晰明了。switch语句可以从一系列的代码中选出一段去执行，它的格式如下：1234567891011121314switch(selector)&#123; case value1: statement; break; case value2: statement; break; case value3: statement; break; default: statement; break;&#125;在上面的代码中，会根据输入进来的selector去与我们定义的value比较，找到相等的case开始执行语句。一般来说，每个case均以一个break语句结尾，这样可使执行流程跳转至switch主体的末尾。但break是可选的，若省略break会继续执行后面的case语句，直到遇到一个break或走到switch的末尾为止。switch语句是实现多路选择的一种干净利落的方法，但它要求使用一个选择因子，并且必须是int或char那样的整数值（在Java SE7时String类型也被支持了）。 臭名昭著的goto编程语言一开始就有goto关键词。事实上，goto起源于汇编语言的程序控制：“若条件A成立，则跳到这里；否则跳到哪里”。如果阅读由编译器最终生成的汇编代码，就会发现程序控制里包含了许多跳转。注：Java编译器生成自己的“汇编代码”，但是这个代码运行在Java虚拟机上的，而不是直接运行在CPU硬件上。goto语句是在源码级上的跳转，这使得很难识别程序的控制流程。尽管**goto仍是Java中的一个保留字**，但在语言中并未使用它，即Java没有goto。然而，Java也能完成一些类似于跳转的操作，这与break和continue这两个关键词有关。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"03-操作符","slug":"Java编程思想/03-操作符","date":"2020-05-25T15:10:54.000Z","updated":"2020-05-27T07:23:51.445Z","comments":true,"path":"Java编程思想/03-操作符/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/03-%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"在最底层，Java中的数据是通过使用操作符来操作的。 使用Java操作符操作符接受一个或多个参数，并生成一个新值。参数的形式与普通的方法调用不同，但效果是相同的。加号和一元的正号（+）、减号和一元的负号（-）、乘号（*）、除号（/）以及赋值号（=）的用法与其他编程语言类似。几乎所有操作符都只能操作“基本类型”。例外的操作符是“=”、“==”、和“！=”，这些操作符能操作所有对象。除此之外，String类支持“+”和“+=”，这是通过重载操作符来实现的。需要说明的是，Java的底层C++语言支持由程序员重载操作符，但Java是不支持这一特性的，String是个唯一的特例。 优先级当一个表达式中存在多个操作符时，操作符的优先级就决定了各部分的计算顺序。其中，最简单的规则就是先乘除和加减，也可以使用括号来明确规定计算顺序。 赋值赋值使用操作符“=”，它的意思是“取右边的值复制给左边”。右值可以是任何常数、变量和表达式（只要它能生成一个值就行）。但左值必须是一个明确的、已命名的变量。也就是说，必须有一个物理空间可以存储等号右边的值。但是不能把任何东西赋给一个常数，即常数不能作为左值（4=a）。对于基本类型的赋值，是直接将一个地方的内容复制到了另一个地方。而为对象赋值时，实际是将引用从一个地方复制到了另一个地方。 算数操作符Java的基本算术操作符与其他大多数程序设计语言是相同的。其中包括加号（+）、减号（-）、除号（/）、乘号（*）以及取模操作符（%，它从整数除法中产生余数）。整数除法会直接去掉结果的小数位（相当于向下取整），而不是四舍五入地圆整结果。 一元加、减操作符一元减号（-）和一元（+）与二元减号和加号使用相同的符号。根据表达式的书写形式，编译器会自动判断出是哪一种。例如：1x = -a;一元减号用于转变数据的符号，而一元加号只是为了与一元减号相对应，但是它唯一的作用仅仅是将较小类型的操作数提升为int。 自动递增和递减递增和递减运算是两种相当不错的快捷运算（吐槽一下python，并不支持此语法）。其中，递减操作符是--，意为减少一个单位；递增操作符是++，意为增加一个单位。这两个操作符各有两种使用方式，通常被称为**“前缀式”和“后缀式”**。对于前缀递增、减（如++a），会先改变值，再执行运算；而后缀递增、减（如a--），会先执行运算，再改变值。*一些注释:*在C++中前缀递增、减与后缀递增、减是有效率区别的，前缀会比后缀效率高20%（没记错的话，以前看过一篇博客分析）。但是在Java中，如果你是用的后缀与前缀是等价的，会自动帮你转化为前缀表达式以提高效率（这一点也忘了在哪里瞎看到的）。 关系操作符关系操作符生成的是一个boolean布尔结果，它们计算的是操作数值之间的关系。如果关系是真，关系表达式会生成true；否则，则生成false。关系操作符包括小于(&lt;)、大于(&gt;)、小于等于(&lt;=)、大于等于(&gt;=)、等于(==)以及不等于(!=)。等于和不等于适用于所有数据类型，而其他比较符适用于除boolean类型之外的所有基本数据类型。 ==和equals的区别对于==运算符：基本类型：比较的是值是否相同引用类型：比较的是引用是否相同1234567String x = \"string\";String y = \"string\";String z = new String(\"string\");System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true代码解读：当你使用String s = &quot;a&quot;这种形式生成字符串时，会先检索方法区中的字符串常量池是否已经存在一个这样的对象，如果存在则返回该对象的引用；若不存在，则创建一个字符串对象并将其放入字符串常量池中。所以上述代码中的变量x和y实际上指向了同一个引用。而使用关键字new则会每次都申请内存空间创建一个新的对象。对于equals方法，其本质上就是==，只不过String和Integer等重写了该方法，把它变成了值比较。因为，equals是一个方法，只有对象具有方法，所以其默认情况是引用比较。但许多类都重写了equals方法，所以一般情况下其比较的是值是否相等。 逻辑操作符逻辑操作符**“与”（&amp;&amp;）、“或”（||）、“非”（！）**能根据参数的逻辑关系，生成一个布尔值（true或false）。与、或、非操作只可应用于布尔值。### 短路当使用逻辑操作符时，我们会遇到一种短路现象。即一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下的部分。因为，逻辑表达式靠后的部分有可能不会被运算。121. a||b2. a&amp;&amp;b代码解读：在式子1中，如果a为true，那么b就不会被计算，因为该表达式必定为真；在式子2中，如果a为false，那么b也不会被计算，因为该表达式必定为假。 直接常量如果在程序里使用了直接常量，需要对编译器加以适当的指导，用与直接常量相关的某些字符来额外增加一些信息。直接常量的后缀字符标志了它的类型。若为大写（或小写）的L，代表Long（尽量使用大写，因为小写的l看起来像数字1，容易造成混淆）；大小（或小写）字母F，代表float；大写（或小写）字母D，则代表double。十六进制数适用于所有整数数据类型，以前缀0x或(0X)，后面跟随0-9或小写（大写）的a-f来表示。如果试图将一个变量初始化成超出自身范围的值，编译器都会向我们报告一条错误信息。八进制由前缀0以及后续的0-7的数字来表示。在C、C++和Java中，二进制数没有直接常量表示方法。但是在使用十六进制和八进制计数法时，以二进制形式显示结果将非常有用。通过使用Integer和Long类型的静态方法toBinaryString()可以很容易实现这一点。1234567int i1 = 0x2f; // Hexadecimalint i2 = 0177; // Octal(leading zero)char c = 0xffff; // max char hex valuebyte b = 0x7f; // max byte hex valuelong n1 = 200L;float f1 = 1F;double d1 = 1D; 指数计数法Java采用了一种很不直观的计数法来表示指数，例如：1float f = 1.39e-43f;上面的变量f表示1.39×10−431.39 \\times 10^{-43}1.39×10−43。编译器通常会把指数作为双精度（double）处理，所以上述代码如果没有这个尾随的f，就会收到一条出错信息。 按位操作符按位操作符用来操作整数基本类型中的单个**“比特”（bit）**，即二进制位。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。按位操作符来源于C语言面向底层的操作，在这种操作中经常需要直接操纵硬件，设置硬件寄存器内的二进制位。如果两个输入位都是1，则按位**“与”操作（&amp;）**生成一个输出位1；否则生成一个输出位0。如果两个输入位只要一个是1，则按位**“或”操作（|）**生成一个输出位1；只有在两个输入位都是0的情况下，“或”操作才会生成一个输出位0。如果输入位的某一个是1，但不全是1，那么按位**“异或”操作（^）**生成一个输出位1。按位**“非”（~）**，也称取反操作符，它属于一元操作符，只对一个操作数进行操作。“非”操作生成与输入位相反的值–若输入0，则输出1；若输入1，则输出0。按位操作符可与等号（=）联合使用，以便合并运算和赋值：&amp;=、|=、^=都是合法的。由于~是一元操作符，故不能与“=”号联合使用。布尔类型作为一种单比特值对待，可以对其执行按位“与”（&amp;）、按位“或”（|）和按位“异或”（^）运算，但不能执行按位“非”。对于布尔值，按位操作符具有与逻辑操作符相同的效果，只是它们不会中途“短路”。 移位操作符移位操作符操作的运算对象也是二进制的“位”，移位操作符只可以用来处理整数类型。**左移位操作符（&lt;&lt;）**能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）。左移1位相当于乘以2，所以说计算5*8，最快的方法应该是将5向左移动三位5&lt;&lt;3。**“有符号”右移位操作符（&gt;&gt;）**则按照操作符右侧指定的位数将操作符左边的操作数向右移动。“有符号”右移位操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1。Java中增加了一种**“无符号”右移位操作符（&gt;&gt;&gt;）**，它使用“零扩展”：无论正负，都在高位插入0.*注意：*如果对char、byte或者short类型的数值进行移位处理，那么在移位进行之前，它们会被转换为int类型的值，并且得到的结果也是一个int类型的值。只有数值右端的低5位有用。这样防止移位超过int类型值所具有的位数（因为25=322^5=3225=32，int类型只有32位）。若对一个long类型的数值进行处理，最后得到结果也是long此时只会用到数值右端的低6位。“移位”可与“等号”组合使用（&lt;&lt;=或&gt;&gt;=或&gt;&gt;&gt;=）。此时，操作符左边的值会移动由右边的值指定的位数，再将得到的结果赋给左边的变量。12345678int i = -1;i &gt;&gt;&gt;= 10;system.out.println(i);long l = -1;l &gt;&gt;= 3;system.out.println(l);l &lt;&lt;= 2;system.out.println(l); 三元操作符 if-else三元操作符也称为条件操作符，因为它有三个操作数；但它确实属于操作符的一种，因为它最终也会生成一个值。1boolean-exp?value0:value1;如果boolean-exp的结果为true，就计算value0，而且这个计算结果也就是操作符最终产生的值；若为false，就计算value1，同样它的结果也就成为操作符最终产生的值。 字符串操作符+和=这个操作符在Java中有一项特殊用途：连接不同的字符串。这项功能用在C中似乎是个不错的主意，所以引入了**操作符重载（operator overloading）**机制，以便C程序员可以为几乎所有操作符增加功能。但操作符重载是一种非常复杂的特性，程序员在设计自己的类时必须对此有周全的考虑。尽管操作符重载在Java这种更容易实现，但Java程序员不能像C++和C#程序员那样实现自己的重载操作符。如果表达式以一个字符串起头，那么后续所有操作数必须都是字符串型。请记住，编译器会把双引号内的字符序列自动转换为字符串。1234int x = 0, y = 1, z = 2;String s = \"x, y, z\";system.out.println(s);system.out.println(s + x + y +z); 使用操作符时常犯的错误第一个常犯的错误是：即使对表达式如何计算有点不确定，也不愿意使用括号。此外，一个常犯的错误如下：123while(x = y)&#123; // ...&#125;程序员明显是想测试是否“相等”（==），而不是进行赋值操作。在Java中，这个表达式的结果并不是布尔值，而编译器期望的是一个布尔值。Java不会自动地将int数值转换成布尔值，所以在编译时抛出一个编译时错误，从而阻止进一步运行这个程序。而在C和C++中，编译器会将int数值转换成布尔值（非0为true，0为false）。 类型转换操作符类型转换（cast）：Java会将一种数据类型自动转换成另一种。例如为某浮点数变量赋一个整数值，编译器为将int自动转换为float。类型转换运算允许显式地进行这种类型的转换，或者在不能自动进行转换的时候强制进行类型转换。要想执行类型转换，需要将希望得到的数据类型置于圆括号()内，并放在要进行类型转换的值左边。12int i = 100;long l = (int)i;在C和C++中，类型转换有时会让人头疼。但是在Java中，类型转换则是一种比较安全的操作。窄化转换（narrowing conversion）：将能容纳更多信息的数据类型转换为无法容纳那么多信息的类型，可能会导致信息丢失。扩展转换（widening conversion）：不必显式地进行类型转换，因为新类型肯定能容纳原来类型的信息，不会造成任何信息的丢失。Java允许把任何基本数据类型转换成其他的基本数据类型，但布尔型除外，后者不允许进行任何类型的转换处理。“类”数据类型不允许进行类型转换，为了将一种类转换成另一种，必须采用特殊的方法。 截尾和舍入在执行窄化转换时，必须注意截尾和舍入问题。123float f = 29.7;int i = (int)f;system.out.println(i); // 29将float或double转型为整型值时，总是对该数字执行截尾。如果想要得到舍入结果，需要使用java.lang.Math.round()方法。 提升如果对基本数据类型执行算术运算或按位运算，大家会发现，只要类型比int小（即char,byte,short），在运算前，这些值会自动转换为int。如果想要把结果赋值给较小的类型，就必须使用类型转换。通常，表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。 Java没有sizeof在C和C++中，sizeof()操作符可以告诉你为数据项分配的字节数。sizeof()最大的用处是为了移植，因为不同的数据类型在不同的机器上可能有不同的大小。Java不需要sizeof()操作符，因为所有的数据类型在所有机器中的大小都是相同的，它已经被设计在语言中。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"02-一切都是对象","slug":"Java编程思想/02-一切都是对象","date":"2020-05-25T14:54:04.000Z","updated":"2020-05-27T11:27:08.322Z","comments":true,"path":"Java编程思想/02-一切都是对象/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"Java是基于C++的，但是相比之下，Java是一种更纯粹的面向对象程序设计语言。 用引用操纵对象每种编程语言都有自己的操纵内存中元素的方式。在Java中，一切都被视为对象，因此可采用固定单一的语法。尽管一切都看作对象，但操纵的标识符实际是对象的一个“引用”（reference）。可以将这一情形想象成用遥控器（引用）来操纵电视机（对象）。引用可以独立存在，但在操纵时会返回错误，因为其没有与一个具体的对象绑定，如下面的代码所示：12String s; &#x2F;&#x2F; 这声明了一个字符串引用s.length(); &#x2F;&#x2F; 编译会错误 必须由你创建所有对象一旦创建一个引用，就希望它能与一个新的对象相关联。通过用new操作符来实现这一目的。new关键字意思是“给我一个新对象”。1String s = new String(\"hello world!\");Java提供了大量过剩的现成类型。重要的是，你可以自行创建类型。 存储到什么地方程序运行时，有五个不同的地方可以存储数据:寄存器：这是最快的存储区，因为它位于不同于其他存储区的地方–处理器内部。但寄存器数量极其有限，所以寄存器根据需求怎么分配。堆栈：位于通用RAM（随机访问存储器）中，通过堆栈指针可以从处理器那里直接获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方式，仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。某些Java数据存储在堆栈中–特别是对象引用，但是Java对象并不存储于其中。堆：一种通用的内存池（也位于RAM区），用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当需要一个对象时，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。灵活性的代价是：用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间。常量存储：常量值通常直接存放在程序代码内部。非RAM存储：如果数据完全存活在程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是流对象和持久化对象。这种存储方式的技巧在于：把对象转换成可以存放在其他媒介上的食物，在需要时可恢复成常规的、基于RAM的对象。Java提供了对轻量级持久化的支持。 补充：Java的内存模型首先回顾一下Java程序的执行流程：如上图所示，首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件。加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area （运行时数据区），也就是我们常说的JVM内存。因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。根据JVM规范，JVM内存共分为五个部分：虚拟机栈堆方法区程序计数器本地方法栈 特例：基本类型在程序设计中经常用到一系列类型，它们需要特殊对待。因为new将对象存储在堆里，对于小的、简单的变量，往往不是很有效。因此对于基本类型，Java采取与C和C++相同的方法。也就是不用new来创建变量，而是创建一个并非是引用的“自动”的变量。这个变量直接存储值，并置于堆栈中，因此更加高效。基本类型大小最小值最大值包装器类型boolean---Booleanchar16-bitUnicode oUnicode 216−12^{16}-1216−1Characterbyte8 bits−128-128−128+127+127+127Byteshort16 bits−215-2^{15}−215+215−1+2^{15}-1+215−1Shortint32 bits−231-2^{31}−231+231−1+2^{31}-1+231−1Integerlong64 bits−263-2^{63}−263+263−1+2^{63}-1+263−1Longfloat32 bitsIEEE 754IEEE 754Floatdouble64 bitsIEE 753IEEE 754Doublevoid---Void所有数值类型都有正负号，所以不要去寻找无符号的数值类型。boolean类型所占的存储空间大小没有明确规定，仅定义为能够取字面值true或false。Java SE5的自动包装功能将自动地将基本类型转换为包装器类型，并可以反向转换。 高精度数字Java提供了两个用于高精度计算的类：BigInteger和BigDecimal。这两个类包含的方法，提供的操作与对基本类型所能执行的操作相似。也就是说，能作用于int和float的操作，也同样能应用在BigInteger和BigDecimal`，只不过必须以方法调用方式取代运算符来实现。BigInteger支持任意精度的整数。也就是说，在运算中，可以准确地表示任意大小的整数值，而不丢失任何信息。BigDecimal支持任意精度的定点数，例如，可以用它来进行精确的货币计算。 永远不需要销毁对象在大多数程序设计语言中，变量生命周期的概念，占据了程序设计工作非常重要的部分。Java帮助我们大大简化了这个问题。 作用域大多数过程语言都有**作用域（Scope）**的概念。作用域决定了其内定义的变量名的可见性和生命周期，作用域由花括号{}的位置决定。在作用域里定义的变量只可用于作用域结束之前。且在Java中，较大作用域的变量不会“隐藏”，故较小作用域中不能定义与较大作用域同名的变量。 对象的作用域Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。假如你编写了下述代码：123&#123; String s = new String(\"hello world!\");&#125;引用s在作用域终点就消失了。然而s指向的String对象仍继续占据内存空间。事实证明，由new创建的对象，只要你需要，就会一直保留下来。同时，Java有一个垃圾回收器，用来监视new创建的对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以供新的对象使用。就是说，程序员不用关心内存回收的问题。Java从天然上隔绝了内存泄漏。 创建新的数据类型：类如果一切都是对象，那么是什么决定了某一类对象的外观与行为呢？大多数面向对象的程序设计语言习惯用关键字class来表示“我准备告诉你一种新类型的对象看起来像什么样子”。1class ATypeName &#123;/* Class body goes here */&#125;这就引入了一种新的类型了，然后你已经可以用new来创建这种类型的对象。 字段和方法一旦定义了一个类，就可以在类中设置两种类型的元素：字段（有时称为数据成员）和方法（有时称为成员函数）。字段可以是任何类型的对象，可以通过其引用与其进行通信；也可以是基本类型中的一种。每个字段都有用来存储其字段的空间；普通字段不能在对象中共享。基本成员默认值：基本类型默认值booleanfalsechar'\\uooooo'(null)byte(byte)oshort(short)ointolongoLfloato.ofdoubleo.od若类的某个成员是基本数据类型，即使没有初始化，Java也会确保它获得一个默认值，以确保那些是基本类型的成员变量得到初始化，防止产生程序错误。提醒：最好明确地对变量进行初始化。 方法、参数和返回值Java的方法决定了一个对象能够接收什么样的消息。方法的基本组成部分包括：名称参数返回值方法体下面是它最基本的形式：123ReturnType methodName(/* Argument list */)&#123; /* Method Body */&#125;返回类型描述的是在调用方法之后从方法返回的值。参数列表给出了要传给方法的信息的类型和名称。方法名和参数列表（它们合起来被称为**“方法签名”**）唯一地标识出某个方法。**Java中的方法只能作为类的一部分来创建，方法只有通过对象才能被调用，且这个对象必须能执行这个方法调用。**通过这个对象调用方法时，需要先列出对象名，紧接着是句点，然后和方法名和参数列表。1objectName.methodName(arg1, arg2, arg3); 参数列表方法的参数列表指定要传递给方法什么样的信息。这些信息如Java中的其他信息一样，采用都是对象的形式。因此，在参数列表必须指定每个所传递对象的类型及名字，这里的传递实际上也是引用。疑问：Java中的参数传递不是副本拷贝吗？正如你把一个对象A传递进方法f(A)，在方法中对A进行操作，并不会影响外部的A的值。在方法体中，可以使用return关键字进行值的返回。当然，如果你的方法返回类型为void的时候，可以不返回任何值，并且通过return;语句，在程序中随时退出方法。 构建第一个Java程序 名字可见性名字管理对任何程序设计语言来说，都是一个重要问题。如果在程序的某个模块使用了一个名字，而其他人的程序的另一个模块也使用了相同的名字，那么怎样区分这两个名字并防止二者相互冲突呢？Java采用了一种全新的方法来解决上述问题。为了给一个类库生成不会与其他名字混淆的名字，Java设计者希望程序员放过来使用自己Internet域名，因为这样可以保证它们肯定是独一无二的。例如：cn.hengxin，这个将域名进行了反转，句点就用来代表子目录的划分。一般来说，这被称为包，建议包名采用全小写的形式。这种机制意味着所有的文件都能自动存活在它们自己的名字空间中，而且同一个文件内每个类都有唯一的标识符–类名。 运用其他构件如果想在自己程序里使用预先定义好的类，那么编译器就必须知道怎么定位它们。当然，这个类可能就在发出调用的源文件中；在这种情况下，就可以直接使用这个类–即使这个类在文件的后面才会被定义。Java消除了所谓的**“向前引用”**问题。例如，C语言在调用一个函数时，这个函数必须在调用语句前被定义。为了消除所有可能的混淆情况，可以使用关键字import来准确地告诉编译器你想要的类是什么。import指示编译器导入一个包，也就是一个类库。1import java.util.ArrayList;如果你想使用Java的util包下数量众多的类，又不想逐一声明，那么可以使用通配符*来达到这个目的：1import java.util.*;当然，现代的IDE一般都会存在提示或者自动导入包的机制，因此你并不需要记住这个类来自于那个包，仅需在IDE提示你的时候进行判断选择就可以了。在eclipse中，我们可以使用crtl+shift+O进行包的自动导入，如果存在混淆的情况，eclipse将会要求你进行选择导入那个包以匹配正确的类 static关键字通常来说，除非用new创建类对象，否则实际上并未获得任何对象。执行new来创建对象时，数据存储空间才被分配，其方法才供外界调用。但是，当使用static关键字去修饰一个字段或者方法时，就意味着这个域不会与包含它的类的任何对象实例关联起来。所以，即使从未创建某个类的任何对象，也可调用其static方法或者访问其static域。1234567class ATest&#123; static int i=0; static void increment()&#123; ATest.i++; &#125;&#125;","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"01-对象导论","slug":"Java编程思想/01-对象导论","date":"2020-05-25T12:21:35.000Z","updated":"2020-05-27T07:23:26.150Z","comments":true,"path":"Java编程思想/01-对象导论/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"计算机革命起源于机器，因此，编程语言的产生也始于对机器的模仿。但是计算机并非只是机器那么简单，计算机是头脑延伸的工具。**面向对象程序设计（Object-oriented Programming，OOP）**是以计算机作为表达媒体的大趋势中的组成部分。 抽象过程所有的编程语言都提供抽象机制，人们所能够解决的问题的复杂性直接取决于抽象的类型与质量。汇编语言是对底层机器的轻微抽象。接着出现的许多所谓的“命令式”语言（如FORTRAN、BASIC、C等）都是对汇编语言的抽象。它们所作的主要抽象仍要求在解决问题时要基于计算机的结构，而不是基于所要解决的问题的结构来考虑。另一种对机器建模的方式就是只针对待解问题建模。早期的编程语言，如LISP和APL，都选择考虑世界的某些特定视图（分别对应于**“所有问题最终都是列表”或者“所有问题都是算法形式的”**）。这些方式对需要解决的特定类型的问题都是不错的解决方案，但一旦超出其特定领域，就会显得力不从心。面向对象方式通过向程序员提供表示问题空间中的元素的工具。这种表示方式非常通用，使程序员不会受限于任何特定类型的问题。我们将问题空间中的元素及其在解空间中的表示称为**“对象”**。OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。每个对象看起来都像一台微型计算机–具有状态和操作，用户可以要求对象执行这些操作。第一个成功的面向对象语言Smalltalk（Java语言的祖先之一）的五大特性：万物皆对象：将对象视为奇特的变量，它可以存储数据，还可以要求它在自身上执行操作；程序是对象的集合：对象通过发送消息来告诉彼此所要做的事。要想请求一个对象，就必须对该对象发送一条消息（即调用对象方法的请求）；每个对象都有自己的由其他对象所构成的存储：可以通过创建包含现有对象的新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后；每个对象都拥有类型：每个对象都是某个类(class)的一个实例(instance)；某一特定类型的所有对象都可以接收同样的消息:一个“圆形”类型的对象同时也是“几何形”类型的对象，所以一个“圆形”对象必定能够接受发送给“几何形”对象的消息。这种**替代性（substitutability）**是OOP中最强有力的概念之一。Booch对对象提出了一个更加简洁的描述：对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据（对象的状态）和方法（产生的行为），并且每一个对象都可以唯一地与其他对象区分开来（即在内存中都有一个唯一的地址）。 每个对象都有一个接口创建抽象数据类型（类）是面向对象程序设计的基本概念之一。因为类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。程序员通过定义类来适应问题，通过添加新的数据类型来扩展编程语言。编程系统欣然接受新的类，并且像内置类型一样地照管它们和进行类型检查。每个对象都只能满足某些请求，这些请求由对象的**接口（interface）**所定义，决定接口的便是类型。接口确定了对某一特定对象所能发出的请求。但是，在程序中必须有满足这些请求的代码。这些代码和隐藏的数据一起构成了实现。在类型中，每一个可能的请求都有一个方法与之相关联，当对对象发送请求时，与之相关联的方法就会被调用。 每个对象都提供服务最好将对象想象为**“服务提供者”**。程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这一目的。当正在试图开发或理解一个程序设计时，首先去想一想需要那些“服务提供者”去帮助我们完成。例如，假设你正在创建一个簿记系统，那么可以想象，系统应该具有：完成簿记输入屏幕的服务提供者；执行簿记计算的服务提供者；处理在不同打印机上打印支票和开发票的服务提供者。上述的服务提供者，本质上就是一类对象，这是将问题分解为对象集合的一种合理方式。将对象看作是服务提供者还有一个附带的好处：它有助于提高对象的内聚性。高内聚是软件设计的基本质量要求之一。将对象看作服务提供者是一项伟大的简化工具，这不仅在设计过程中非常有用，而且当其他人试图理解你的代码或重用某个对象时，使用或调整的过程变得简单许多。 被隐藏的具体实现将程序开发人员按照角色分为类创建者（那些创建新数据类型的程序员）和客户端程序员（那些在应用中使用数据类型的类消费者）。客户端程序员收集各种用来实现快速开发应用的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必须的部分，而隐藏其他部分。如果加以隐藏，那么客户端程序员将不能访问它，这就意味着类创建者可以任意修改被隐藏的部分，而不用担心对其他人造成影响。被隐藏的部分通常代表对象内部脆弱的部分，它们很容易被粗心的或不知内情的客户端程序员所毁坏。因此，将实现隐藏起来可以减少程序BUG。在任何相互关系中，具有关系所涉及的各方都遵守的边界是十分重要的事情。因此，我们需要引入访问控制：访问控制让客户端程序员无法触及他们不应该触及的部分–这些部分对数据类型的内部操作是必须的，但并不是用户解决特定问题所需的接口的一部分；访问控制允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。Java使用三个关键字（或叫访问指定词，access specifier ）在类的内部设定边界：public：表示紧随其后的元素对任何人都可以用；private：表示除类型创建者和类型内部方法之外的任何人都不能访问。如果有人试图访问private成员，就会在编译时得到错误信息；protected：protected关键字与private作用相当，差别仅在于继承的类可以访问protected成员，但是不能访问privae成员。Java还有一种默认的访问权限，当没有使用前面提到的任何访问指定词，它将发挥作用，这种权限通常被称为包访问权限。在这种权限下，类可以访问同一包（库构件）中的其他类的成员。但是在包之外，这些成员如同指定了private一样。 复用具体实现一旦类被创建并被测试完，那么它就应该（在理想情况下）代表一个有用的代码单元。最简单地复用某个类的方式是直接使用该类的一个对象，此外也可以将那个类的一个对象置于新的类中。我们称其为**“创建一个成员对象”**。新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。这种概念被称为组合（composition）。如果组合式动态发生的，那么可以称为聚合（aggregation）。组合经常被视为**“has-a”（拥有）**关系。组合带来了极大的灵活性，设计会变得更加清晰。 继承类型不仅仅只是描述了作用于一个对象集合上的约束条件，同时还有与其他类型之间的关系。两个类型可以有相同的特性和行为，但是其中一个类型可能比另一个含有更多特性，并且可以处理更多的消息（或以不同的方式来处理消息）。**继承使用基类型和导出类型的概念表示这种类型之间的相似性。一个基类型包含其所有导出类型的所共享的特性和行为。**可以创建一个基类型来表示系统中某些对象的核心概念，从基类型中导出其他类型，来表示此核心可以被实现的各种不同方式。以同样的术语将解决方案转换成问题是大有裨益的，因为不需要在问题描述和解决方案描述之间建立许多中间模型。使导出类与基类之前产生差异的方法之一是改变现有基类的方法的行为，这被称之为覆盖（overriding），即重写基类的方法。 伴随多态的可互换对象在试图将导出类型的对象当作其泛化基类型对象看待时，存在着一个问题：让泛化的导出类工作时，编译器在编译时不可能知道应该执行哪一段代码。一个非面向对象编程的编译器产生的函数调用会引起所谓的前期绑定，即每个函数都会被绑定一个绝对地址。而在OOP中，程序直到运行时才能确定代码的地址。为了解决这个问题，面向对象程序设计语言使用了后期绑定的概念。为了执行后期绑定，Java使用了一小段特殊的代码来替代绝对地址调用。这段代码使用在对象存储的信息中来计算方法体的地址。在某些语言中，必须明确地声明希望某个方法具备后期绑定所带来的灵活性（C++通过使用virtual关键字来实现的）。而在Java中，动态绑定是默认行为，无需添加额外的关键字。将导出类看作是它的基类的过程称为向上转型（upcasting）。一个面向对象程序肯定会在某处包含向上转型，因为这正是将自己从必须知道确切类型中解放出来的关键。 单根继承结构在Java中，所有的类最终都继承自单一的基类–Object。事实证明，单根继承结构带来了很多好处：在单根继承结构中所有对象都具有一个共用接口，所以它们归根到底都是相同的基本类型。单根继承结构保证了所有对象都具备某些功能。因此你知道，你可以对任何对象执行某些基本操作。所有的对象都可以很容易地在堆上创建，而参数的传递也得到了很大的简化。单根继承结构使垃圾回收器的实现变得容易了很多。由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局。这对于系统级操作（如异常处理）显得尤其重要，并给编程带来了更大的灵活性。 容器容器：在任何需要时都可以扩充自己以容纳你置于其中的所有东西。因为程序员不需要知道将来把多少对象置于容器内，只需要创建一个容器对象，然后让它处理所有的细节。Java中具有满足不同需要的各种类型的容器：List：用于存储序列；Map：关联数组，用来建立对象之间的关联；Set：每种对象类型只持有一个的集合其他：如队列、树、堆栈等 参数化类型在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型：Object。单根继承结构意味着所有东西都是Object类型，所以可以存储Object的容器可以存储任何东西。这使得容器很容易被复用。但是由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object。因此它会丢失其身份。当把它取回时，就获取了一个对Object对象的引用，而不是对置入的那个类型对象的引用。这个时候需要**向下转型(downcasting)**才能得到确切的类型对象。我们知道，向上转型是安全的，但是向下转型却很危险（除非确切知道所要处理的对象类型）。解决方案被称为：参数化类型机制。参数化类型就是一个编译器可以自动定制作用于特定类型上的类。在Java中它称为范型。一对尖括号，中间包含类型信息（26个大写字母），通过这些特征就可以识别对范型的使用。1ArrayList&lt;Shape&gt; shapeLst = new ArrayList&lt;Shape&gt;(); 对象的创建和生命期在使用对象时，最关键的问题之一便是生成和销毁方式。每个对象为了生存都需要资源，尤其是内存。当我们不再需要一个对象时，它必须被清理掉，使其占有的资源可以被释放和重用。Java完全采用动态内存分配方式，每当想要创建新对象时，就要使用new关键字，在**堆（heap）**的内存池中动态创建对象实例。对于允许在堆栈上创建对象的语言，编译器可以确定对象的存活时间，并可以自动销毁它，即对象生命周期由编译器确定。Java提供了被称为“垃圾回收器”的机制，它可以自动发现对象何时不再被使用，并继而销毁它。垃圾回收器减少了所必需考虑的议题和必须编写的代码，提供了更高层的保障，可以避免暗藏的内存泄漏问题。C++为了追求最大的执行速度，对象的存储空间和生命周期都必须在编写程序时确定。而Java必须花费更多的CPU时间去回收对象。但是C++必须手动分配和释放对象，灵活性差，且常发生内存泄漏问题。 并发编程在计算机编程中有一个基本概念，就是在同一时刻处理多个任务的思想。我们想把问题切分成多个可独立运行的部分（任务），从而提高程序的响应能力。在程序中，这些彼此独立运行的部分称之为线程，上述概念称之为**“并发”**。多线程所带来的便利之一便是程序员不用再担心机器上是有多个处理器还是只有一个处理器，因为程序在逻辑上被分为线程，同时使程序执行更快。但并发存在一个隐患：共享资源。如果有多个并发任务都要访问同一项资源，那么就会出问题。解决的方案一般是：某个任务锁定某项资源，完成其任务，然后释放资源锁，使其他任务可以使用这项资源。并发：从时间上也是有先后顺序的，只是时间极短，故在人感受上是同时的。例如，线程A和线程B实际上是先后执行的，但对用户来看是一起发生的。那么为什么会发生争夺共享资源呢？因为CPU分配的时间片是长度是一定的，线程A在这个时间片上使用资源1，使用到一半时间片用完了。那么这时候轮到线程B，它要使用资源1。这个时候如果不加锁，就会发生数据不一致的问题之类的。并行：从时间上是一致，比如两匹马同时在跑。 异常处理：处理错误异常处理将错误处理直接置于编程语言中，甚至于操作系统中。**异常是一种对象，它从出错地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”。**异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径。因为它是另一条完全分离的执行路径，所以它不会干扰正常的执行代码。**异常不能被忽略，所以它保证一定会在某处得到处理。**需要指出的是：异常提供了一种从错误状态进行可靠恢复的途径，这帮助编写更健壮的程序。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"工厂模式","slug":"设计模式/工厂模式","date":"2020-05-25T11:57:00.000Z","updated":"2020-05-27T07:22:29.144Z","comments":true,"path":"设计模式/工厂模式/","link":"","permalink":"https://hengxincheung.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"引言工厂模式是一种创建型模式，它提供了了一种创建对象的最佳方式。使用工厂模式，创建对象时不会暴露客户端暴露创建逻辑（这个有点像接口的概念，客户端程序员不必关心内部的实现细节，并有效减少发生bug的概率），并且通过使用一个共同的接口来指向新创建的对象。 针对的问题许多类对象的创建都需要一系列的步骤，可能需要计算或取得对象的初始设置，选择生成哪个子对象实例，或者在生成需要的对象之前必须先生成一些辅助对象的对象。这些情况下，对象的建立是一个过程，是一个操作。简而言之，工厂模式存在的意义是：高效地创建某一类对象。 工厂模式的种类一般来说，工厂模式分为以下三种：简单工厂模式，又称静态工厂模式工厂方法模式，全程多个工厂方法模式抽象工厂模式 角色组成 概念工厂类角色：工厂模式的核心，含有一定的商业逻辑和判断逻辑，用以创建产品抽象产品角色：一类对象的抽象概念，即具体产品继承的父类或者实现的接口具体产品角色：工厂类所创建的对象就是此角色的实例，在Java中由一个具体类实现 手机制造工厂本文以手机制造工厂生产各类手机为场景学习工厂模式。手机分为两类：苹果手机华为手机。注：随便举例，不存在任何话题。 手机抽象父类123456public abstract class Phone&#123; // 手机的名字 private String name; // 打电话的方法 public abstract void call();&#125; 苹果手机123456789public class IPhone extends Phone&#123; public IPhone()&#123; super(\"苹果手机\"); &#125; @Override public void call()&#123; System.out.println(super.getName() + \"正在打电话\"); &#125;&#125; 华为手机123456789public class Huawei extends Phone&#123; public Huawei()&#123; super(\"华为手机\"); &#125; @Override public void call()&#123; System.out.println(super.getName() + \"正在打电话\"); &#125;&#125; 简单（静态）工厂模式 实现简单工厂模式的实现思想是：创建对象时候传入代表类型的参数type，然后再通过if-else或者switch语句根据type创建对应的对象返回。先看一下简单的代码实现：123456789101112131415161718public class PhoneFactory&#123; // 通过静态方法返回需要的手机实例 // type参数建议使用枚举，好处多多 public static Phone producePhone(String type)&#123; Phone phone; switch(type)&#123; case \"iphone\": phone = new IPhone(); break; case \"huawei\": phone = new Huawei(); break; default: throw new IllegalArgumentException(\"此型号手机暂不支持制造\"); &#125; return phone; &#125;&#125;简单工厂的机制很简单：根据传入的类型，创建对应的对象 总结在简单工厂模式中，提供创建对象的方法一般是静态的，故也被称为静态工厂模式。 优点实现简单：代码逻辑简单可复用高：所有对象的创建都通过同名的方法创建 缺点容错率低：如果传入的类型参数因为粗心写错，则创建的产品会与预期不符耦合度高：所有对象的共用一个创建方法，每增减一种产品，都需要对这个唯一的方法进行修改扩展性差：每增减一种产品，都需要修改工厂类，违背了设计模式中的开放-封闭原则（OCP，对扩展开放，对修改关闭） （多个）工厂方法模式 实现工厂方法模式的关键点在于：为每种对象提供相应的工厂方法。12345678910public class PhoneFactory&#123; // 制造苹果手机的方法 public static Phone produceIPhone()&#123; return new IPhone(); &#125; // 制造华为手机的方法 public static Phone produceHuawei()&#123; return new Huawei(); &#125;&#125; 总结（多个）工厂方法模式，为每种对象分别编写专用的创建方法，根据调用的创建方法不同，产生不同对象。 优点实现简单：代码逻辑容易理解容错率高：每种对象都有专用的创建方法，无需传入类型等参数，只要调用正确的创建方法就不会出错。（这一点有点异议，感觉跟简单工厂模式传参错误的概率是一样）耦合度低：每增减一种产品，只需要增减一个创建方法，不会影响其他对象的创建方法 缺点扩展性差：每增减一种产品，都需要修改工厂类，违背了开闭原则可复用低：所有对象的创建方法都不同名 抽象工厂模式 实现抽象工厂模式的关键点在于：为每种对象提供单独的工厂和工厂方法。所以需要把工厂类抽象出来，形成抽象工厂，然后针对每种对象分别实现专用的工厂及工厂方法，这就是抽象工厂的命名由来。1.抽象工厂:AbstractPhoneFactory1234public abstract class AbstractPhoneFactory&#123; // 生成手机的抽象方法 public abstract Phone producePhone();&#125;2.苹果手机专用生产工厂：IPhoneFactory123456public class IPhoneFactory extends AbstractPhoneFactory&#123; @Override public Phone producePhone()&#123; return new IPhone(); &#125;&#125;3.华为手机专用生产工厂：HuaweiFactory123456public class HuaweiFactory extends AbstractPhoneFactory&#123; @Override public Phone producePhone()&#123; return new Huawei(); &#125;&#125;4.测试1234567// 苹果手机的工厂AbstractPhoneFactory factory = new IPhoneFactory();// 制造一台苹果手机Phone phone = factory.producePhone();// 调用苹果手机的打电话方法phone.call();// 输出：苹果手机正在打电话 总结抽象工厂模式：定义一个抽象工厂和其抽象方法，每种对象都有专用的子工厂及对象创建方法。个人理解，就像富士康（抽象父工厂）有许多的车间（具体的工厂）生产不同的产品。 优点容错率高：因为每种对象都有专用的工厂及创建方法，只要调用正确的工厂就不会出错耦合度低：每增减一种产品，只需要增减一个工厂及其方法，不会影响其他对象的创建方法扩展性好：每增减一种产品，只需要增减此对象的工厂及其创建方法，不会修改其他工厂，遵循开闭原则可复用高：所有对象的创建都通过同名的方法创建 缺点实现复杂：代码逻辑相对复杂，nnn 个对象需要定义 nnn 个工厂类","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"统计机器学习","slug":"统计机器学习","permalink":"https://hengxincheung.github.io/categories/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/categories/web/"},{"name":"git","slug":"git","permalink":"https://hengxincheung.github.io/categories/git/"},{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/tags/web/"},{"name":"权限系统","slug":"权限系统","permalink":"https://hengxincheung.github.io/tags/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/"},{"name":"用户系统","slug":"用户系统","permalink":"https://hengxincheung.github.io/tags/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/"},{"name":"统计机器学习","slug":"统计机器学习","permalink":"https://hengxincheung.github.io/tags/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"随机森林","slug":"随机森林","permalink":"https://hengxincheung.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"},{"name":"git","slug":"git","permalink":"https://hengxincheung.github.io/tags/git/"},{"name":"登录","slug":"登录","permalink":"https://hengxincheung.github.io/tags/%E7%99%BB%E5%BD%95/"},{"name":"RESTful","slug":"RESTful","permalink":"https://hengxincheung.github.io/tags/RESTful/"},{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"},{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}