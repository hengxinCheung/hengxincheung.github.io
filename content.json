{"meta":{"title":"hengxincheung's blog","subtitle":"","description":"","author":"hengxincheung","url":"https://hengxincheung.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2020-05-25T10:19:05.369Z","updated":"2020-05-25T10:19:05.369Z","comments":false,"path":"categories/index.html","permalink":"https://hengxincheung.github.io/categories/","excerpt":"","text":""},{"title":"个人简介","date":"2020-05-25T10:44:05.334Z","updated":"2020-05-25T10:44:05.334Z","comments":false,"path":"about/index.html","permalink":"https://hengxincheung.github.io/about/","excerpt":"","text":"联系方式移动电话：15626487308电子邮箱：hengxincheung@qq.com 教育背景时间学校专业学历2015-09 至 2019-06华南农业大学信息与计算科学本科2019-09 至 今电子科技大学软件工程硕士主修课程：数学分析、高等代数、离散数学、概率论、数值计算、常微分方程、组合优化、随机过程与排队论算法设计与分析、操作系统、Web开发、数据结构、数据挖掘、信息安全、Unix操作系统内核高级计算机结构、软件架构模型与设计、统计机器学习、网络计算模式、网络编程 项目经验修正 UWB 定位飘移算法研究人体检测与人体行为识别研究 技能评价具有良好的英语文本阅读能力以及书面写作；数学基础扎实，熟练掌握数学分析、数值计算、高等代数等，了解机器学习、深度学习，可以进行独立的数据挖掘和分析工作；熟练 C、Java、Python 等编程语言；熟悉常用的数据结构及算法、设计模式；掌握后台 Spring、Spring MVC、MyBatis、Hibernate 、Struts 等框架，前端 HTML\\CSS、JavaScript、Ajax、JQuery、Vue 等。 荣誉奖励美国大学生数学建模竞赛 H 奖（二等奖）、全国大学生数学建模竞赛三等奖；校级 ACM 竞赛专业组三等奖；校二等奖学金、校级三等奖学金；优秀志愿者、优秀团干部、优秀班委等。 自我评价思维严谨，有较强的学习和适应能力。工作主动，有责任心、执行力和抗压性，对代码有偏执地完美的追求，有着良好的规范代码编写习惯。热爱互联网行业，热爱编程开发，对互联网发展有敏锐触觉和十二分激情。"},{"title":"标签","date":"2020-05-25T10:19:35.595Z","updated":"2020-05-25T10:19:35.595Z","comments":true,"path":"tags/index.html","permalink":"https://hengxincheung.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"01-对象导论","slug":"Java编程思想/01-对象导论","date":"2020-05-25T12:21:35.000Z","updated":"2020-05-25T12:31:20.226Z","comments":true,"path":"Java编程思想/01-对象导论/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"计算机革命起源于机器，因此，编程语言的产生也始于对机器的模仿。但是计算机并非只是机器那么简单，计算机是头脑延伸的工具。**面向对象程序设计（Object-oriented Programming，OOP）**是以计算机作为表达媒体的大趋势中的组成部分。 抽象过程所有的编程语言都提供抽象机制，人们所能够解决的问题的复杂性直接取决于抽象的类型与质量。汇编语言是对底层机器的轻微抽象。接着出现的许多所谓的“命令式”语言（如FORTRAN、BASIC、C等）都是对汇编语言的抽象。它们所作的主要抽象仍要求在解决问题时要基于计算机的结构，而不是基于所要解决的问题的结构来考虑。另一种对机器建模的方式就是只针对待解问题建模。早期的编程语言，如LISP和APL，都选择考虑世界的某些特定视图（分别对应于**“所有问题最终都是列表”或者“所有问题都是算法形式的”**）。这些方式对需要解决的特定类型的问题都是不错的解决方案，但一旦超出其特定领域，就会显得力不从心。面向对象方式通过向程序员提供表示问题空间中的元素的工具。这种表示方式非常通用，使程序员不会受限于任何特定类型的问题。我们将问题空间中的元素及其在解空间中的表示称为**“对象”**。OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。每个对象看起来都像一台微型计算机–具有状态和操作，用户可以要求对象执行这些操作。第一个成功的面向对象语言Smalltalk（Java语言的祖先之一）的五大特性：万物皆对象：将对象视为奇特的变量，它可以存储数据，还可以要求它在自身上执行操作；程序是对象的集合：对象通过发送消息来告诉彼此所要做的事。要想请求一个对象，就必须对该对象发送一条消息（即调用对象方法的请求）；每个对象都有自己的由其他对象所构成的存储：可以通过创建包含现有对象的新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后；每个对象都拥有类型：每个对象都是某个类(class)的一个实例(instance)；某一特定类型的所有对象都可以接收同样的消息:一个“圆形”类型的对象同时也是“几何形”类型的对象，所以一个“圆形”对象必定能够接受发送给“几何形”对象的消息。这种**替代性（substitutability）**是OOP中最强有力的概念之一。Booch对对象提出了一个更加简洁的描述：对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据（对象的状态）和方法（产生的行为），并且每一个对象都可以唯一地与其他对象区分开来（即在内存中都有一个唯一的地址）。 每个对象都有一个接口创建抽象数据类型（类）是面向对象程序设计的基本概念之一。因为类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。程序员通过定义类来适应问题，通过添加新的数据类型来扩展编程语言。编程系统欣然接受新的类，并且像内置类型一样地照管它们和进行类型检查。每个对象都只能满足某些请求，这些请求由对象的**接口（interface）**所定义，决定接口的便是类型。接口确定了对某一特定对象所能发出的请求。但是，在程序中必须有满足这些请求的代码。这些代码和隐藏的数据一起构成了实现。在类型中，每一个可能的请求都有一个方法与之相关联，当对对象发送请求时，与之相关联的方法就会被调用。 每个对象都提供服务最好将对象想象为**“服务提供者”**。程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这一目的。当正在试图开发或理解一个程序设计时，首先去想一想需要那些“服务提供者”去帮助我们完成。例如，假设你正在创建一个簿记系统，那么可以想象，系统应该具有：完成簿记输入屏幕的服务提供者；执行簿记计算的服务提供者；处理在不同打印机上打印支票和开发票的服务提供者。上述的服务提供者，本质上就是一类对象，这是将问题分解为对象集合的一种合理方式。将对象看作是服务提供者还有一个附带的好处：它有助于提高对象的内聚性。高内聚是软件设计的基本质量要求之一。将对象看作服务提供者是一项伟大的简化工具，这不仅在设计过程中非常有用，而且当其他人试图理解你的代码或重用某个对象时，使用或调整的过程变得简单许多。 被隐藏的具体实现将程序开发人员按照角色分为类创建者（那些创建新数据类型的程序员）和客户端程序员（那些在应用中使用数据类型的类消费者）。客户端程序员收集各种用来实现快速开发应用的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必须的部分，而隐藏其他部分。如果加以隐藏，那么客户端程序员将不能访问它，这就意味着类创建者可以任意修改被隐藏的部分，而不用担心对其他人造成影响。被隐藏的部分通常代表对象内部脆弱的部分，它们很容易被粗心的或不知内情的客户端程序员所毁坏。因此，将实现隐藏起来可以减少程序BUG。在任何相互关系中，具有关系所涉及的各方都遵守的边界是十分重要的事情。因此，我们需要引入访问控制：访问控制让客户端程序员无法触及他们不应该触及的部分–这些部分对数据类型的内部操作是必须的，但并不是用户解决特定问题所需的接口的一部分；访问控制允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。Java使用三个关键字（或叫访问指定词，access specifier ）在类的内部设定边界：public：表示紧随其后的元素对任何人都可以用；private：表示除类型创建者和类型内部方法之外的任何人都不能访问。如果有人试图访问private成员，就会在编译时得到错误信息；protected：protected关键字与private作用相当，差别仅在于继承的类可以访问protected成员，但是不能访问privae成员。Java还有一种默认的访问权限，当没有使用前面提到的任何访问指定词，它将发挥作用，这种权限通常被称为包访问权限。在这种权限下，类可以访问同一包（库构件）中的其他类的成员。但是在包之外，这些成员如同指定了private一样。 复用具体实现一旦类被创建并被测试完，那么它就应该（在理想情况下）代表一个有用的代码单元。最简单地复用某个类的方式是直接使用该类的一个对象，此外也可以将那个类的一个对象置于新的类中。我们称其为**“创建一个成员对象”**。新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。这种概念被称为组合（composition）。如果组合式动态发生的，那么可以称为聚合（aggregation）。组合经常被视为**“has-a”（拥有）**关系。组合带来了极大的灵活性，设计会变得更加清晰。 继承类型不仅仅只是描述了作用于一个对象集合上的约束条件，同时还有与其他类型之间的关系。两个类型可以有相同的特性和行为，但是其中一个类型可能比另一个含有更多特性，并且可以处理更多的消息（或以不同的方式来处理消息）。**继承使用基类型和导出类型的概念表示这种类型之间的相似性。一个基类型包含其所有导出类型的所共享的特性和行为。**可以创建一个基类型来表示系统中某些对象的核心概念，从基类型中导出其他类型，来表示此核心可以被实现的各种不同方式。以同样的术语将解决方案转换成问题是大有裨益的，因为不需要在问题描述和解决方案描述之间建立许多中间模型。使导出类与基类之前产生差异的方法之一是改变现有基类的方法的行为，这被称之为覆盖（overriding），即重写基类的方法。 伴随多态的可互换对象在试图将导出类型的对象当作其泛化基类型对象看待时，存在着一个问题：让泛化的导出类工作时，编译器在编译时不可能知道应该执行哪一段代码。一个非面向对象编程的编译器产生的函数调用会引起所谓的前期绑定，即每个函数都会被绑定一个绝对地址。而在OOP中，程序直到运行时才能确定代码的地址。为了解决这个问题，面向对象程序设计语言使用了后期绑定的概念。为了执行后期绑定，Java使用了一小段特殊的代码来替代绝对地址调用。这段代码使用在对象存储的信息中来计算方法体的地址。在某些语言中，必须明确地声明希望某个方法具备后期绑定所带来的灵活性（C++通过使用virtual关键字来实现的）。而在Java中，动态绑定是默认行为，无需添加额外的关键字。将导出类看作是它的基类的过程称为向上转型（upcasting）。一个面向对象程序肯定会在某处包含向上转型，因为这正是将自己从必须知道确切类型中解放出来的关键。 单根继承结构在Java中，所有的类最终都继承自单一的基类–Object。事实证明，单根继承结构带来了很多好处：在单根继承结构中所有对象都具有一个共用接口，所以它们归根到底都是相同的基本类型。单根继承结构保证了所有对象都具备某些功能。因此你知道，你可以对任何对象执行某些基本操作。所有的对象都可以很容易地在堆上创建，而参数的传递也得到了很大的简化。单根继承结构使垃圾回收器的实现变得容易了很多。由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局。这对于系统级操作（如异常处理）显得尤其重要，并给编程带来了更大的灵活性。 容器容器：在任何需要时都可以扩充自己以容纳你置于其中的所有东西。因为程序员不需要知道将来把多少对象置于容器内，只需要创建一个容器对象，然后让它处理所有的细节。Java中具有满足不同需要的各种类型的容器：List：用于存储序列；Map：关联数组，用来建立对象之间的关联；Set：每种对象类型只持有一个的集合其他：如队列、树、堆栈等 参数化类型在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型：Object。单根继承结构意味着所有东西都是Object类型，所以可以存储Object的容器可以存储任何东西。这使得容器很容易被复用。但是由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object。因此它会丢失其身份。当把它取回时，就获取了一个对Object对象的引用，而不是对置入的那个类型对象的引用。这个时候需要**向下转型(downcasting)**才能得到确切的类型对象。我们知道，向上转型是安全的，但是向下转型却很危险（除非确切知道所要处理的对象类型）。解决方案被称为：参数化类型机制。参数化类型就是一个编译器可以自动定制作用于特定类型上的类。在Java中它称为范型。一对尖括号，中间包含类型信息（26个大写字母），通过这些特征就可以识别对范型的使用。1ArrayList&lt;Shape&gt; shapeLst = new ArrayList&lt;Shape&gt;(); 对象的创建和生命期在使用对象时，最关键的问题之一便是生成和销毁方式。每个对象为了生存都需要资源，尤其是内存。当我们不再需要一个对象时，它必须被清理掉，使其占有的资源可以被释放和重用。Java完全采用动态内存分配方式，每当想要创建新对象时，就要使用new关键字，在**堆（heap）**的内存池中动态创建对象实例。对于允许在堆栈上创建对象的语言，编译器可以确定对象的存活时间，并可以自动销毁它，即对象生命周期由编译器确定。Java提供了被称为“垃圾回收器”的机制，它可以自动发现对象何时不再被使用，并继而销毁它。垃圾回收器减少了所必需考虑的议题和必须编写的代码，提供了更高层的保障，可以避免暗藏的内存泄漏问题。C++为了追求最大的执行速度，对象的存储空间和生命周期都必须在编写程序时确定。而Java必须花费更多的CPU时间去回收对象。但是C++必须手动分配和释放对象，灵活性差，且常发生内存泄漏问题。 并发编程在计算机编程中有一个基本概念，就是在同一时刻处理多个任务的思想。我们想把问题切分成多个可独立运行的部分（任务），从而提高程序的响应能力。在程序中，这些彼此独立运行的部分称之为线程，上述概念称之为**“并发”**。多线程所带来的便利之一便是程序员不用再担心机器上是有多个处理器还是只有一个处理器，因为程序在逻辑上被分为线程，同时使程序执行更快。但并发存在一个隐患：共享资源。如果有多个并发任务都要访问同一项资源，那么就会出问题。解决的方案一般是：某个任务锁定某项资源，完成其任务，然后释放资源锁，使其他任务可以使用这项资源。并发：从时间上也是有先后顺序的，只是时间极短，故在人感受上是同时的。例如，线程A和线程B实际上是先后执行的，但对用户来看是一起发生的。那么为什么会发生争夺共享资源呢？因为CPU分配的时间片是长度是一定的，线程A在这个时间片上使用资源1，使用到一半时间片用完了。那么这时候轮到线程B，它要使用资源1。这个时候如果不加锁，就会发生数据不一致的问题之类的。并行：从时间上是一致，比如两匹马同时在跑。 异常处理：处理错误异常处理将错误处理直接置于编程语言中，甚至于操作系统中。**异常是一种对象，它从出错地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”。**异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径。因为它是另一条完全分离的执行路径，所以它不会干扰正常的执行代码。**异常不能被忽略，所以它保证一定会在某处得到处理。**需要指出的是：异常提供了一种从错误状态进行可靠恢复的途径，这帮助编写更健壮的程序。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"工厂模式","slug":"设计模式/工厂模式","date":"2020-05-25T11:57:00.000Z","updated":"2020-05-25T12:25:06.823Z","comments":true,"path":"设计模式/工厂模式/","link":"","permalink":"https://hengxincheung.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"引言工厂模式是一种创建型模式，它提供了了一种创建对象的最佳方式。使用工厂模式，创建对象时不会暴露客户端暴露创建逻辑（这个有点像接口的概念，客户端程序员不必关心内部的实现细节，并有效减少发生bug的概率），并且通过使用一个共同的接口来指向新创建的对象。 针对的问题许多类对象的创建都需要一系列的步骤，可能需要计算或取得对象的初始设置，选择生成哪个子对象实例，或者在生成需要的对象之前必须先生成一些辅助对象的对象。这些情况下，对象的建立是一个过程，是一个操作。简而言之，工厂模式存在的意义是：高效地创建某一类对象。 工厂模式的种类一般来说，工厂模式分为以下三种：简单工厂模式，又称静态工厂模式工厂方法模式，全程多个工厂方法模式抽象工厂模式 角色组成 概念工厂类角色：工厂模式的核心，含有一定的商业逻辑和判断逻辑，用以创建产品抽象产品角色：一类对象的抽象概念，即具体产品继承的父类或者实现的接口具体产品角色：工厂类所创建的对象就是此角色的实例，在Java中由一个具体类实现 手机制造工厂本文以手机制造工厂生产各类手机为场景学习工厂模式。手机分为两类：苹果手机华为手机。注：随便举例，不存在任何话题。 手机抽象父类123456public abstract class Phone&#123; // 手机的名字 private String name; // 打电话的方法 public abstract void call();&#125; 苹果手机123456789public class IPhone extends Phone&#123; public IPhone()&#123; super(\"苹果手机\"); &#125; @Override public void call()&#123; System.out.println(super.getName() + \"正在打电话\"); &#125;&#125; 华为手机123456789public class Huawei extends Phone&#123; public Huawei()&#123; super(\"华为手机\"); &#125; @Override public void call()&#123; System.out.println(super.getName() + \"正在打电话\"); &#125;&#125; 简单（静态）工厂模式 实现简单工厂模式的实现思想是：创建对象时候传入代表类型的参数type，然后再通过if-else或者switch语句根据type创建对应的对象返回。先看一下简单的代码实现：123456789101112131415161718public class PhoneFactory&#123; // 通过静态方法返回需要的手机实例 // type参数建议使用枚举，好处多多 public static Phone producePhone(String type)&#123; Phone phone; switch(type)&#123; case \"iphone\": phone = new IPhone(); break; case \"huawei\": phone = new Huawei(); break; default: throw new IllegalArgumentException(\"此型号手机暂不支持制造\"); &#125; return phone; &#125;&#125;简单工厂的机制很简单：根据传入的类型，创建对应的对象 总结在简单工厂模式中，提供创建对象的方法一般是静态的，故也被称为静态工厂模式。 优点实现简单：代码逻辑简单可复用高：所有对象的创建都通过同名的方法创建 缺点容错率低：如果传入的类型参数因为粗心写错，则创建的产品会与预期不符耦合度高：所有对象的共用一个创建方法，每增减一种产品，都需要对这个唯一的方法进行修改扩展性差：每增减一种产品，都需要修改工厂类，违背了设计模式中的开放-封闭原则（OCP，对扩展开放，对修改关闭） （多个）工厂方法模式 实现工厂方法模式的关键点在于：为每种对象提供相应的工厂方法。12345678910public class PhoneFactory&#123; // 制造苹果手机的方法 public static Phone produceIPhone()&#123; return new IPhone(); &#125; // 制造华为手机的方法 public static Phone produceHuawei()&#123; return new Huawei(); &#125;&#125; 总结（多个）工厂方法模式，为每种对象分别编写专用的创建方法，根据调用的创建方法不同，产生不同对象。 优点实现简单：代码逻辑容易理解容错率高：每种对象都有专用的创建方法，无需传入类型等参数，只要调用正确的创建方法就不会出错。（这一点有点异议，感觉跟简单工厂模式传参错误的概率是一样）耦合度低：每增减一种产品，只需要增减一个创建方法，不会影响其他对象的创建方法 缺点扩展性差：每增减一种产品，都需要修改工厂类，违背了开闭原则可复用低：所有对象的创建方法都不同名 抽象工厂模式 实现抽象工厂模式的关键点在于：为每种对象提供单独的工厂和工厂方法。所以需要把工厂类抽象出来，形成抽象工厂，然后针对每种对象分别实现专用的工厂及工厂方法，这就是抽象工厂的命名由来。1.抽象工厂:AbstractPhoneFactory1234public abstract class AbstractPhoneFactory&#123; // 生成手机的抽象方法 public abstract Phone producePhone();&#125;2.苹果手机专用生产工厂：IPhoneFactory123456public class IPhoneFactory extends AbstractPhoneFactory&#123; @Override public Phone producePhone()&#123; return new IPhone(); &#125;&#125;3.华为手机专用生产工厂：HuaweiFactory123456public class HuaweiFactory extends AbstractPhoneFactory&#123; @Override public Phone producePhone()&#123; return new Huawei(); &#125;&#125;4.测试1234567// 苹果手机的工厂AbstractPhoneFactory factory = new IPhoneFactory();// 制造一台苹果手机Phone phone = factory.producePhone();// 调用苹果手机的打电话方法phone.call();// 输出：苹果手机正在打电话 总结抽象工厂模式：定义一个抽象工厂和其抽象方法，每种对象都有专用的子工厂及对象创建方法。个人理解，就像富士康（抽象父工厂）有许多的车间（具体的工厂）生产不同的产品。 优点容错率高：因为每种对象都有专用的工厂及创建方法，只要调用正确的工厂就不会出错耦合度低：每增减一种产品，只需要增减一个工厂及其方法，不会影响其他对象的创建方法扩展性好：每增减一种产品，只需要增减此对象的工厂及其创建方法，不会修改其他工厂，遵循开闭原则可复用高：所有对象的创建都通过同名的方法创建 缺点实现复杂：代码逻辑相对复杂，nnn 个对象需要定义 nnn 个工厂类","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}