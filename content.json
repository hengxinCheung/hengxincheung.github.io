{"meta":{"title":"hengxincheung's blog","subtitle":"","description":"","author":"hengxincheung","url":"https://hengxincheung.github.io","root":"/"},"pages":[{"title":"个人简介","date":"2020-05-25T10:44:05.334Z","updated":"2020-05-25T10:44:05.334Z","comments":false,"path":"about/index.html","permalink":"https://hengxincheung.github.io/about/","excerpt":"","text":"联系方式移动电话：15626487308电子邮箱：hengxincheung@qq.com教育背景时间学校专业学历2015-09 至 2019-06华南农业大学信息与计算科学本科2019-09 至 今电子科技大学软件工程硕士主修课程：数学分析、高等代数、离散数学、概率论、数值计算、常微分方程、组合优化、随机过程与排队论算法设计与分析、操作系统、Web开发、数据结构、数据挖掘、信息安全、Unix操作系统内核高级计算机结构、软件架构模型与设计、统计机器学习、网络计算模式、网络编程项目经验修正 UWB 定位飘移算法研究人体检测与人体行为识别研究技能评价具有良好的英语文本阅读能力以及书面写作；数学基础扎实，熟练掌握数学分析、数值计算、高等代数等，了解机器学习、深度学习，可以进行独立的数据挖掘和分析工作；熟练 C、Java、Python 等编程语言；熟悉常用的数据结构及算法、设计模式；掌握后台 Spring、Spring MVC、MyBatis、Hibernate 、Struts 等框架，前端 HTML\\CSS、JavaScript、Ajax、JQuery、Vue 等。荣誉奖励美国大学生数学建模竞赛 H 奖（二等奖）、全国大学生数学建模竞赛三等奖；校级 ACM 竞赛专业组三等奖；校二等奖学金、校级三等奖学金；优秀志愿者、优秀团干部、优秀班委等。自我评价思维严谨，有较强的学习和适应能力。工作主动，有责任心、执行力和抗压性，对代码有偏执地完美的追求，有着良好的规范代码编写习惯。热爱互联网行业，热爱编程开发，对互联网发展有敏锐触觉和十二分激情。"},{"title":"文章分类","date":"2020-05-25T10:19:05.369Z","updated":"2020-05-25T10:19:05.369Z","comments":false,"path":"categories/index.html","permalink":"https://hengxincheung.github.io/categories/","excerpt":"","text":""},{"title":"标签","date":"2020-05-25T10:19:35.595Z","updated":"2020-05-25T10:19:35.595Z","comments":true,"path":"tags/index.html","permalink":"https://hengxincheung.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"10-内部类","slug":"Java编程思想/10-内部类","date":"2020-05-30T13:51:09.000Z","updated":"2020-05-30T15:29:16.354Z","comments":true,"path":"Java编程思想/10-内部类/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/10-%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"可以将一个类的定义放在另一个类的定义内部，这就是内部类。内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织起来，并控制位于内部类的可视性。创建内部类创建内部类的方式如同你想的一样—把类的定义置于外围类的里面：123456789public class Parcell &#123; class Contents &#123; private int i = 1; &#125; class Destination &#123; private String label = \"\" &#125;&#125;如果你想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体的指明这个对象的类型（前提是该内部类非 private）：1OuterClassName.InnerClassName obj &#x3D; new OuterClassName.InnerClassName();链接到外部类内部类似乎只是一种名字隐藏和组织代码的模式，但它还有其他的用途。当生成一个内部类的对象时，此对象与制造它的 外围对象（enclosing object） 之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还具有外围类的所有元素的访问权。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 迭代器接口interface Selector &#123; // 是否已经到尾 boolean end(); // 获取当前的元素 Object current(); // 移动到下一个元素 void next();&#125;public class Sequence &#123; private Object[] items; private int next = 0; public Sequence(int size) &#123; items = new Object[size]; &#125; // 增加一个元素 public void add(Object x) &#123; if(next &lt; items.length)&#123; items[next++] = x; &#125; &#125; // 迭代器 private class SequenceSelector implements Selector &#123; private int i = 0; // 是否已经到尾 public boolean end() &#123; return i == items.length; &#125; // 获取当前的元素 public Object current() &#123; return items[i]; &#125; // 移动到下标到下一个元素 public void next() &#123; if(i &lt; items.length)&#123; i++; &#125; &#125; &#125; // 获取新的迭代器 public Selector selector() &#123; return new SequenceSelector(); &#125; // 运行 public static void main(String[] args) &#123; Sequence sequence = new Sequence(10); for(int i=0;i&lt;10;i++)&#123; sequence.add(i); &#125; Selector selector = sequence.selector(); while(!selector.end()) &#123; system.out.println(selector.current()); selector.next(); &#125; &#125;&#125;所有内部类自动拥有对其外围类所有成员的访问权。这是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部类对象必定秘密捕捉一个指向那个外围对象的引用。然后，当你访问此外围类对象时，就是用该引用来选择外围类的成员。而这，都是编译器在帮助你处理所有的细节。使用 .this 和 .new如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点 . 和 this。这样产生的引用自动地具有正确的类型。这一点在编译器就被知晓并受到检查，因此没有任何运行时的开销。12345678910// 外部类public class OuterClass &#123; // 内部类 public class InnerClass &#123; // 返回外部类的引用 public OuterClass getOuter() &#123; return OuterClass.this; &#125; &#125;&#125;有时候你可能去创建其他类的某个内部类对象，要实现这个目的，你必须在 new 表达式中提供对其他外部类对象的引用，这时可以使用 .new 语法。12345678910111213// 外部类public class OuterClass &#123; // 内部类 public class InnerClass &#123; &#125; // 测试 public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); // 直接创建内部类 OuterClass.InnerClass inner = outer.new Inner(); &#125;&#125;你必须使用外部类的对象来创建该内部类对象。在拥有外部类对象之前是不可能创建内部类对象的，这是因为内部类对象会暗暗地链接到创建它的外部类对象上。当然，如果你创建的是 嵌套类（静态内部类） ，那么它就不需要对外部类对象的引用。在方法和作用域内的内部类通常，如果你所读、写的代码包含了内部类，那么它们都是“平凡的”内部类，简单且容易理解。然后，内部类的语法覆盖了大量其他难以理解的技术。例如，可以在一个方法或者任意作用域内定义内部类。这么做有两个理由：实现了某类型的接口，于是可以创建并返回对其的引用；你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但又不希望这个类是公共可用的。在方法的作用域内创建一个完整的类，这被称为局部内部类。1234567891011public class OuterClass &#123; public Destination destination() &#123; class PDestination implements Destination &#123; private String label; private PDestination(String label)&#123;this.label = label;&#125; public String readLabel() &#123;return label;&#125; &#125; return new PDestination(\"to your heart!\"); &#125;&#125;匿名内部类12345678public class OuterClass &#123; public InnerClass inner() &#123; return new InnerClass() &#123; // 插入一个类的定义 private int i = 1; public int value() &#123;return i;&#125; &#125; &#125;&#125;嵌套类如果不需要内部对象与外围对象之间有联系，那么可以将内部类声明为 static。这通常被称为 嵌套类。普通的内部类对象隐式地保存了一个引用，指向创建它的外围对象。然后，当内部类是 static 时：要创建嵌套类的对象，不需要其外围类的对象；不能从嵌套类的对象访问非静态的外围类对象。嵌套类与普通的内部类还有一个区别：普通内部类的字段与方法，只能放在类的外部层次上，所有普通的内部类不能有 static 数据和 static 字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西。123456public OuterClass &#123; private static class InnerClass &#123; private int i = 0; public static int value = 11; &#125;&#125;为什么需要内部类一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。内部类最吸引人的原因是：每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型。内部类标识符由于每个类都会产生一个 .class 文件，其中包含了如何创建该类型对象的全部信息（此信息产生一个 “meta-class”, 称为 Class 对象）。内部类也必须生成一个 .class 文件以包含它们的 Class 对象信息。这些类文件的命名有严格的规则：外围类的名字$内部类的名字.class。例如产生了以下的类文件：12OuterClass.classOuterClass$InnerClass.class虽然这种格式简单又直接，但它还是很健壮的，足以应对绝大多数情况。因为这是Java标准的命名方式，所以产生的文件自动都是平台无关的。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"09-接口","slug":"Java编程思想/09-接口","date":"2020-05-30T10:55:09.000Z","updated":"2020-05-30T12:11:31.905Z","comments":true,"path":"Java编程思想/09-接口/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/09-%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。抽象类与抽象方法Java 提供一个叫做 抽象方法 的机制，这种方法是不完整的，仅有声明而没有方法体。1abstract void f();包含抽象方法的类叫做 抽象类。如果一个类中含有抽象方法，该类必须被限定为抽象的，否则编辑器将会给出报错信息。123public abstract class Tutorial &#123; public abstract void abstractMethod();&#125;如果从一个抽象类继承，并想创建该新类的对象，那么必须为基类中所有的抽象方法提供方法定义。如果不这么做，那么导出类便也是抽象类，且编译器将会强制使用 abstract 关键字来限定这个类。抽象类中并不是所有的方法都是抽象的，也可以有具体实现的方法。抽象类和抽象方法十分有用，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算如何使用它们。抽象类还是很有用的重构工具，因为它使得我们可以很容易地将公共方法沿着继承层次结构向上移动。接口interface 关键字使抽象的概念更向前迈进了一步。abstract 关键字允许人们在类中创建一个或多个没有任何定义的方法。而 interface 这个关键字产生一个完全抽象的类，它根本没有提供任何具体实现。它允许创建者确定方法名，参数列表和返回类型，但是没有任何方法体。接口只提供形式，而未提供任何具体实现。因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。因此，接口被用来建立类与类之间的协议。interface 不仅仅是一个极度抽象的类，它还允许人们创建一个能够被向上转型为多种基型的类型，来实现某种多重继承的特性。而抽象类则不能达到这一点，因为Java是纯单根继承的体系。要想创建一个接口，需要使用 interface 关键字来替代 class 关键字。注意：接口也可以包含域，但是这些域隐式地是 static 和 final 的。同时，接口的方法默认都是 public 的。要让一个类遵循某个特定接口（或者一组接口），需要使用 implements 关键字。1234567891011121314interface Instrument &#123; int VALUE = 5; // static&amp;final void play(); // automatically public void adjust();&#125;class Wind implements Instrument &#123; public void play() &#123; system.out.println(\"wind playing...\"); &#125; public void adjust() &#123; system.out.println(\"wind adjusting...\"); &#125;&#125;完全解耦只要一个方法操作的是类而非接口，那么你就只能使用这个类及其子类。如果你想要将这个方法应用于不在此继承体系的其他类中，那么是不允许的。接口可以在很大程序上放宽了这种限制。因此，接口使得我们可以编写可复用性更好的代码。1234567891011121314151617181920212223242526272829303132333435// 处理器接口interface Processor &#123; String name(); Object process(Object input);&#125;// 应用器class Apply &#123; public static void process(Processor p, Object input) &#123; system.out.println(\"Using Processor \" + p.name()); system.out.println(p.process(input)); &#125;&#125;// 滤波器适配器：一个处理器的具体实现class FilterAdapter implements Processor &#123; Filter filter; public FilterAdapter(Filter filter)&#123; this.filter = filter; &#125; public String name() &#123; return filter.name(); &#125; public Waveform process(Object input)&#123; return filter.process((Waveform)input); &#125;&#125;class FilterProcessor &#123; public static void main(String[] args)&#123; Waveform w = new Waveform(); Apply.process(new FilterAdapter(new LowPass(1.0)), w); Apply.process(new FilterAdapter(new HighPass(1.0)), w); &#125;&#125;上面的例子中，使用了 适配器模式。适配器中的代码将接收你所拥有的接口，并产生你所需要的接口。你可能还注意到，在 FilterAdapter 中使用了 代理。Java中的多重继承接口不仅仅是一种更纯粹形式的抽象类，因为接口是根本没有任何实现—即没有任何与接口相关的存储。因此，也无法阻止多个接口的组合。这一点是很有价值的，因为你有时需要去表示“一个 $x$ 是一个 $a$ 和一个 $b$”。在C++中，组合多个类的接口的行为被称作 多重继承。如果要从一个非接口的类继承，那么只能从一个类去继承。这一点由Java的单根继承体系所决定。但一个类可以实现多个接口，只需要将所有的接口名都置于 implements 关键字之后，并用逗号 , 将它们一一隔开。可以继承任意多个接口，并可以向上转型为每个接口，因为每一个接口都一个独立类型。12345678910111213141516interface Fight &#123; void fight();&#125;interface Swim &#123; void Swim();&#125;public class Hero implements Fight, Swim &#123; public void fight() &#123; system.out.println(\"I can fight!\"); &#125; public void swim() &#123; system.out.println(\"I can swim!\"); &#125;&#125;通过继承来扩展接口通过继承，可以很容易地在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。1234567891011interface Monster &#123; void menace();&#125;interface Lethal &#123; void kill();&#125;interface Vampire extends Monster, Lethal &#123; void drinkBlood();&#125;在 Vampire 中使用的语法仅仅适用于接口继承。一般情况下，只可以将 extends 关键字用于单一类。接口适配接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现。在简单的情况下，它的体现形式通常是接收一个接口类型的方法，而该接口的实现与向该方法传递的对象则取决于方法的使用者。因此，接口一种最常见的用法就是 策略设计模式。此时你编写一个执行某些操作的方法，而该方法将接收一个同样是你指定的接口。这使得你的方法更加灵活、通用，并更具复用性。例如，Java SE5 中 Scanner 类的构造器接收的就是一个 Readable 接口。接口中的域因为你放入接口中的任何域都自动是 static 和 final 的，所在接口就成为了一种很便捷的用来创建常量组的工具。在Java SE5 之前，这是产生枚举类型 enum 的唯一途径。123public interface Color &#123; int RED = 1, BLUE = 2, GREEN = 3;&#125;请注意，Java中标识具有常量初始化值的 static final 时，会使用大写字母的风格（使用下划线分割单词）。接口中的域自动是 public 的。接口与工厂接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式是 工厂方法 设计模式。这与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象。理论上，我们的代码将完全与接口的实现分离，这也可以使我们可以透明地将某个实现替换成另一个实现。12345678910111213141516171819202122interface Phone &#123; void call() &#123;&#125;;&#125;class Iphone implements Phone &#123; void call() &#123; system.out.println(\"Iphone is calling!\"); &#125;&#125;class Huawei implements Phone &#123; void call() &#123; system.out.println(\"Huawei is calling!\"); &#125;&#125;class PhoneFactory&#123; public void testPhoneCall(Phone phone) &#123; phone.call(); &#125;&#125;总结确定接口是理想选择，因而应该总是选择接口而不是具体的类。这其实是一种引诱。任何抽象性都应该是应真正的需求而产生的。恰当的原则应该是优先选择类而不是接口。接口是一种重要的工具，但是它们容易被滥用。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"基于URL的权限系统","slug":"web/基于URL的权限系统","date":"2020-05-29T12:59:34.000Z","updated":"2020-05-30T16:17:39.816Z","comments":true,"path":"web/基于URL的权限系统/","link":"","permalink":"https://hengxincheung.github.io/web/%E5%9F%BA%E4%BA%8EURL%E7%9A%84%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"概念1权限管理，一般指根据系统设置的安全规则或者安全策略，用户可以访问而且只能访问自己被授权的资源，不多不少。通俗易懂地总结，权限系统就是谁（什么身份）可以允许对什么内容（资源）执行什么操作（查看、增加、修改、删除等）。最常用的权限系统使用 基于角色的权限访问控制 （Role-Based Access Control，RBAC） 的方式实现。RBAC支持三个著名的安全原则：最小权限原则，责任分离原则和数据抽象原则。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。想要做到从用户到功能的精确控制，要从数据库表结构设计和代码控制同时进行。表结构用户表 useridusernamepasswordstautsis_superadmin…用户id用户名密码状态，如冻结、锁定、正常等是否超级管理员其他信息，如创建时间等is_superadmin 字段用以标识是否为超级管理员，即当用户为超级管理员时候，无需配置任何权限都可对任何资源进行任何操作。角色表 roleidcodenamedescribecreatorcreatedstatus…主键角色编码角色名称角色描述创建者创建时间状态，如禁用、正常等其他信息用户-角色表 user_roleiduser_idrole_idstatus…主键用户id角色id状态，如正常、禁用等其他信息，如创建时间资源表 resourceidcodenamedescribeurlactionlevelparent_idis_leaf…主键资源编码资源名称资源描述资源url请求方法资源等级父节点主键是否叶节点其他信息，如资源icon等因为资源表在前端需要展示，所以数据设定为树结构，方便加载和筛选。只有叶节点对应的资源才具有真正的 url 和 action。非叶节点的资源可以认为是功能模块的描述。举个例子，如：12345用户管理 |___账号信息 |___修改基本信息 |___修改密码 |___查看所有人的账号信息说明：权限也是一种资源，可以配置给适当的角色进行管理。角色-资源表 role_resourceidrole_idresource_idstatus…主键角色id资源id状态，如正常、禁用其他信息，如创建时间等其他说明权限不足时首先，前端不应该展示任何无法操作的资源若用户通过某些方式访问了未授权的权限，应当返回 404 页面。公共资源有一些公共资源，如首页等，是不需要进行授权检查的。这时候，我们只需要一个能灵活配置的授权切入点。如在全局配置了使用基于该URL权限系统的检查器，但可以在局部取消对该资源的检查。这一点，目前主流的框架都能实现。同时应当对公共资源进行限流操作，如同一ip每秒只能请求1次等，可以根据服务器状态进行动态调整。这样可以避免服务器被频繁的请求使得服务器响应缓慢。登录失败时使用密码登录失败时，应当返回 账号或密码不正确 而不应该返回具体的 账号不存在 或者 密码不正确 的信息。这样可以防止别有用心的人进行撞库搜集用户信息。","categories":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/tags/web/"},{"name":"权限系统","slug":"权限系统","permalink":"https://hengxincheung.github.io/tags/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/"}]},{"title":"一个简单的用户系统设计","slug":"web/一个简单的用户系统设计","date":"2020-05-29T08:18:53.000Z","updated":"2020-05-29T12:48:31.838Z","comments":true,"path":"web/一个简单的用户系统设计/","link":"","permalink":"https://hengxincheung.github.io/web/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"用户系统是最基础的构成之一，但是越是基础越是难以设计。在设计用户系统的时候，首先想到的自建一个用户系统，劳烦用户填写资料进行注册登录。但同时还需要考虑如何兼容第三方平台授权登录等。登录方式密码登录账号密码是最常见的一种登录注册设计，适用于普遍场景，鼓励用户用注册方式登录，有利于产品引导用户完善更多的资料，留存自己的用户信息。现在的账号密码登录都会以用户注册填写的用户名、邮箱或手机号代替系统生成的id作为账号。纯账号密码登录是较为早期的设计，例如早期qq和飞信。验证码登录验证码登录，也叫免密登录。主要分为手机短信验证码和邮箱验证码。适用于用户不登录能够完成大部分行为，只有在某种场景下必须获得用户身份时才需要用户登录，且此时用户的想要完成的行为是被要求登录操作打断的。但繁琐的注册或者登录都有可能导致用户流失，所以这时获取用户身份的方式一定要尽可能便捷。一般来说，这种方式在手机号或邮箱未注册过的时候，会自动为用户创建一个账户。第三方授权登录第三方授权登陆，适用于对用户资料和权限要求不高快速解约开发成本的产品。建议在应用构建用户系统的前期可以首先接入第三方，快速的实现登录功能。但是若想建设自身关系链还是需要完善自己的用户系统。用户资料实际也属于用户系统等设计的内容。是否要增加此项的判断原则是根据这个产品对用户资料的需求程度决定用户注册时是否要增加资料填写页，资料填写页是强制阻断性的还是可跳过的，必填的资料项有哪些，希望填的有哪些。表结构系统用户表 useridusernamepasswordtelephoneemail…用户id用户名密码电话号码邮箱其他信息，如密码盐、状态、创建时间等用户授权信息表 user_authiduser_idtypeidentifiercredentialexpire_time…主键id用户id登录类型，如手机验证码、邮箱验证码、微信小程序、微博等授权书，如手机号、邮箱、第三方平台的唯一标识等证书，如验证码、第三方的保存token等过期时间,如验证码等需要其他信息，如创建时间、更新时间等用户资料表 user_profileiduser_idnicknameavatarsexcity…主键id用户id昵称头像性别城市其他信息，如创建时间、修改时间等这里也提供另一种思路，将用户资料表分为两张表，分别是用户资料名和用户资料值，这样可以通过后台自定义去不断扩展需要的用户资料:用户资料名表 user_profile_key：idcodenamedescribeis_fileis_require…主键id资料名编码资料名资料名描述是否文件是否必须其他信息，如创建时间等用户资料值表 user_profile_value：iduser_idprofile_key_idtext_valuefile_value…主键标识用户id资料名id文本值文件值其他信息，如创建时间、更新时间等登录流程密码登录用户在页面输入用户名\\邮箱\\手机号和密码，点击登录；后台只需要校验信息是否在用户表中存在，若存在，则返回成功登录的信息。验证码登录验证码登录主要分为手机验证码和邮箱验证码，两者思路一致，下面以手机验证码为例：用户在页面输入手机号，点击获取验证码按钮；后台校验手机号的合法性，若合法则生成随机数字串并调用短信api向该号码发送短信，同时向用户授权信息表中写入数据（也可以利用缓存增加系统性能）；用户接收到短信后，填写验证码，点击登录按钮；后台在用户授权信息表中校验请求的手机号和验证码是否匹配；若该手机号无绑定的用户(user_id)，则自动创建一个用户进行绑定。注：登录按钮请求的地址可以是同一个，也可以是不同的地址。若是同一个请求地址，可以通过增加 type 字段以区分登录方式，由后台根据 type 字段再进行分发。也可以使用不同的请求地址以区分不同的登录方式。第三方授权登录进入 Web2.0 时代, 许多平台都开放了第三方登录，如微博、微信等。但这些平台的登录逻辑都大大同小异：客户端调用 api 唤起授权页面；客户端将授权通过返回的信息发送到服务器；服务器将授权信息和在各平台注册获取的 appid 和 secret 发送到各开发平台接口；若服务器能查询到正确的用户信息，即表示验证通过；若返回的用户信息并未在用户授权信息表中存在，则为用户自动创建一个账户，并且将相关信息写入用户授权信息表中。手机号/邮箱绑定注册的时候，可能会允许用户不填写手机号或邮箱信息。那么，系统需要增加手机号/邮箱绑定的功能。用户在页面输入手机号/邮箱，点击获取验证码按钮；后台校验手机号的/邮箱合法性，若合法则生成随机数字串并向该手机号/邮箱发送验证码，同时向用户授权信息表中写入数据（也可以利用缓存增加系统性能）；用户接收到短信后，填写验证码，点击绑定按钮；后台在用户授权信息表中校验请求的手机号/邮箱和验证码是否匹配；将当前用户的的 user_id 绑定到授权信息表中。想一想：如果该手机号/邮箱之前已经绑定了其他用户如何处理？","categories":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/tags/web/"},{"name":"用户系统","slug":"用户系统","permalink":"https://hengxincheung.github.io/tags/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/"}]},{"title":"08-多态","slug":"Java编程思想/08-多态","date":"2020-05-27T12:56:56.000Z","updated":"2020-05-27T17:56:21.961Z","comments":true,"path":"Java编程思想/08-多态/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/08-%E5%A4%9A%E6%80%81/","excerpt":"","text":"在面向对象的程序设计语言中，多态（也称为动态绑定，后期绑定或者运行时绑定）是继数据抽象和继承之后的第三种基本特征。封装 通过合并特征和行为来创建新的数据类型；实现隐藏 通过将细节 “私有化” 把接口和实现分离开来。多态 的作用则是消除类型之间的耦合关系。再论向上转型对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。而这种视为其基类型的引用的做法被称为 向上转型。忘记对象类型为什么所有人都故意忘记对象的类型呢？如果我们只写一个简单的方法，它仅接收基类作为参数，而不是那些特殊的子类，会让我们编写的代码只是与基类打交道，显得简单而优雅。特别是许多时候我们并不关心子类的具体类型，只需要知道传入的参数是这个基类，我们只需要利用它们的共性而不是异性。转机方法调用绑定将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定（由编译器和连接程序实现），叫做 前期绑定。这在面向过程语言中是默认的绑定方式，例如C语言。若在运行时候根据对象的类型进行绑定，叫做 后期绑定。如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用正确的方法体。Java中除了 static 和 final 方法之外，其他的方法都是后期绑定。产生正确的行为一旦知道Java中的所有方法都是通过动态绑定实现多态这个事实之后，我们就可以编写只与其基类打交道的程序代码了。并且这些代码对所有子类都可以正确运行了。或者说，发送消息给某个对象，让该对象去判断做什么事情。可扩展性假设我们有一个名为 Instrument 的基类。由于有了多态机制，我们可以根据自己的需要对系统添加任意多的新类型，而不需要更改其 tune() 方法。在一个设计良好的OOP程序中，大多数或者所有方法都会遵循 tune() 的模型，而且只与基类接口通信。这样的程序是可扩展的，因为可以从通用的基类继承出新的数据类型，从而添加一些功能。那些操纵基类接口的方法不需要任何改动就可以应用于新类。构造器和多态通常，构造器不同于其他种类的方法。涉及多态时仍是如此。尽管构造器并不具有多态性（构造方法实际上是 static 方法，只不过这种声明是隐式的）。构造器的调用顺序基类的构造器总是在子类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使得每个基类的构造器都得到调用。因为构造器具有一项特殊的任务：检查对象是否正确地构造。构造器的执行遵循下列顺序：调用基类构造器。这个步骤会不断反复递归下去。按声明顺序调用成员的初始化方法。调用子类的构造器的主体。构造器内部的多态方法的行为如果一个构造器的内部调用正在构造的对象的某个动态绑定方法，那会发生什么情况呢？如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖后的定义。然而，这个调用的效果可能相当难以预料，因为被覆盖的方法在对象被完全构造之前会被调用。这可能会造成一些难以发现的隐藏错误。初始化的完整过程是：在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的零。如前所述调用基类构造器。按照声明的顺序调用成员的初始化方法。调用子类的构造器主体。这样做有一个优点，那就是所有东西都至少初始化为了零，这通常也是发现问题的证据。因此，编写构造器有一条有效的准则：用尽可能简答的方法使对象进入正常状态；如果可以，避免调用其他方法。在构造器内唯一能够安全调用的那些方法是基类中的 final 或 private 方法，这些方法不能被覆盖，因此也不会出现不可预知的问题。协变返回类型Java SE5 中添加了协变返回类型，它表示在子类的被覆盖方法中可以返回基类方法的返回类型的某种子类型。即可以返回原返回类型的子类。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"07-复用类","slug":"Java编程思想/07-复用类","date":"2020-05-27T11:30:44.000Z","updated":"2020-05-27T15:14:38.754Z","comments":true,"path":"Java编程思想/07-复用类/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/07-%E5%A4%8D%E7%94%A8%E7%B1%BB/","excerpt":"","text":"组合：在新的类中产生现有类的对象。继承：按照现有类的类型来创建新类。继承是面向对象设计的基石之一。组合语法假设你需要某个对象，它要具有多个 String 对象，几个基础类型数据，以及另一个类的对象。1234567891011121314151617181920212223242526class WaterSource&#123; private String s; public WaterSource()&#123; System.out.println(\"WaterSource()\"); &#125; public String toString()&#123; return s; &#125;&#125;public class SprinklerSystem&#123; private String value1, value2; private WaterSource waterSource = new WaterSource(); private int i; private float f; public String toString()&#123; return \"value1 = \" + value1 + \"\\n\" + \"value2 = \" + value2 + \"\\n\" + \"i = \" + i + \"\\n\" + \"f = \" + f + \"\\n\" + \"waterSource = \" + waterSource + \"\\n\" &#125;&#125;如上面的代码所示，我们并没有初始化各个变量。正如前面的章节所提到的，基本类型能够被自动初始化为零。但是对象引用会被初始化为 null。但是，当你尝试打印 SprinklerSystem 对象时，可以在不抛出异常的情况下打印出一个 null 引用，这对于我们调式程序十分方便和有用。你可以认为，是编译器在打印过程中将 null 引用转换为了字符串。toString() 方法每一个非基本类型的对象都有一个 toString() 方法，而当编译器需要一个 String 而却只有一个对象时，该方法便会被调用。如果你没有重写 toString() 方法，那么将使用继承于 Object 类的 toString() 方法（除非你继承的类中重写了该方法），返回的是 类名@hashcode。初始化的正确位置如果想初始化引用，可以在代码中的下列位置进行：在定义对象的地方，这意味着它们总能够在构造器被调用之前被初始化。在类的构造器中。在正要使用这些对象之前，这种方式被称为惰性初始化。在生成类对象前不必生成其包含的其他对象，这种方式可以减少额外的负担。继承语法继承是所有 OOP 语言不可缺少的组成部分。当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承，否则就是隐式地从Java标准根类 Object 进行继承。继承使用一种特殊的语法，这种声明通过在类主体的左边花括号之前，书写关键字 extends 和需要继承的基类而实现。当这么做之后，会自动获得基类中的所有域和方法。123456789class Cleanser&#123; private String s; public void append(String a) &#123;s += a;&#125; public String toString() &#123;return s;&#125;&#125;public class Detergent extends Cleanser&#123; public foam()&#123;system.out.println(\"foam()\");&#125;&#125;由上述的代码所示，类 Detergent 天然就拥有了基类的 Cleanser 的 append() 和 toString() 方法。当然，你也可以通过重写同名的方法以覆盖父类中的方法。如果覆盖了父类中的方法，又想要在子类中的调用基类继承而来的方法，可以使用 super 关键字以实现。如 super.append(&quot;调用父类中的方法&quot;);。如何继承基类的属性与属性当创建一个子类的对象时，该对象会包含一个基类的子对象。这个子对象与你直接使用基类创建的对象是一样的。二者的区别是，后者来源于外部，而基类的子对象被包装在导出类对象内部。你可以认为这个基类的子对象就是 super。 那么我们不妨猜测继承的工作机制是如下所示：调用方法中的一个属性或方法。在本对象中判断是否具有该属性或方法，若有则执行并返回。否则，在基类子对象中一直向上寻找是否具有该属性或方法，若有则执行并返回。若寻找到根类 Object 中也没有该属性或方法，则抛出属性或方法不存在的异常。初始化基类对基类子对象的正确初始化是直观重要的，而且仅有一种方法来保证这一点：在构造器中调用基类构造器来执行初始化。如果你没有显式在构造器中的第一行（必须是第一行），Java会自动在子类的构造器中插入对基类构造器的调用。构造过程是从基类“向外”扩散的，所以基类子对象在子类构造器可以访问它之前，就已经完成了初始化。带参数的构造器如果没有默认的基类构造器，或者想要调用一个带参数的基类构造器，就必须使用关键字 super 显示编写调用基类构造器的语法，并匹配适当的参数列表。123456789class Game&#123; public Game(String name)&#123; system.out.println(\"You are playing \" + name); &#125; &#125;class Chess extends Game&#123; public Chess()&#123;&#125;&#125;如果基类的构造器需要参数列表，而你没有显示调用基类构造器，编译器就会“抱怨”无法找到符合默认构造器形式的构造器。而且，调用调类构造器必须是你在子类构造器中要做的第一件事，否则构造器也会“提醒”你。名称屏蔽如果 Java 的基类拥有某个已被多次重载的方法名称，那么在子类中重新定义该方法名称并不会屏蔽其在基类中的任何版本。Java SE5 新增了 @Override 注解。它并不是关键字，但是可以把它当作关键字使用。当你想要覆写某个方法时，可以选择添加这个注解。在你不留心重载而不是覆写该方法时，编译器会生成一条错误信息提示你:1method does not override a method from its superclassprotected 关键字关键字 protected 指明了：就类用户而言，这是 private 的。但对于任何继承与此类的任何子类或其他任何位于同一个包内的类来说，它却是可以访问的。note：protected 也提供了包内访问权限。尽管可以创建 protected 域，但是最好的方式还是将域保持为 private：你应当一直保留更改底层实现的权力。然后通过 protected 方法来控制类的继承者的访问权限。向上转型为新类提供方法并不是继承技术最重要的考虑。其最重要的方面是用来表现新类与基类之间的关系。这种关系可以用“新类是现有类的一种类型”加以概括。Java 对类型的检查十分严格，接收某种类型的方法同样可以接收另一种类型会显得十分奇怪。除非编译器意识到接收的对象是需要类型的子类。这种将子类引用转换为基类引用的动作，称作向上转型。子类是基类的一个超集，它可能比基类含有更多的方法，但它必须至少具备基类中的方法。在向上转型的过程中，类接口唯一可能发生的事情就是丢失方法。但这种丢失只是在编译层面的，实际上在运行时仍保留着子类所有的方法。但是如果你用正常的方法去调用方法将会引起编译错误。对于这种情况，你可以通过反射去调用，但这种方式不予以推荐。final 关键字final 数据一块永恒不变的数据：一个永不改变的编译时常量。一个在运行时被初始化的值，但初始化后不可以改变。对于基本类型，final 使得数值恒定不变；而对于对象引用，final 使得引用恒定不变，即一旦引用被初始化指向一个对象，就无法再把它指向另一个对象。final 方法使用 final 方法的原因有两个：把方法锁住，以防任何继承类修改它的含义，不会被覆盖；效率。将一个方法指明为 final，就是同意编译器针对该方法的所有调用都转为内嵌调用。但现在并不建议使用 final 进行优化，因为虚拟机变得功能更加强大了。final 和 private 关键字类中所有的 private 方法都隐式地指定为了 final。由于无法取用 private 方法，所以也无法覆盖它。可以对 private 方法添加 final 修饰词，但并无任何额外的意义。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"随机森林简述","slug":"统计机器学习/随机森林简述","date":"2020-05-26T06:53:11.000Z","updated":"2020-05-27T07:22:46.853Z","comments":true,"path":"统计机器学习/随机森林简述/","link":"","permalink":"https://hengxincheung.github.io/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E7%AE%80%E8%BF%B0/","excerpt":"","text":"摘要摘要：随机森林是一种灵活的、便于使用的统计学习方法，即使在没有超参数调整的情况下，往往也能取得好的结果。随机森林是典型的集成学习例子，采用自举法生成多个样本集并分别进行建模，然后组合多颗决策树的预测并投票得出最终结果。随机森林具有较高的预测准确率，且对异常值和噪声不敏感，不容易出现过拟合，在医学、生物信息等领域有着广泛的应用。关键字：随机森林; 集成学习; 自举; 决策树1 前言传统的分类模型往往精度不高，且容易出现过拟合问题。而如支持向量机(Support Vector Machine, SVM)、多层神经网络等模型又很少能提供对数据内部关系的观察能力，但这种透明度对于医学决策支持、质量控制等应用领域是至关重要的。因此，很多学者通过聚集多个简单模型来提高预测精度和模型解释性。这种方法被称为集成(ensemble)或分类器组合(classifier combination)，其核心思想在于利用训练数据构建一组基分类模型(base classifier)，然后通过对每个基分类器模型的预测值进行投票（预测值为离散变量）或取平均值（预测值为连续变量）来输出最终的预测值。随机森林（Random Forest，RF）是由Leo Bremian与Adele Cutler于2011年提出的一种以决策树作为弱分类器的集成分类器。传统的CART决策树可以提供对内部关系的观察能力，但对训练集中的小波动十分敏感，而随机森林充分吸收了决策树的优点并最大化消除了其缺点。为了生成随机森林，通常需要生成随机变量来控制组合中的每个决策树的生长。装袋算法（Bagging）是早期组合树方法之一，又称自助聚集（bootstrap aggregating），是一种从训练集随机抽取部分样本来生成决策树的方法。同时，Ho关于随机子空间（Random subspace）方法做了许多研究，该方法通过对特征变量随机选取子集来生成每颗决策树，对随机森林的研究起到巨大的推进。随机森林利用自举法（Bootstrap）方法从原始样本集中进行重采样，进而得到多个样本集，对每个样本集进行决策树建模，然后组合多棵决策树的结果，最后通过投票得出最终的预测结果。大量的理论和研究都证明了随机森林具有很高的预测准确率，且不容易出现过拟合。总结来说，随机森林是一种自然的非线性建模工具，在数据挖掘、生物医学等领域有重大意义和广泛应用。2 随机森林相关概念介绍2.1 自举法2.1.1 自举法简介自举法是一种通过抽取多个样本集来估计抽样分布的方法，这些样本集中包含单个随机样本的替换内容。这些重复样本被称为重新采样的样本。每个重新采样的样本集的数量小于等于原始样本的数量。自举法是非参数统计中一种重要的估计统计量，并可进行统计量区间估计的统计方法。并且，自举法还可以用来进行假设检验。2.1.2 自举法的基本思想自举法的基本思想如下:从原始样本集中随机抽取一个样本，将其副本放入新的样本集中，并将该样本放回到原始样本集中；重复采样$m$次，即可得到一个新的样本集。其中次数$m$一般要小于原始样本集的数目$n$;重复上述步骤$k$次，即可得到$k$个新的样本集，计算这$k$个样本集的统计量。2.1.3 自举法的代码实现123456789101112131415161718192021222324252627import randomimport numpy as npfrom sklearn import datasets# 加载iris数据集iris = datasets.load_iris()iris = np.hstack((iris.data, iris.target.reshape(-1, 1)))# 定义新的样本集的列表samples_list = []# 生成10个新的样本集for k in range(10): # 定义新的样本集 samples = [] # 新的样本集中采样100个样本 for m in range(100): # 获得一个随机下标 idx = random.randint(0, iris.shape[0]-1) # 得到一个样本 sample = iris[idx, :].reshape(1, -1) # 添加进入新的样本集中 samples.append(sample) samples = np.array(samples) print(f\"样本集[&#123;k&#125;]的维度是:&#123;samples.shape&#125;\") # 将新的样本集添加到列表中 samples_list.append(samples)samples_list = np.array(samples_list)2.2 集成分类器以多个弱分类器组合成的分类器通常被称为集成分类器(Ensemble Classifier)。常见的集成分类器包括 Boosting和Bootstrap aggregation（简称Bagging）。2.2.1 BoostingBoosting通常的做法是迭代地重复调用弱分类器学习算法构造一系列弱分类器，然后将它们以加权的方式联合起来形成一个强分类器。迭代是Boosting方法的显著特征。Boosting的基本流程如下：（1）在首轮调用弱学习算法时，以均匀分布从训练样本全集中抽取一个训练样本子集，并在此子集上学习生成弱分类器；（2）以后每轮对选取此轮样本子集时对前一轮训练失败的样本给以更大的分布权值，使其在这一轮训练中出现的概率增加，使后续的弱分类器集中对比较难训练的样本进行学习，最后在此子集上学习生成弱分类器；（3）迭代若干次后会得到一系列弱分类器，每个都有一个对应的权值，其权值大小根据该分类器的效果而定。最后的分类器由生成的多个分类器加权联合产生。2.2.2 BaggingBagging是Leo Breiman在1996年提出的通过组合随机生成的训练集而改进分类的集成算法。与Boosting的迭代做法不同，Bagging以独立同分布选取的训练样本子集训练弱分类器，作为其组成元素的各个弱分类器之间也是平权的。许多研究都指出神经网络、CART 树和线性回归中的子集选择都是不稳定的，而Bagging可以正常处理不稳定情形。Bagging通过将独立同分布的弱分类器通过平均集成起来，可以在使偏差保持基本不变的同时降低方差以及弱分类器之间相关值的平均。这样，如果独立同分布的弱分类器的相关值和偏差都较小，则总的分类误差可以降低。实践和理论双方面都表明，Bagging可以将一个好的但不稳定的过程向着最优化的方向椎动一大步，它可以相对性的降低对稳定性的要求。2.3 决策树2.3.1 决策树简介决策树(decision tree)是一类常见的机器学习方法。一般地，一颗决策树包含一个根节点、若干个内部节点和若个叶子节点，其中叶子节点对应于决策结果，其他每个节点则对应于一个属性测试。每个节点包含的样本集合根据属性测试的结果被划分到子节点中。根节点包含整个样本集，从根节点到每个叶子节点的路径对应了一个判定测试序列。决策树学习的目的是为了产生一棵泛化能力强，即处理未见示例能力强的决策树。决策树学习算法主要由三部分构成：（1）特征选择；（2）决策树生成；（3）决策树剪枝。决策树学习算法最著名的代表是ID3、C45和CART。这些算法主要区别在于分类节点上特征选取的标准不同。常用的划分标准包括信息增益、增益率、基尼指数等。此外学者们还设计了许多其他的准则，然而实验表明划分标准只对决策树的尺寸有较大影响，但对泛化能力的影响有限。2.3.2 决策树的基本思想决策树是一种基本的分类与回归方法，它可以看作是一系列if-then规则的集合，也可以认为是定义在特征空间与类空间的条件概率分布。决策树的根节点到叶节点的每一条路径构建一条规则，路径内部节点的特征对应着规则的条件，叶子节点的类则对应着规则的结论。决策树的生成流程遵循简单且直观的“分而治之”（divide-and-conquer）策略：生成一个树节点$node$；如果样本集中的样本全属于同一个类别$C$，将树节点$node$标记为$C$类叶子节点，返回该树节点；如果属性集$A$为空集或者样本在属性集$A$上取值相同，将树节点$node$标记为样本集$D$中最多的类，返回该树节点成；从属性集$A$中选取最优划分属性$a_*$;遍历最优划分属性$a_$中的每一个值$a_{}^{v}$，为树节点$node$生成一个分支，在样本集$D$中选出在$a_$上取值为$a_{}^{v}$的样本子集$D_v$。如果$D_v$为空，则将分支节点标记为叶节点，其类别标记为$D$中最多的类，返回该树节点；否则，以$(D_v, A \\setminus a_*)$作为分支节点，重复上述步骤。显然，决策树的关键在于如何选择最优划分属性。一般而言，随着划分过程不断进行，决策树的分支节点所包含的样本尽可能都属于同一类别，即节点的“纯度”（purity）越来越高。2.3.3 决策树的优缺点决策树的优点:易于理解和解释，甚至比线性回归更直观；与人类做决策思考的思维习惯相吻合；模型可以通过树的形式进行可视化展示；可以直接处理非数值型数据，不需要进行哑变量的转化，甚至可以直接处理含缺失值的数据。决策树的缺点：对于有大量数值型输入和输出的问题，决策树未必是一个好的选择；当数值型变量之间存在许多错综复杂的关系，模型不能很好的处理；模型鲁棒性差，某一个节点的小小变化都可能导致整棵树发生变化。2.3.4 决策树的代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245import mathdef divide_on_feature(X, feature_i, threshold): \"\"\" 基于特征索引上的样本值是否大于给定的阈值进行分割\"\"\" split_func = None if isinstance(threshold, int) or isinstance(threshold, float): split_func = lambda sample: sample[feature_i] &gt;= threshold else: split_func = lambda sample: sample[feature_i] == threshold X_1 = np.array([sample for sample in X if split_func(sample)]) X_2 = np.array([sample for sample in X if not split_func(sample)]) return np.array([X_1, X_2])def calculate_entropy(y): \"\"\" 计算熵 \"\"\" log2 = lambda x: math.log(x) / math.log(2) unique_labels = np.unique(y) entropy = 0 for label in unique_labels: count = len(y[y == label]) p = count / len(y) entropy += -p * log2(p) return entropydef accuracy_score(y_true, y_pred): \"\"\" 计算精度\"\"\" accuracy = np.sum(y_true == y_pred, axis=0) / len(y_true) return accuracyclass DecisionNode(): \"\"\"决策树节点\"\"\" def __init__(self, feature_i=None, threshold=None, value=None, true_branch=None, false_branch=None): self.feature_i = feature_i # 特征索引 self.threshold = threshold # 特征的阈值 self.value = value # 叶子节点的值 self.true_branch = true_branch # 子树 self.false_branch = false_branch # 子树class DecisionTree(object): \"\"\"决策树\"\"\" def __init__(self, min_samples_split=2, min_impurity=1e-7, max_depth=float(\"inf\"), loss=None): self.root = None # 根节点 # 调整拆分的最小样本数 self.min_samples_split = min_samples_split # 调整拆分的最小不纯度 self.min_impurity = min_impurity # 树生长的最大深度 self.max_depth = max_depth # 切割树的方法，gini，方差等 self._impurity_calculation = None # 树节点取值的方法，分类树：选取出现最多次数的值，回归树：取所有值的平均值 self._leaf_value_calculation = None # 标签是不是one-hot编码 self.one_dim = None self.loss = loss def fit(self, X, y, loss=None): \"\"\" 训练决策树 \"\"\" self.one_dim = len(np.shape(y)) == 1 self.root = self._build_tree(X, y) self.loss = None def _build_tree(self, X, y, current_depth=0): \"\"\" 递归地构建决策树\"\"\" largest_impurity = 0 best_criteria = None # 特征索引和与之 best_sets = None # 数据集的子集 # 检查y是否扩展 if len(np.shape(y)) == 1: y = np.expand_dims(y, axis=1) # 把y加到X的最后一列上 Xy = np.concatenate((X, y), axis=1) n_samples, n_features = np.shape(X) if n_samples &gt;= self.min_samples_split and current_depth &lt;= self.max_depth: # 计算每个特征的不纯度 for feature_i in range(n_features): # 特征i的所有值 feature_values = np.expand_dims(X[:, feature_i], axis=1) unique_values = np.unique(feature_values) # 遍历特征列i的所有唯一值并计算不纯度 for threshold in unique_values: # 根据索引特征i处X的特征值是否满足阈值来划分X和y Xy1, Xy2 = divide_on_feature(Xy, feature_i, threshold) if len(Xy1) &gt; 0 and len(Xy2) &gt; 0: # 选择两个集合的y值 y1 = Xy1[:, n_features:] y2 = Xy2[:, n_features:] # 计算不纯度 impurity = self._impurity_calculation(y, y1, y2) # 如果此阈值导致比先前记录的信息增益更高，则保存阈值和特征索引 if impurity &gt; largest_impurity: largest_impurity = impurity best_criteria = &#123;\"feature_i\": feature_i, \"threshold\": threshold&#125; best_sets = &#123; \"leftX\": Xy1[:, :n_features], \"lefty\": Xy1[:, n_features:], \"rightX\": Xy2[:, :n_features], \"righty\": Xy2[:, n_features:], &#125; if largest_impurity &gt; self.min_impurity: # 为左右分支建立子树 true_branch = self._build_tree(best_sets[\"leftX\"], best_sets[\"lefty\"], current_depth + 1) false_branch = self._build_tree(best_sets[\"rightX\"], best_sets[\"righty\"], current_depth + 1) return DecisionNode(feature_i=best_criteria[\"feature_i\"], threshold=best_criteria[ \"threshold\"], true_branch=true_branch, false_branch=false_branch) # 我们在leaf=&gt;确定价值 leaf_value = self._leaf_value_calculation(y) return DecisionNode(value=leaf_value) def predict_value(self, x, tree=None): \"\"\" 递归搜索得到的叶子节点的值\"\"\" if tree is None: tree = self.root # 如果我们有一个值（即在叶子节点上）=&gt;返回值作为预测 if tree.value is not None: return tree.value # 选择要测试的特征 feature_value = x[tree.feature_i] # 确定是跟随左分支还是跟随右分支 branch = tree.false_branch if isinstance(feature_value, int) or isinstance(feature_value, float): if feature_value &gt;= tree.threshold: branch = tree.true_branch elif feature_value == tree.threshold: branch = tree.true_branch # 测试子树 return self.predict_value(x, branch) def predict(self, X): \"\"\" 预测单个样本 \"\"\" y_pred = [] for x in X: y_pred.append(self.predict_value(x)) return y_pred def print_tree(self, tree=None, indent=\" \"): \"\"\" 可视化决策树 \"\"\" if not tree: tree = self.root # 如果是叶子节点，打印 if tree.value is not None: print(tree.value) # 往深处寻找 else: print(\"%s:%s? \" % (tree.feature_i, tree.threshold)) print(\"%sT-&gt;\" % (indent), end=\"\") self.print_tree(tree.true_branch, indent + indent) print(\"%sF-&gt;\" % (indent), end=\"\") self.print_tree(tree.false_branch, indent + indent)class ClassificationTree(DecisionTree): \"\"\"分类树\"\"\" def _calculate_information_gain(self, y, y1, y2): # 切割树的标准，这里使用的是交叉熵 p = len(y1) / len(y) entropy = calculate_entropy(y) info_gain = entropy - p * \\ calculate_entropy(y1) - (1 - p) * \\ calculate_entropy(y2) # print(\"info_gain：\", info_gain) return info_gain def _majority_vote(self, y): # 计算子节点值的方法，这里使用的是选取数据集中出现最多的种类 most_common = None max_count = 0 for label in np.unique(y): # Count number of occurences of samples with label count = len(y[y == label]) if count &gt; max_count: most_common = label max_count = count # print(\"most_common :\", most_common) return most_common def fit(self, X, y): # 将分类树切割的标准与计算子节点值的方式传回给基类DecisionTree self._impurity_calculation = self._calculate_information_gain self._leaf_value_calculation = self._majority_vote super(ClassificationTree, self).fit(X, y)class RegressionTree(DecisionTree): def _calculate_variance_reduction(self, y, y1, y2): # 切割树的标准，这里使用的是平方残差 var_tot = calculate_variance(y) var_1 = calculate_variance(y1) var_2 = calculate_variance(y2) frac_1 = len(y1) / len(y) frac_2 = len(y2) / len(y) # 计算方差减少量 variance_reduction = var_tot - (frac_1 * var_1 + frac_2 * var_2) return sum(variance_reduction) def _mean_of_y(self, y): # 计算子节点值的方法，这里使用的是取数据集中的平均值 value = np.mean(y, axis=0) return value if len(value) &gt; 1 else value[0] def fit(self, X, y): # 将回归树切割的标准与计算子节点值的方式传回给基类DecisionTree self._impurity_calculation = self._calculate_variance_reduction self._leaf_value_calculation = self._mean_of_y super(RegressionTree, self).fit(X, y)# 测试代码from sklearn import datasetsfrom sklearn.model_selection import train_test_splitimport numpy as npimport matplotlib.pyplot as plt# 加载iris数据集data = datasets.load_iris()X = data.datay = data.target# 切割训练集和测试集X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4)# 实例化分类树clf = ClassificationTree()clf.fit(X_train, y_train)y_pred = clf.predict(X_test)accuracy = accuracy_score(y_test, y_pred)print (\"Accuracy:\", accuracy)3 随机森林3.1 随机森林的定义随机森林是一个由$k$个树状分类器$h(x, \\theta_k), k=1,2,…$组成的分类器，且每棵树为输入变量$x$归属于哪个类投出平等的一票。这里的$\\theta_k$是独立同分布的随机向量，它通过在独立同分布的bootstrap集上学习而被独立同分布地确定。在预测的时候，被$\\theta_k$确定的第$k$棵树被用来对输入向量$x$做预测。3.2 抗过拟合性质设有一个包括若干未知参数的模型和为便于拟合该模型提供的数据集，拟合过程可以简要定义为通过优化模型参数使得模型尽量与训练数据拟合。如果用一个从训练数据相同群落中独立的抽取验证数据，总会发现模型不能像拟合训练数据一样好的拟合验证数据，这被称为过拟合。通常过拟合的程度可以以泛化误差来表现。在随机森林的定义基础上，这里假设训练集$\\{(x,y)\\}$是由随机向量$X$和$Y$分布所抽取出来的，那么可以定义边际函数为：mg(X, Y) = av_kI(h_k=y) - max_{j \\ne y}av_kI(h_k(x)=j)其中，函数$I(\\bullet)$表示示性函数，$av_k(\\bullet)$表示取平均。这里的边际函数表示在$X$和$Y$分布下正确投票数的平均数超出错误投票平均数的值。这个值越大则分类正确的信息越大。这样，泛化误差可以如下式表示：PE = P_{x,y}(mg(X,Y)","categories":[{"name":"统计机器学习","slug":"统计机器学习","permalink":"https://hengxincheung.github.io/categories/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"统计机器学习","slug":"统计机器学习","permalink":"https://hengxincheung.github.io/tags/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"随机森林","slug":"随机森林","permalink":"https://hengxincheung.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"}]},{"title":"git命令大全","slug":"git/git命令大全","date":"2020-05-26T06:51:35.000Z","updated":"2020-05-27T07:23:06.623Z","comments":true,"path":"git/git命令大全/","link":"","permalink":"https://hengxincheung.github.io/git/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"","text":"参考文档git 命令123456789101112131415161718192021222324252627282930语法： git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;&#x3D;&lt;value&gt;] [--exec-path[&#x3D;&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p|--paginate|--no-pager] [--no-replace-objects] [--bare] [--git-dir&#x3D;&lt;path&gt;] [--work-tree&#x3D;&lt;path&gt;] [--namespace&#x3D;&lt;name&gt;] [--super-prefix&#x3D;&lt;path&gt;] &lt;command&gt; [&lt;args&gt;] 选项： --version # 打印git程序的版本号 --help # 打印概要和最常用命令的列表 -C &lt;path&gt; # 在&lt;path&gt;而不是当前的工作目录中运行git -c &lt;name&gt;&#x3D;&lt;value&gt; # 将配置参数传递给命令, 给定的值将覆盖配置文件中的值 --exec-path[&#x3D;&lt;path&gt;] # 安装核心Git程序的路径, 可以通过设置GIT_EXEC_PATH环境变量来控制, 如无路径, git将打印当前设置并退出 --html-path # 打印Git的HTML文档安装并退出的路径, 不带斜杠 --man-path # 打印man(1)此版本Git的手册页的manpath, 并退出 --info-path # 打印记录此版本Git的Info文件的安装路径并退出 -p, --paginate # 如果标准输出是终端, 则将所有输出管道更少（或如果设置为$ PAGER）, 这将覆盖pager.&lt;cmd&gt; 配置选项 --no-pager # 不要将Git输出管道传输到寻呼机 --no-replace-objects # 不要使用替换参考来替换Git对象 --bare # 将存储库视为裸存储库, 如果未设置GIT_DIR环境, 则将其设置为当前工作目录 --git-dir&#x3D;&lt;path&gt; # 设置存储库的路径, 可以通过设置GIT_DIR环境变量来控制, 可以是当前工作目录的绝对或相对路径 --work-tree&#x3D;&lt;path&gt; # 设置工作树的路径, 可以通过设置GIT_WORK_TREE环境变量和core.worktree配置变量来控制, 相对于当前工作目录的绝对或相对路径 --namespace&#x3D;&lt;path&gt; # 设置Git命名空间, 相当于设置GIT_NAMESPACE环境变量 --super-prefix&#x3D;&lt;path&gt; # 目前仅供内部使用, 设置一个前缀, 该前缀从存储库到根的路径, 一个用途是给调用它的超级项目的子模块上下文 --literal-pathspecs # 字面上处理pathspecs, 相当于设置GIT_LITERAL_PATHSPECS为1 --glob-pathspecs # 添加&quot;glob&quot;到所有pathspec, 相当于设置GIT_GLOB_PATHSPECS为1 --noglob-pathspecs # 添加&quot;文字&quot;到所有pathspec, 相当于设置GIT_NOGLOB_PATHSPECS为1 --icase-pathspecs # 添加&quot;icase&quot;到所有pathspec, 相当于设置GIT_ICASE_PATHSPECS为1 --no-optional-locks # 不要执行需要锁定的可选操作, 相当于设置GIT_OPTIONAL_LOCKS为0config 命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546语法： git config [&lt;file-option&gt;] [type] [--show-origin] [-z|--null] name [value [value_regex]] git config [&lt;file-option&gt;] [type] --add name value git config [&lt;file-option&gt;] [type] --replace-all name value [value_regex] git config [&lt;file-option&gt;] [type] [--show-origin] [-z|--null] --get name [value_regex] git config [&lt;file-option&gt;] [type] [--show-origin] [-z|--null] --get-all name [value_regex] git config [&lt;file-option&gt;] [type] [--show-origin] [-z|--null] [--name-only] --get-regexp name_regex [value_regex] git config [&lt;file-option&gt;] [type] [-z|--null] --get-urlmatch name URL git config [&lt;file-option&gt;] --unset name [value_regex] git config [&lt;file-option&gt;] --unset-all name [value_regex] git config [&lt;file-option&gt;] --rename-section old_name new_name git config [&lt;file-option&gt;] --remove-section name git config [&lt;file-option&gt;] [--show-origin] [-z|--null] [--name-only] -l | --list git config [&lt;file-option&gt;] --get-color name [default] git config [&lt;file-option&gt;] --get-colorbool name [stdout-is-tty] git config [&lt;file-option&gt;] -e | --edit选项： --system # 使用系统配置文件 --global # 使用全局配置文件 --local # 使用本地配置文件, 默认 -f &lt;filename&gt;, --file &lt;filename&gt; # 使用指定配置文件 --blob &lt;blob-id&gt; # 使用指定blob --int # 确保输出为简单十进制数 --bool # 确保输出为&quot;true&quot; 或 &quot;false&quot; 的布尔字符串表示 --bool-or-int # 确保输出为--bool或--int的格式 --path # 将扩展~到指定用户的主目录的值 $HOME和~user主目录。 --replace-all # 替换与该键匹配的所有行 --add # 添加配置项 --get # 获取给定键的值（可选用与值匹配的正则表达式进行过滤） --get-all # 像get一样，但返回多值键的所有值 --get-regexp # 像get-all一样，但将该名称解释为正则表达式并写出键名称 --get-urlmatch name URL # 当给定一个由两部分组成的名称section.key时，会返回部分&lt;url&gt;.key的值 --remove-section # 从配置文件中删除给定的部分 --rename-section # 将给定部分重命名为新名称 --unset # 从配置文件中删除与密钥匹配的行 --unset-all # 从配置文件中删除所有与密钥匹配的行 -l, --list # 列出在配置文件中设置的所有变量及其值 --expiry-date # 将确保输出从固定或相对日期字符串转换为时间戳, 设置该值时此选项无效 -z, --null # 对于输出值和&#x2F;或键的所有选项，始终使用空字符结束值, 使用换行符作为键和值之间的分隔符 --name-only # 输出--listor 的配置变量的名称--get-regexp --show-origin # 使用原点类型（文件, 标准输入, blob, 命令行）和实际原点（配置文件路径, ref或blob id）扩大所有查询配置选项的输出 --get-colorbool name [stdout-is-tty]# 找到name（例如color.diff）的颜色设置并输出&quot;true&quot;或&quot;false&quot; --get-color name [default] # 查找name（例如color.diff.new）配置的颜色并将其作为ANSI颜色转义序列输出到标准输出 -e, --edit # 打开一个编辑器来修改指定的配置文件; 或者 --system，--global或者存储库（默认） --[no-]includes # 查找值, 默认off, on搜索所有配置文件, 当值定文件时（使用：--file，--global等）help 命令12345678910语法： git help [-a|--all] [-g|--guide] [-i|--info|-m|--man|-w|--web] [COMMAND|GUIDE]选项： -a, --all # 在标准输出上打印所有可用的命令 -g, --guide # 在标准输出上打印有用的指南列表 -i, --info # 以信息格式显示命令的手册页 -m, --man # 以man格式显示命令的手册页 -w, --web # 以Web（HTML）格式显示命令的手册页init 命令12345678910111213141516语法： git init [-q | --quiet] [--bare] [--template&#x3D;&lt;template_directory&gt;] [--separate-git-dir &lt;git dir&gt;] [--shared[&#x3D;&lt;permissions&gt;]] [directory]选项： -q, --quiet # 仅打印错误和警告消息, 所有其他输出将被抑制 --bare # 创建一个裸仓库, 如果GIT_DIR未设置环境, 则将其设置为当前工作目录 --template&#x3D;&lt;template_directory&gt; # 指定将使用模板的目录 --separate-git-dir&#x3D;&lt;git dir&gt; # 相反, 初始化存储库作为目录之一$GIT_DIR或者.&#x2F;.git&#x2F;, 创建一个包含路径的实际存储库的文本文件存在, 该文件充当文件系统不可知的Git与存储库的符号链接 --shared[&#x3D;(false|true|umask|group|all|world|everybody|0xxx)] # 指定Git存储库在多用户间共享, 允许同一组的用户推入该存储库 umask (or false) # 使用由umask(2)报告的权限, --shared未指定时的默认值 group (or true) # 使存储库组可写 all (or world or everybody) # 与组相同，但使存储库可供所有用户读取 0xxx # 0xxx是八进制数, 每个文件都有模式0xxx。 0640将创建一个组可读的存储库, 但不能对其他组进行写入或访问。0660将创建一个对当前用户和组可读可写的回购, 但其他人无法访问。clone 命令12345678910111213141516171819202122232425262728293031323334353637语法： git clone [--template&#x3D;&lt;template_directory&gt;] [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror] [-o &lt;name&gt;] [-b &lt;name&gt;] [-u &lt;upload-pack&gt;] [--reference &lt;repository&gt;] [--dissociate] [--separate-git-dir &lt;git dir&gt;] [--depth &lt;depth&gt;] [--[no-]single-branch] [--no-tags] [--recurse-submodules[&#x3D;&lt;pathspec&gt;]] [--[no-]shallow-submodules] [--jobs &lt;n&gt;] [--] &lt;repository&gt; [&lt;directory&gt;]选项： -l, --local # 当克隆的存储库位于本地计算机上时, 此标志绕过正常的“Git aware”传输机制, 并通过复制HEAD以及对象和引用目录下的所有内容来克隆存储库 --no-hardlinks # 强制从本地文件系统的存储库复制进程, 以复制目录下的.git&#x2F;objects 文件而不是使用硬链接 -s, --shared # 当克隆的存储库位于本地计算机上时, 将自动设置.git&#x2F;objects&#x2F;info&#x2F;alternates为与源存储库共享对象, 而不是使用硬链接, 生成的存储库首先没有任何对象 --reference[-if-able] &lt;repository&gt; # 如存储库位于本地计算机上, 则自动设置.git&#x2F;objects&#x2F;info&#x2F;alternates为从存储库获取对象将已存在存储库用作备用存储库将需从正在克隆的存储库中复制更少对象, 而降低网络和本地存储成本 --dissociate # 借助--reference仅使用选项指定的引用存储库借用对象, 以减少网络传输, 并通过制作所需的借用对象的本地副本, 在克隆完成后停止借用它们 -q, --quiet # 安静地操作, 进度未报告给标准错误流 -v, --verbose # 运行详细, 不影响向标准错误流报告进度状态 --progress # 当连接到终端时，默认情况下, 标准错误流中会报告进度状态，除非指定-q，即使标准错误流未定向到终端, 此标志也会强制进度状态 -n, --no-checkout # 克隆完成后, 不执行HEAD签出 --bare # 制作一个纯粹的 Git存储库 --mirror # 设置源存储库的镜像 -o &lt;name&gt;, --origin &lt;name&gt; # 不要使用远程名称origin来跟踪上游存储库，请使用&lt;name&gt; -b &lt;name&gt;, --branch &lt;name&gt; # 而不是将新创建的HEAD指向克隆存储库HEAD指向的&lt;name&gt;分支，而是指向分支在非裸仓库中, 这是将被检出的分支。 --branch也可以在生成的存储库中提交标签并分离HEAD -u &lt;upload-pack&gt;, --upload-pack &lt;upload-pack&gt; # 当给定时, 通过ssh访问要克隆的存储库, 这将为另一端运行的命令指定非默认路径 --template&#x3D;&lt;template_directory&gt; # 指定将使用模板的目录 -c &lt;key&gt;&#x3D;&lt;value&gt;, --config &lt;key&gt;&#x3D;&lt;value&gt; # 在新创建的存储库中设置配置变量 --depth &lt;depth&gt; # 创建一个历史截断为指定数目的提交的浅表副本 --shallow-since&#x3D;&lt;date&gt; # 在指定时间后创建一个具有历史记录的浅表克隆 --shallow-exclude&#x3D;&lt;revision&gt; # 创建有历史记录的浅层克隆, 但不包括从指定远程分支或标记可访问的提交 --[no-]single-branch # 只克隆导致单个分支尖端的历史记录, 无论--branch选项指定还是主分支远程的HEAD指向 --no-tags # 不要克隆任何标签, 并remote.&lt;remote&gt;.tagOpt&#x3D;--no-tags在配置中设置, 确保将来git pull和git fetch操作不会跟随任何标签 --recurse-submodules[&#x3D;&lt;pathspec] # 创建克隆后, 根据pathspec初始化和克隆子模块。如未提供pathspec, 则初始化并克隆所有子模块 --[no-]shallow-submodules # 所克隆的所有子模块将会变浅, 深度为1 --separate-git-dir&#x3D;&lt;git dir&gt; # 不要将克隆的存储库放置在它应该存在的位置, 而应将克隆的存储库放置在指定的目录中,然后创建一个与文件系统无关的Git符号链接。结果是Git仓库可以从工作树中分离出来 -j &lt;n&gt;, --jobs &lt;n&gt; # 同时获取的子模块的数量。默认为submodule.fetchJobs选项 &lt;repository&gt; # 从中克隆的存储库 &lt;directory&gt; # 要克隆到的新目录的名称add 命令12345678910111213141516171819202122232425语法： git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p] [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize] [--chmod&#x3D;(+|-)x] [--] [&lt;pathspec&gt;…​]选项： -v, --verbose # 详细 -n, --dry-run # 不要实际添加文件, 只显示它们是否存在和&#x2F;或将被忽略 -f, --force # 允许添加被忽略的文件 -i, --interactive # 在工作树中交互添加修改的内容到索引 -p, --patch # 在索引和工作树之间交互地选择补丁块, 并将它们添加到索引中 -e, --edit # 在编辑器中打开差异与索引并让用户编辑它。编辑器关闭后, 调整大块头并将补丁应用到索引 -u, --update # 更新已存在匹配&lt;pathspec&gt;条目的索引。这会删除和修改索引条目以匹配工作树, 但不会添加新文件 -A, --all, --no-ignore-removal # 更新索引不仅在工作树具有匹配&lt;pathspec&gt;的文件的位置, 而且索引已经有条目的位置这会添加，修改和删除索引条目以匹配工作树 --no-all, --ignore-removal # 通过添加索引未知的新文件和工作树中修改的文件来更新索引, 但忽略已从工作树中删除的文件当没有使用&lt;pathspec&gt;时，该选项是无操作的 -N, --intent-to-add # 只记录路径将在稍后添加的事实。路径条目放置在没有内容的索引中 --refresh # 不要添加文件，而只需刷新索引中的stat()信息 --ignore-errors # 如果某些文件因索引错误而无法添加, 请不要中止操作，而是继续添加其他文件 --ignore-missing # 该选项只能与--dry-run一起使用。用户可检查是否有给定的文件被忽略, 不管是否已存在于工作树中 --no-warn-embedded-repo # 默认情况下, git add向嵌入式存储库添加索引时会发出警告, 而不用git submodule add其中创建条目.gitmodules。该选项将会禁止警告 --renormalize # 将新鲜的&quot;干净&quot;过程应用于所有跟踪的文件, 以强制将其再次添加到索引 --chmod&#x3D;(+|-)x # 覆盖添加文件的可执行位。可执行位仅在索引中更改, 磁盘上的文件保持不变。 -- # 此选项可用于将命令行选项与文件列表分开 &lt;pathspec&gt;… # 要从中添加内容的文件。*.c可以给Fileglobs（例如）添加所有匹配的文件status 命令1234567891011121314151617181920语法： git status [&lt;options&gt;…​] [--] [&lt;pathspec&gt;…​]选项： -s, --short # 以短格式输出输出 -b, --branch # 甚至以短格式显示分支和跟踪信息 --show-stash # 显示当前隐藏的条目数量 --porcelain[&#x3D;&lt;version&gt;] # 为脚本提供易于解析的格式输出 --long # 以长格式输出输出, 默认 -v, --verbose # 除了已更改的文件名称之外, 还会显示正在执行的文本更改 -u[&lt;mode&gt;], --untracked-files[&#x3D;&lt;mode&gt;] # 显示未跟踪的文件 --ignore-submodules[&#x3D;&lt;when&gt;] # 查找更改时忽略对子模块的更改。&lt;when&gt;可以是&quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot;或&quot;all&quot;, 这是默认设置 --ignored[&#x3D;&lt;mode&gt;] # 也显示忽略的文件。mode参数用于指定忽略文件的处理, 可选的, 默认为传统 traditional # 传统, 显示被忽略的文件和目录, 除非指定--untracked-files &#x3D; all，这种情况下将显示忽略目录中的单个文件 no # 否, 不显示任何被忽略的文件 matching # 匹配, 显示与忽略模式匹配的忽略文件和目录 -z # 用NUL而不是LF终止输入 --no-column, --column[&#x3D;&lt;options&gt;] # 在列中显示未跟踪的文件 --ahead-behind, --no-ahead-behind # 显示或不显示分支相对于其上游分支的详细前&#x2F;后计数。默认为true &lt;pathspec&gt;…​ #diff 命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788语法： git diff [options] [&lt;commit&gt;] [--] [&lt;path&gt;…​] git diff [options] --cached [&lt;commit&gt;] [--] [&lt;path&gt;…​] git diff [options] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…​] git diff [options] &lt;blob&gt; &lt;blob&gt; git diff [options] [--no-index] [--] &lt;path&gt; &lt;path&gt;选项： -p, -u, --patch # 生成补丁, 这是默认设置 -s, --no-patch # 抑制差异输出。对于像git show这样的命令很有用，默认显示补丁，或取消效果--patch -U&lt;n&gt;, --unified&#x3D;&lt;n&gt; # 使用&lt;n&gt;行上下文生成差异，而不是通常的三行。意味着-p --raw # 以原始格式生成差异 --patch-with-raw # 原始的同义词-p --raw --indent-heuristic, --no-indent-heuristic # 为了帮助调试和调整实验启发式, 改变差异边界以使修补程序更易于阅读, 默认关闭 --minimal # 花费额外的时间来确保生成最小可能的差异 --patience # 使用&quot;耐心差异&quot;算法生成差异 --histogram # 使用&quot;直方图差异&quot;算法生成差异 --diff-algorithm&#x3D;&#123;patience|minimal|histogram|myers&#125; # 选择一种差异算法 default, myers # 基本的贪婪diff算法, 默认设置 minimal # 花费额外的时间来确保生成最小可能的差异 patience # 生成补丁时使用&quot;耐心差异&quot;算法 histogram # 该算法将耐心算法扩展为&quot;支持低出现率的通用元素&quot; --stat[&#x3D;&lt;width&gt;[,&lt;name-width&gt;[,&lt;count&gt;]]] # 生成一个diffstat --numstat # 类似--stat，但显示十进制表示法中添加和删除的行数以及不带缩写的路径名。 对于二进制文件，输出两个-而不是说 0 0 --shortstat # 只输出--stat包含修改文件总数的格式的最后一行, 以及添加和删除行的数量 --dirstat[&#x3D;&lt;param1,param2,…​&gt;] # 输出每个子目录的相对变化量分布。--dirstat可以通过传递逗号分隔的参数列表来定制行为 changes # 通过计算已从源中删除或添加到目标的行来计算dirstat数字 lines # 通过执行常规基于行的差异分析来计算dirstat数字，并将删除&#x2F;添加的行数相加 files # 通过计算更改的文件数量来计算dirstat数字 cumulative # 计数父目录的子目录中的更改 &lt;limit&gt; # 整数参数指定截断百分比（默认为3％）。输出中不显示贡献小于此百分比的目录 --summary # 输出扩展头信息的精简摘要，如创建，重命名和模式更改 --patch-with-stat # 同义词- p - stat -z # 当--raw，--numstat，--name-only或--name-status已给出，不Munge时间路径名，并使用完全无效的输出字段终止符 --name-only # 仅显示已更改文件的名称 --name-status # 仅显示已更改文件的名称和状态 --submodule[&#x3D;&lt;format&gt;] # 指定如何显示子模块中的差异 --color[&#x3D;&lt;when&gt;] # 显示有色差异 --no-color # 关闭有色差异 --word-diff[&#x3D;&lt;mode&gt;] # 显示一个单词diff，使用&lt;mode&gt;分隔已更改的单词。默认: 空格分隔 color # 仅使用颜色突出显示更改的词 plain # 将单词显示为[-removed-]和&#123;+added+&#125;。如果输入中出现分隔符，则不会尝试跳过分隔符，因此输出可能不明确 porcelain # 使用专门用于脚本消费的基于行的格式 none # 再次禁用字差异 --word-diff-regex&#x3D;&lt;regex&gt; # 使用&lt;regex&gt;来决定一个单词是什么，而不是将非空白的运行视为一个单词 --color-words[&#x3D;&lt;regex&gt;] # 相当于--word-diff&#x3D;color加号 --no-renames # 关闭重命名检测，即使配置文件提供了默认设置 --check # 警告如果更改引入冲突标记或空白错误。认为空白错误由core.whitespace 配置控制。 --ws-error-highlight&#x3D;&lt;kind&gt; # 按&lt;颜色&gt;指定的颜色突出显示由&lt;颜色&gt;指定的行上的空白错误color.diff.whitespace --full-index # 在生成补丁格式输出时，在“索引”行上显示完整的映像前和映像后blob对象名称，而不是第一批字符 --binary # 除了--full-index输出可以应用的二进制差异git-apply --abbrev[&#x3D;&lt;n&gt;] # 不是在diff-raw格式输出和diff-tree标题行中显示完整的40字节十六进制对象名称，只显示部分前缀 -B[&lt;n&gt;][&#x2F;&lt;m&gt;], --break-rewrites[&#x3D;[&lt;n&gt;][&#x2F;&lt;m&gt;]] # 将完全重写更改分解为删除和创建对 -M[&lt;n&gt;], --find-renames[&#x3D;&lt;n&gt;] # 检测重命名 -C[&lt;n&gt;], --find-copies[&#x3D;&lt;n&gt;] # 检测副本以及重命名 --find-copies-harder # 出于性能原因，默认情况下，-C只有当副本的原始文件在相同的变更集中被修改时，选项才会查找副本 -D, --irreversible-delete # 省略原图像进行删除，即仅打印标题，但不打印原像和之间的差异&#x2F;dev&#x2F;null -l&lt;num&gt; # 在-M和-C选项需要为O（n ^ 2）的处理时间，其中n是&#x2F;复制目标潜在的重命名的数目如果重命名&#x2F;复制目标的数量超过指定的数量，则此选项可防止重命名&#x2F;复制检测运行 --diff-filter&#x3D;[(A|C|D|M|R|T|U|X|B)…​[*]] # 选择仅添加(A), 复制(C), 删除(D), 修改(M), 重命名(R), 其类型(即常规文件, 符号链接, 子模块, ...)更改(T), Unmerged(U), 未知(X)或已配对Broken(B) 可以使用任何过滤字符的组合(包括无)当*（全部或无）添加到组合中时，如果有任何文件与比较中的其他条件匹配，则选择所有路径; 如果没有与其他标准匹配的文件，则不会选择任何内容 -S&lt;string&gt; # 查找改变文件中指定字符串出现次数（即添加&#x2F;删除）的差异 -G&lt;regex&gt; # 寻找补丁文本包含与&lt;regex&gt;匹配的添加&#x2F;删除行的差异 --pickaxe-all # 当-S或-G发现更改时，显示该更改集中的所有更改，而不仅仅是包含&lt;string&gt;中的更改的文件 --pickaxe-regex # 将给定的&lt;string&gt; -S视为扩展的POSIX正则表达式进行匹配 -O&lt;orderfile&gt; # 控制文件在输出中出现的顺序 -R # 交换两个输入; 即显示索引或磁盘文件与树内容的差异 --relative[&#x3D;&lt;path&gt;] # 从项目的子目录运行时，可以通过此选项告知排除目录外的更改并显示与其相关的路径名 -a, --text # 将所有文件视为文本 --ignore-space-at-eol # 忽略EOL中的空白变化 -b, --ignore-space-change # 忽略空白量的变化。这会忽略行结束处的空白，并认为一个或多个空白字符的所有其他序列是等价的 -w, --ignore-all-space # 比较行时忽略空格。即使一行有空白，而另一行没有空白，这也会忽略差异 --ignore-blank-lines # 忽略其行全部空白的更改 --inter-hunk-context&#x3D;&lt;lines&gt; # 显示差异hunk之间的上下文，直到指定的行数，从而融合彼此接近的hunk -W, --function-context # 显示整个周围的变化功能 --exit-code # 用类似于diff（1）的代码退出程序。也就是说，如果存在差异，则1退出，0表示没有差异 --quiet # 禁用程序的所有输出。意味着--exit-code --ext-diff # 允许执行一个外部比较助手 --no-ext-diff # 禁止外部差异驱动程序 --textconv, --no-textconv # 在比较二进制文件时，允许（或不允许）运行外部文本转换过滤器 --ignore-submodules[&#x3D;&lt;when&gt;] # 忽略差异代中子模块的更改。&lt;when&gt;可以是“none”，“untracked”，“dirty”或“all”，这是默认设置 --src-prefix&#x3D;&lt;prefix&gt; # 显示给定的源前缀而不是“a &#x2F;” --dst-prefix&#x3D;&lt;prefix&gt; # 显示给定的目的地前缀而不是“b &#x2F;” --no-prefix # 不要显示任何来源或目的地前缀 --line-prefix&#x3D;&lt;prefix&gt; # 为每行输出预留一个额外的前缀 --ita-invisible-in-index # 默认情况下，由“git add -N”添加的条目显示为“git diff”中的现有空文件和“git diff --cached”中的新文件 -1 --base, -2 --ours, -3 --theirs # 比较工作树与“基本”版本（阶段＃1），“我们的分支”（阶段＃2）或“他们的分支”（阶段＃3） -0 # 忽略差异输出未合并的条目并只显示“未合并”。仅在将工作树与索引进行比较时才能使用 &lt;path&gt;…​ # 给出的&lt;paths&gt;参数用于将diff限制为指定的路径commit 命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253语法： git commit [-a | --interactive | --patch] [-s] [-v] [-u&lt;mode&gt;] [--amend] [--dry-run] [(-c | -C | --fixup | --squash) &lt;commit&gt;] [-F &lt;file&gt; | -m &lt;msg&gt;] [--reset-author] [--allow-empty] [--allow-empty-message] [--no-verify] [-e] [--author&#x3D;&lt;author&gt;] [--date&#x3D;&lt;date&gt;] [--cleanup&#x3D;&lt;mode&gt;] [--[no-]status] [-i | -o] [-S[&lt;keyid&gt;]] [--] [&lt;file&gt;…​]选项： -a, --all # 告诉命令自动对已被修改和删除的文件进行分段处理，但没有告知Git的新文件不受影响 -p, --patch # 使用交互式补丁选择界面来选择要提交的更改 -C &lt;commit&gt;, --reuse-message&#x3D;&lt;commit&gt; # 取一个现有的提交对象，并在创建提交时重用日志消息和作者信息（包括时间戳） -c &lt;commit&gt;, --reedit-message&#x3D;&lt;commit&gt; # 像-C一样，但-c调用了编辑器，以便用户可以进一步编辑提交消息 --fixup&#x3D;&lt;commit&gt; # 构建一个提交消息以供使用rebase --autosquash。提交消息将成为指定提交的主题行，其前缀为“fixup！” --squash&#x3D;&lt;commit&gt; # 构建一个提交消息以供使用rebase --autosquash。提交消息主题行取自指定的提交，前缀为“squash！” --reset-author # 当与-C &#x2F; -c &#x2F; - 修改选项一起使用时，或者在冲突樱桃挑选后提交时，声明结果提交的作者现在属于提交者 --short # 进行干运行时，请以短格式输出 --branch # 甚至以短格式显示分支和跟踪信息 --porcelain # 进行干式运行时，请将输出信号以瓷器准备好的格式输出 --long # 进行干式运行时，请以长格式输出 -z, --null # 显示short或porcelain状态输出时，逐字打印文件名并用NUL而不是LF结束输入。如果没有给出格式，则表示--porcelain输出格式 -F &lt;file&gt;, --file&#x3D;&lt;file&gt; # 从给定的文件中获取提交消息。使用-从标准输入中读取消息 --author&#x3D;&lt;author&gt; # 覆盖提交作者。使用标准A U Thor &lt;author@example.com&gt;格式指定明确的作者 --date&#x3D;&lt;date&gt; # 覆盖提交中使用的作者日期 -m &lt;msg&gt;, --message&#x3D;&lt;msg&gt; # 使用给定的&lt;msg&gt;作为提交消息 -t &lt;file&gt;, --template&#x3D;&lt;file&gt; # 编辑提交消息时，使用给定文件中的内容启动编辑器 -s, --signoff # 提交日志消息结尾处的提交者添加Signed-off-by行 -n, --no-verify # 该选项绕过预先提交和提交msg钩子 --allow-empty # 通常记录具有与其唯一父提交完全相同的树的提交是个错误，并且该命令阻止您提交此类提交 --allow-empty-message # 像--allow-empty这个命令主要供外国SCM接口脚本使用。它允许你使用空的提交消息创建一个提交，而不使用像git-commit-tree [1]命令 --cleanup&#x3D;&lt;mode&gt; # 这个选项决定了在提交之前应该如何清理提供的提交消息。所述&lt;模式&gt;可以是strip， whitespace，verbatim，scissors或default strip # 删除前导和尾随空行，尾随空白，评论和折叠连续的空行 whitespace # 同strip除#commentary不会被删除 verbatim # 根本不要改变信息 scissors # 相同whitespace，除了一切从（并包括）下面找到的行被截短，如果消息是要被编辑 default # 就strip好像要编辑的消息一样。否则whitespace -e, --edit # 从文件提取的消息-F，命令行 -m和从提交对象中取出的消息-C通常用作未修改的提交日志消息 --no-edit # 使用选定的提交消息而不启动编辑器。例如，git commit --amend --no-edit修改提交而不更改其提交消息 --amend # 通过创建一个新的提交来替换当前分支的提示 --no-post-rewrite # 绕过重写挂钩 -i, --include # 在到目前为止的阶段性内容提交之前，请在命令行上指定路径的内容。这通常不是你想要的，除非你正在完成一个冲突的合并。 -o, --only # 通过获取命令行中指定路径的更新工作树内容来进行提交，而忽略已为其他路径执行的任何内容 -u[&lt;mode&gt;], --untracked-files[&#x3D;&lt;mode&gt;] # 显示未跟踪的文件。模式可选的(默认为全部), 并用于指定未跟踪文件的处理; 当-u未被使用时，默认是正常的，即显示未跟踪的文件和目录。所述&lt;模式&gt;可以是no， normal，all -v, --verbose # 显示HEAD提交与提交消息模板底部提交的内容之间的统一差异，以帮助用户通过提醒提交具有哪些更改来描述提交 -q, --quiet # 禁止提交摘要消息 --dry-run # 不要创建提交,而是显示要提交的路径列表,包含将保留未提交的本地更改的路径以及未跟踪的路径 --status # 使用编辑器准备提交消息时，在提交消息模板中包含git-status [1]的输出。默认为打开，但可用于覆盖配置变量commit.status。 --no-status # 使用编辑器准备默认提交消息时，不要在提交消息模板中包含git-status [1]的输出。 -S[&lt;keyid&gt;], --gpg-sign[&#x3D;&lt;keyid&gt;] # GPG标志提交。该keyid参数是可选的，并且默认为提交者身份 --no-gpg-sign # commit.gpgSign设置为强制每个提交进行签名的计数器配置变量 -- # 不要将更多的参数解释为选项 &lt;file&gt;…​ # 当在命令行上给出文件时，该命令将提交指定文件的内容，而不记录已经执行的更改reset 命令123456789101112语法： git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​ git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​] git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;]选项： -q, --quiet # 保持安静，只报告错误 --soft # 根本不触摸索引文件或工作树（但将头重置为&lt;commit&gt;，就像所有模式一样） --mixed # 重置索引而不是工作树（即，保存更改的文件但未标记为提交）并报告尚未更新的内容。这是默认操作 --hard # 重置索引和工作树。放弃自&lt;commit&gt;以来对工作树中跟踪文件所做的任何更改 --merge # 重置索引并更新工作树中&lt;commit&gt;和HEAD之间不同的文件，但保留索引和工作树之间不同的文件（即没有添加更改的文件）如果&lt;commit&gt;和索引之间的文件有不同的变化，则重置会中止 --keep # 重置索引条目并更新工作树中&lt;commit&gt;和HEAD之间不同的文件。如果&lt;commit&gt;和HEAD之间的文件有本地更改，则重置会中止rm 命令123456789101112语法： git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch] [--quiet] [--] &lt;file&gt;…​选项： &lt;file&gt;…​ # 要删除的文件 -f, --force # 覆盖最新的检查 -n, --dry-run # 切勿删除任何文件。相反，只需显示它们是否存在于索引中，否则将被命令删除 -r # 当给出主目录名时允许递归删除 -- # 此选项可用于将命令行选项与文件列表分开，（当文件名可能被误认为是命令行选项时很有用） --cached # 使用此选项可以取消仅从索引中删除路径的情况。工作树文件，无论是否修改，都将被单独保留 --ignore-unmatch # 即使没有匹配的文件，也可以用零状态退出 -q, --quiet # 该选项禁止输出mv 命令12345678语法： git mv &lt;options&gt;…​ &lt;args&gt;…​选项： -f, --force # 即使目标存在，也要强制重命名或移动文件 -k # 跳过移动或重命名会导致错误情况的操作 -n, --dry-run # 没做什么; 只显示会发生什么 -v, --verbose # 报告移动文件的名称branch 命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152语法： git branch [--color[&#x3D;&lt;when&gt;] | --no-color] [-r | -a] [--list] [-v [--abbrev&#x3D;&lt;length&gt; | --no-abbrev]] [--column[&#x3D;&lt;options&gt;] | --no-column] [--sort&#x3D;&lt;key&gt;] [(--merged | --no-merged) [&lt;commit&gt;]] [--contains [&lt;commit]] [--no-contains [&lt;commit&gt;]] [--points-at &lt;object&gt;] [--format&#x3D;&lt;format&gt;] [&lt;pattern&gt;…​] git branch [--track | --no-track] [-l] [-f] &lt;branchname&gt; [&lt;start-point&gt;] git branch (--set-upstream-to&#x3D;&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;] git branch --unset-upstream [&lt;branchname&gt;] git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt; git branch (-c | -C) [&lt;oldbranch&gt;] &lt;newbranch&gt; git branch (-d | -D) [-r] &lt;branchname&gt;…​ git branch --edit-description [&lt;branchname&gt;]选项： -d, --delete # 删除分支 -D # 快捷键--delete --force -l, --create-reflog # 创建分支的reflog -f, --force # 将&lt;branchname&gt;重置为&lt;startpoint&gt;，即使&lt;branchname&gt;已存在 -m, --move # 移动&#x2F;重命名分支和相应的reflog -M # 快捷键--move --force -c, --copy # 复制分支和相应的reflog -C # 快捷键--copy --force --color[&#x3D;&lt;when&gt;] # 颜色分支突出显示当前，本地和远程跟踪分支。该值必须始终（默认），永不，或自动 --no-color # 关闭分支颜色，即使配置文件将默认设置为颜色输出。和...一样--color&#x3D;never -i, --ignore-case # 排序和过滤分支不区分大小写 --column[&#x3D;&lt;options&gt;], --no-column # 在列中显示分支列表 -r, --remotes # 列出或删除（如果与-d一起使用）远程跟踪分支 -a, --all # 列出远程追踪分行和当地分行 --list # 列出分支 -v, -vv, --verbose # 在列表模式下，显示sha1并为每个头提交主题行，以及与上游分支（如果有）的关系 -q, --quiet # 创建或删除分支时更安静，抑制非错误消息 --abbrev&#x3D;&lt;length&gt; # 改变输出列表中sha1的最小显示长度。默认值是7 --no-abbrev # 在输出列表中显示完整的sha1，而不是缩写它们 -t, --track # 创建新分支时，设置branch.&lt;name&gt;.remote和 branch.&lt;name&gt;.merge配置条目以将起点分支标记为新分支的“上游” --no-track # 即使branch.autoSetupMerge配置变量为true，也不要设置“上游”配置 --set-upstream # 由于此选项具有混淆语法，因此不再支持。请使用--track或--set-upstream-to替代 -u &lt;upstream&gt;, --set-upstream-to&#x3D;&lt;upstream&gt; # 设置&lt;branchname&gt;的跟踪信息，以便&lt;upstream&gt;被视为&lt;branchname&gt;的上游分支。如果未指定&lt;branchname&gt;，则默认为当前分支。 --unset-upstream # 删除&lt;branchname&gt;的上游信息。如果未指定分支，则默认为当前分支 --edit-description # 打开一个编辑器，编辑文本解释分支是干什么用的，通过其他各种命令使用（例如format-patch， request-pull和merge（如果启用）） --contains [&lt;commit&gt;] # 只列出包含指定提交的分支（如果未指定，则为HEAD）。意味着--list --no-contains [&lt;commit&gt;] # 只列出不包含指定提交的分支（如果未指定，则为HEAD）。意味着--list --merged [&lt;commit&gt;] # 仅列出可从指定提交中获得提示的分支（如果未指定，则为HEAD）。暗示--list，不符合--no-merged --no-merged [&lt;commit&gt;] # 只列出提示无法从指定提交中获得的分支（如果未指定，则为HEAD）。暗示--list，不符合--merged &lt;branchname&gt; # 要创建或删除的分支的名称 &lt;start-point&gt; # 新的分支头将指向这个提交 &lt;oldbranch&gt; # 要重命名的现有分支的名称 &lt;newbranch&gt; # 现有分支的新名称 --sort&#x3D;&lt;key&gt; # 根据给定的关键字进行排序 --points-at &lt;object&gt; # 只列出给定对象的分支 --format &lt;format&gt; # 从显示的分支ref 中插入的字符串以及它指向的对象。格式与git-for-each-ref [1]的格式相同checkout 命令12345678910111213141516171819202122232425262728293031语法： git checkout [-q] [-f] [-m] [&lt;branch&gt;] git checkout [-q] [-f] [-m] --detach [&lt;branch&gt;] git checkout [-q] [-f] [-m] [--detach] &lt;commit&gt; git checkout [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;] git checkout [-f|--ours|--theirs|-m|--conflict&#x3D;&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​ git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​ git checkout (-p|--patch) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​]选项： -q, --quiet # 抑制反馈信息 --[no-]progress # 除非--quiet 已指定，否则标准错误流默认情况下会将其连接到终端时报告进度状态 -f, --force # 切换分支时，即使索引或工作树与HEAD不同，也要继续。这用于丢弃本地更改 --ours, --theirs # 当从索引中检出路径时，请检查第2阶段(ours)或第3阶段(theirs)是否有未合并的路径 -b &lt;new_branch&gt; # 创建一个名为&lt;new_branch&gt;的新分支并在&lt;start_point&gt;处启动它 -B &lt;new_branch&gt; # 创建分支&lt;new_branch&gt;并在&lt;start_point&gt;处启动它 -t, --track # 创建新分支时，设置“上游”配置 --no-track # 即使branch.autoSetupMerge配置变量为true，也不要设置“上游”配置 -l # 创建新分支的reflog --detach # 而不是检查一个分支来处理它，检查提交检查和可废弃的实验 --orphan &lt;new_branch&gt; # 创建一个名为&lt;new_branch&gt; 的新孤立分支，从&lt;start_point&gt;开始并切换到该分支 --ignore-skip-worktree-bits # 在稀疏结帐模式下，git checkout -- &lt;paths&gt;只会更新$GIT_DIR&#x2F;info&#x2F;sparse-checkout中由&lt;路径&gt;和稀疏模式匹配的条目 -m, --merge # 在切换分支时，如果对当前分支与切换到的分支之间的一个或多个文件进行本地修改，则该命令将拒绝切换分支以便在上下文中保留修改 --conflict&#x3D;&lt;style&gt; # 与上面的--merge选项相同，但改变了冲突的区块显示方式，覆盖merge.conflictStyle配置变量 -p, --patch # 在&lt;tree-ish&gt;（或索引，如果未指定）和工作树之间的区别中交互地选择hunk。然后将选定的区块反向应用于工作树（并且如果指定了&lt;tree-ish&gt;，则索引） --ignore-other-worktrees # git checkout当被通缉的裁判已经被另一个工作树签出时拒绝。这个选项使它无论如何检查裁判 --[no-]recurse-submodules # 使用--recurse子模块将根据超级项目中记录的提交更新所有已初始化的子模块的内容 &lt;branch&gt; # 分支, 如果它引用了一个分支（即，前缀为“refs&#x2F;heads&#x2F;”的名称是有效的ref），那么该分支将被签出 &lt;new_branch&gt; # 新分支的名称 &lt;start_point&gt; # 要开始新分支的提交的名称 &lt;tree-ish&gt; # 要检出的树（当有路径时）。如果未指定，则会使用索引merge 命令123456789101112131415161718192021222324252627282930313233语法： git merge [-n] [--stat] [--no-commit] [--squash] [--[no-]edit] [-s &lt;strategy&gt;] [-X &lt;strategy-option&gt;] [-S[&lt;keyid&gt;]] [--[no-]allow-unrelated-histories] [--[no-]rerere-autoupdate] [-m &lt;msg&gt;] [&lt;commit&gt;…​] git merge --abort git merge --continue选项： --commit, --no-commit # 执行合并并提交结果。这个选项可以用来覆盖--no-commit -e, --edit, --no-edit # 在提交成功的机械合并之前调用编辑器来进一步编辑自动生成的合并消息，以便用户可以解释并验证合并 --ff # 当合并解析为快进时，只更新分支指针，而不创建合并提交。这是默认行为 --no-ff # 即使合并解析为快进，也可以创建合并提交。这是合并注释标记时的默认行为 --ff-only # 拒绝合并并以非零状态退出，除非当前HEAD已更新或合并可以解决为快进 -S[&lt;keyid&gt;], --gpg-sign[&#x3D;&lt;keyid&gt;] # GPG-签署合并提交 --log[&#x3D;&lt;n&gt;], --no-log # 除了分支名称之外，还可以用来自至多&lt;n&gt;实际提交的单行描述来填充日志消息 --signoff, --no-signoff # 提交日志消息结尾处的提交者添加Signed-off-by行 --stat, -n, --no-stat # 在合并结束时显示diffstat。diffstat也由配置选项merge.stat控制 --squash, --no-squash # 生成工作树和索引状态，就像发生真正的合并一样，但实际上并未进行提交，移动HEAD或记录$GIT_DIR&#x2F;MERGE_HEAD -s &lt;strategy&gt;, --strategy&#x3D;&lt;strategy&gt; # 使用给定的合并策略; 可以多次提供，以按照他们应该尝试的顺序指定它们 -X &lt;option&gt;, --strategy-option&#x3D;&lt;option&gt; # 将合并策略特定选项传递给合并策略 --verify-signatures, --no-verify-signatures # 验证被合并的分支的提示提交是否使用有效密钥进行签名，即具有有效uid的密钥：在默认信任模型中， 这意味着签名密钥已由可信密钥签名。如果侧分支的提示提交未使用有效密钥进行签名，则会中止合并 --summary, --no-summary # 同义词--stat和--no-stat; 这些已被弃用，并将在未来被删除 -q, --quiet # 安静地操作。意味着 - 没有进步 -v, --verbose # 详细 --progress, --no-progress # 明确地打开&#x2F;关闭进度。如果没有指定，如果标准错误连接到终端，则显示进度 --allow-unrelated-histories # 默认情况下，git merge命令拒绝合并不共享祖先的历史记录 -m &lt;msg&gt; # 设置要用于合并提交的提交消息（以防创建） --[no-]rerere-autoupdate # 如果可能的话，允许rerere机制用自动冲突解决的结果更新索引 --abort # 中止当前的冲突解决过程，并尝试重新构建预合并状态 --continue # 经过git的合并，由于停止冲突，那么可以得出结论：通过运行合并混帐合并--continue &lt;commit&gt;…​ # 提交, 通常其他分支, 合并到我们的分支mergetool 命令123456789语法： git mergetool [--tool&#x3D;&lt;tool&gt;] [-y | --[no-]prompt] [&lt;file&gt;…​] 选项： -t &lt;tool&gt;, --tool&#x3D;&lt;tool&gt; # 使用&lt;tool&gt;指定的合并解析程序。有效值包括emerge，gvimdiff，kdiff3，meld，vimdiff和tortoisemerge。 运行git mergetool --tool-help 有效的&lt;工具&gt;设置列表 --tool-help # 打印可能使用的合并工具列表--tool -y, --no-prompt # 在每次调用合并解析程序之前不要提示。如果通过--tool或 merge.tool配置变量显式指定合并解析程序(默认值) --prompt # 在每次调用合并解决方案之前提示，以使用户有机会跳过该路径 -O&lt;orderfile&gt; # 按照&lt;orderfile&gt;中指定的顺序处理文件，每行有一个shell glob模式log 命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103语法： git log [&lt;options&gt;] [&lt;revision range&gt;] [[\\--] &lt;path&gt;…​] 选项： --follow # 继续列出除重命名之外的文件历史记录（仅适用于单个文件） --no-decorate, --decorate[&#x3D;short|full|auto|no] # 打印出任何提交的ref名称 --decorate-refs&#x3D;&lt;pattern&gt;, --decorate-refs-exclude&#x3D;&lt;pattern&gt; # 如果没有--decorate-refs给出，假装所有参考文献都包含在内 --source # 打印在每个提交到达的命令行上给出的ref名称 --use-mailmap # 使用邮件地图文件将作者和提交者姓名和电子邮件地址映射到规范的实名和电子邮件地址 --full-diff # 没有此标志，git log -p &lt;path&gt;...显示提交触摸指定的路径，并且差异关于相同指定的路径 --log-size # 在每个提交的输出中包含一行“log size &lt;number&gt;”，其中&lt;number&gt;是该提交消息的长度（以字节为单位） -L &lt;start&gt;,&lt;end&gt;:&lt;file&gt;, -L :&lt;funcname&gt;:&lt;file&gt; # 跟踪&lt;file&gt;中由“&lt;start&gt;，&lt;end&gt;”（或函数名称regex &lt;funcname&gt;）给出的行范围的演变 &lt;revision range&gt; # 仅显示指定修订范围内的提交 [\\--] &lt;path&gt;…​ # 仅显示足以解释如何匹配指定路径的文件的提交 提交限制： -&lt;number&gt;, -n &lt;number&gt;, --max-count&#x3D;&lt;number&gt; # 限制提交输出的数量 --skip&#x3D;&lt;number&gt; # 在开始显示提交输出之前跳过数字提交 --since&#x3D;&lt;date&gt;, --after&#x3D;&lt;date&gt; # 显示比特定日期更近的提交 --until&#x3D;&lt;date&gt;, --before&#x3D;&lt;date&gt; # 显示比特定日期更早的提交 --author&#x3D;&lt;pattern&gt;, --committer&#x3D;&lt;pattern&gt; # 将提交输出限制为与指定模式（正则表达式）匹配的作者&#x2F;提交者标题行 --grep-reflog&#x3D;&lt;pattern&gt; # 将提交输出限制为具有与指定模式（正则表达式）匹配的reflog条目的提交输出 --grep&#x3D;&lt;pattern&gt; # 将提交输出限制为符合指定模式（正则表达式）的日志消息 --all-match # 将提交输出限制为匹配所有给定的提交--grep，而不是至少匹配一个提交 --invert-grep # 将提交输出限制为与日志消息不匹配的模式--grep&#x3D;&lt;pattern&gt; -i, --regexp-ignore-case # 匹配正则表达式限制模式而不考虑字母大小写 --basic-regexp # 考虑限制模式是基本的正则表达式; 这是默认值 -E, --extended-regexp # 考虑限制模式是扩展正则表达式而不是默认的基本正则表达式 -F, --fixed-strings # 考虑限制模式为固定字符串（不要将模式解释为正则表达式） -P, --perl-regexp # 考虑限制模式是与Perl兼容的正则表达式 --remove-empty # 当给定的路径从树上消失时停止 --merges # 仅打印合并提交。这完全一样--min-parents&#x3D;2 --no-merges # 不要打印与多个父代的提交。这完全一样--max-parents&#x3D;1 --min-parents&#x3D;&lt;number&gt;, --max-parents&#x3D;&lt;number&gt; # 仅显示至少（或至多）多次父级提交的提交 --no-min-parents, --no-max-parents # --no-min-parents并--no-max-parents重新设置这些限制（无限制） --first-parent # 在查看合并提交后，只跟踪第一个父提交 --not # 反转的意思^前缀（或缺乏）的所有后续修订说明符，到下一个--not --all # 假设所有的参考文件refs&#x2F;，以及HEAD命令行都列为&lt;commit&gt; --branches[&#x3D;&lt;pattern&gt;] # 假设所有的参数refs&#x2F;heads都在命令行上列为&lt;commit&gt;。如果给定&lt;pattern&gt;，则将分支限制为与给定shell glob匹配的分支 --tags[&#x3D;&lt;pattern&gt;] # 假设所有的参数refs&#x2F;tags都在命令行上列为&lt;commit&gt;。如果给出&lt;pattern&gt;，则将标记限制为与给定shell glob相匹配的标记 --remotes[&#x3D;&lt;pattern&gt;] # 假设所有的参数refs&#x2F;remotes都在命令行上列为&lt;commit&gt;。如果给出&lt;pattern&gt;，则将远程跟踪分支限制为与给定shell glob匹配的分支 --glob&#x3D;&lt;glob-pattern&gt; # 假设所有与shell glob &lt;glob-pattern&gt;匹配的ref 在命令行中都以&lt;commit&gt;列出。前导refs &#x2F;，如果缺失，将自动添加前缀 --exclude&#x3D;&lt;glob-pattern&gt; # 不包括裁判匹配&lt;水珠图案&gt;，未来--all， --branches，--tags，--remotes，或--glob原本考虑 --reflog # 假设所有reflog提到的对象都在命令行中列为&lt;commit&gt; --single-worktree # 默认情况下，所有工作的树木将被下面的选项时，有一个以上--all，--reflog和 --indexed-objects。该选项强制他们仅检查当前工作树 --ignore-missing # 在输入中看到一个无效的对象名称时，假装没有给出错误的输入 --bisect # 假装好坏的二等分参考文献refs&#x2F;bisect&#x2F;bad 被列出，并且仿佛它被跟随，--not并且良好的平分参考refs&#x2F;bisect&#x2F;good-*命令行 --stdin # 除了命令行上列出的&lt;commit&gt;之外，还可以从标准输入中读取它们。如果--看到分隔符，请停止读取提交并开始读取路径以限制结果 --cherry-mark # 像--cherry-pick（见下面）但标记等价提交&#x3D;而不是省略它们，而不等价的提交+ --cherry-pick # 当提交集合受到对称差异限制时，省略任何提交引入与“另一侧”上的另一个提交相同的更改的提交 --left-only, --right-only # 列表仅在对称差异的相应侧提交，即只有那些将被标记&lt;为resp的列表。&gt;通过 --left-right --cherry # 的代名词--right-only --cherry-mark --no-merges; 有用的是将输出限制在我们这边的提交中，并将那些已经应用到 分叉历史的另一边的标记标记为 git log --cherry upstream...mybranch类似于 git cherry upstream mybranch -g, --walk-reflogs # 而不是走提交祖先链，将reflog条目从最近的一条走到更旧的条目 --merge # 合并失败后，显示引用文件有冲突并且不存在于所有合并头上 --boundary # 输出排除边界提交。边界提交以前缀- 历史简化： &lt;paths&gt; # 提交修改给定的&lt;路径&gt;被选中 --simplify-by-decoration # 由某个分支或标签引用的提交被选中 Default mode # 将历史简化为解释树的最终状态的最简单历史记录 --full-history # 与默认模式相同，但不修剪某些历史记录 --dense # 只显示选定的提交，另外一些提供有意义的历史记录 --sparse # 显示简化历史记录中的所有提交 --simplify-merges # 附加选项可--full-history从结果历史记录中删除一些不必要的合并，因为没有选定的提交对此合并作出贡献 --ancestry-path # 当给定一个范围提交的显示（例如commit1..commit2 或commit2 ^ commit1）， 只直接存在于之间的祖先链显示提交commit1和 commit2，即提交属于的两个后代commit1，和祖先commit2提交订单： --date-order # 在显示所有孩子之前不显示父母，但在提交时间戳顺序中显示提交 --author-date-order # 在显示所有孩子之前不显示父母，但以作者时间戳顺序显示提交 --topo-order # 在显示所有孩子之前不要显示父母，并且避免在多行历史记录中混合显示提交 --reverse # 以相反顺序输出选择显示的提交。不能与之结合 --walk-reflogs对象遍历： --no-walk[&#x3D;(sorted|unsorted)] # 只显示给定的提交，但不要遍历其祖先。如果指定了范围，则这不起作用。如果提供了参数 unsorted， 则提交按照它们在命令行上的顺序显示。否则（如sorted没有给参数），提交按提交时间以反向时间顺序显示。不能与之结合--graph --do-walk # 覆盖以前--no-walk提交格式： --pretty[&#x3D;&lt;format&gt;], --format&#x3D;&lt;format&gt; # 漂亮地打印在提交日志的内容在给定的格式，其中&lt;格式&gt;可以是一个ONELINE，短，中等，充分，更全面的，电子邮件，原料，格式：&lt;字符串&gt; 和tformat：&lt;字符串&gt; --abbrev-commit # 不显示完整的40字节十六进制提交对象名称，只显示部分前缀 --no-abbrev-commit # 显示完整的40字节十六进制提交对象名称。这种否定 --abbrev-commit和暗示它的选项如“--oneline” --oneline # 这是一起使用的“--pretty &#x3D; oneline --abbrev-commit”的缩写 --encoding&#x3D;&lt;encoding&gt; # 提交对象在其编码头中记录用于日志消息的编码; 这个选项可以用来告诉命令在用户首选的编码中重新编写提交日志消息 --expand-tabs&#x3D;&lt;n&gt;, --expand-tabs, --no-expand-tabs # 在输出中显示日志消息之前，执行一个选项卡扩展（将每个选项卡用足够的空格替换，以填充日志消息中的倍数为&lt;n&gt;的下一个显示列） --notes[&#x3D;&lt;treeish&gt;] # 在显示提交日志消息时，显示注释提交的注释 --no-notes # 不要显示笔记 --show-signature # 通过签名传递gpg --verify并显示输出来检查签名提交对象的有效性 --relative-date # 的同义词--date&#x3D;relative --date&#x3D;&lt;format&gt; # 仅对以人可读格式显示的日期生效，例如在使用时--pretty。log.dateconfig变量为log命令的--date选项设置一个默认值 --parents # 也打印提交的父母（以“commit parent ...”的形式） --children # 也打印提交的子代（以“commit child ...”的形式） --left-right # 标记可以从中提交提交的对称差异的哪一侧。来自左侧的提交将以前面的&lt;和前面的提交&gt;。如果合并--boundary，那些提交前缀为- --graph # 在输出的左侧绘制提交历史记录的基于文本的图形表示 --show-linear-break[&#x3D;&lt;barrier&gt;] # 当不使用--graph时，所有历史分支都会变平，这使得很难看到两个连续的提交不属于线性分支区分格式： -c # 使用此选项，合并提交的差异输出会同时显示每个父级与合并结果的差异，而不是显示父级与每次结果之间的pairwise差异 --cc # 这个标志意味着这个-c选项，并通过省略父母内容只有两个变体的无趣hunk来进一步压缩补丁输出，并且合并结果不加修改地选择其中的一个 -m # 这个标志使得合并提交显示了像常规提交一样的完整差异; 对于每个合并父项，会生成一个单独的日志条目和diff -r # 显示递归差异 -t # 在diff输出中显示树对象。这意味着-rstash 命令1234567891011121314151617181920212223242526语法： git stash list [&lt;options&gt;] git stash show [&lt;stash&gt;] git stash drop [-q|--quiet] [&lt;stash&gt;] git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;] git stash branch &lt;branchname&gt; [&lt;stash&gt;] git stash [push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet] [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;] [--] [&lt;pathspec&gt;…​]] git stash clear git stash create [&lt;message&gt;] git stash store [-m|--message &lt;message&gt;] [-q|--quiet] &lt;commit&gt;选项： push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet] [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;] [--] [&lt;pathspec&gt;…​] # 将您的本地修改保存到新的存储条目中，并将它们回滚到HEAD（在工作树和索引中） list [&lt;options&gt;] # 列出您当前拥有的存储条目 show [&lt;stash&gt;] # 显示存储条目中记录的更改，作为隐藏内容和提交首次创建存储条目时的提交之间的差异 pop [--index] [-q|--quiet] [&lt;stash&gt;] # 从存储列表中删除一个单独的存储状态并将其应用于当前工作树状态的顶部，即进行反操作git stash push。工作目录必须与索引匹配 apply [--index] [-q|--quiet] [&lt;stash&gt;] # 喜欢pop，但不要从存储列表中删除状态。不像pop， &lt;stash&gt;可能是任何看起来像由stash pushor 创建的提交 stash create branch &lt;branchname&gt; [&lt;stash&gt;] # 创建并检出&lt;branchname&gt;从&lt;stash&gt;最初创建的提交开始的新分支，将记录的更改应用&lt;stash&gt;到新的工作树和索引 clear # 删除所有的存储条目 drop [-q|--quiet] [&lt;stash&gt;] # 从存储条目列表中删除单个存储条目。如果没有&lt;stash&gt;给出，它将删除最新的一个 create # 创建一个存储条目（这是一个常规的提交对象）并返回它的对象名称，而不将它存储在ref命名空间的任何位置 store # 在存储引用中存储通过git stash create（这是一个悬挂的合并提交）创建的给定存储，更新存储引用日志tag 命令1234567891011121314151617181920212223242526272829303132333435语法： git tag [-a | -s | -u &lt;keyid&gt;] [-f] [-m &lt;msg&gt; | -F &lt;file&gt;] [-e] &lt;tagname&gt; [&lt;commit&gt; | &lt;object&gt;] git tag -d &lt;tagname&gt;…​ git tag [-n[&lt;num&gt;]] -l [--contains &lt;commit&gt;] [--no-contains &lt;commit&gt;] [--points-at &lt;object&gt;] [--column[&#x3D;&lt;options&gt;] | --no-column] [--create-reflog] [--sort&#x3D;&lt;key&gt;] [--format&#x3D;&lt;format&gt;] [--[no-]merged [&lt;commit&gt;]] [&lt;pattern&gt;…​] git tag -v [--format&#x3D;&lt;format&gt;] &lt;tagname&gt;…​选项： -a, --annotate # 制作一个未签名的带注释的标签对象 -s, --sign # 使用默认的电子邮件地址密钥创建一个GPG签名的标签 -u &lt;keyid&gt;, --local-user&#x3D;&lt;keyid&gt; # 使用给定的密钥创建一个GPG签名的标签 -f, --force # 用给定名称替换现有标签（而不是失败） -d, --delete # 用给定名称删除现有标签 -v, --verify # 验证给定标签名称的GPG签名 -n&lt;num&gt; # &lt;num&gt;指定在使用-l时打印多少行（如果有）。意味着--list -l, --list # 列表标签 --sort&#x3D;&lt;key&gt; # 根据给定的关键字进行排序。前缀-按值的降序进行排序 -i, --ignore-case # 排序和过滤标签不区分大小写 --column[&#x3D;&lt;options&gt;], --no-column # 在列中显示标签列表 --contains [&lt;commit&gt;] # 只列出包含指定提交的标签（如果未指定，则为HEAD）。意味着--list --no-contains [&lt;commit&gt;] # 只列出不包含指定提交的标签（如果未指定，则为HEAD）。意味着--list --merged [&lt;commit&gt;] # 仅列出可从提交的提交（HEAD如果未指定）可访问的列表标记，与之不兼容--no-merged --no-merged [&lt;commit&gt;] # 仅列出其提交无法从指定提交（HEAD如果未指定）到达的标记，与之不兼容--merged --points-at &lt;object&gt; # 只列出给定对象的标签（HEAD，如果未指定）。意味着--list -m &lt;msg&gt;, --message&#x3D;&lt;msg&gt; # 使用给定的标签消息（而不是提示） -F &lt;file&gt;, --file&#x3D;&lt;file&gt; # 从给定的文件中获取标签消息。使用-从标准输入中读取消息。 -e, --edit # 从带有-F和命令行的 文件中获取的消息-m通常用作未经修改的标记消息 --cleanup&#x3D;&lt;mode&gt; # 该选项设置标签消息的清理方式 --create-reflog # 为标签创建一个reflog &lt;tagname&gt; # 要创建，删除或描述的标记的名称 &lt;commit&gt;, &lt;object&gt; # 新标签将引用的对象，通常是提交。默认为HEAD &lt;format&gt; # %(fieldname)从显示的标记ref和指向的对象中插入一个字符串worktree 命令12345678910111213141516171819202122232425262728293031语法： git worktree add [-f] [--detach] [--checkout] [--lock] [-b &lt;new-branch&gt;] &lt;path&gt; [&lt;commit-ish&gt;] git worktree list [--porcelain] git worktree lock [--reason &lt;string&gt;] &lt;worktree&gt; git worktree move &lt;worktree&gt; &lt;new-path&gt; git worktree prune [-n] [-v] [--expire &lt;expire&gt;] git worktree remove [--force] &lt;worktree&gt; git worktree unlock &lt;worktree&gt;选项： add &lt;path&gt; [&lt;commit-ish&gt;] # 创建&lt;path&gt;并签&lt;commit-ish&gt;出 list # 列出每个工作树的详细信息 lock # 如果工作树位于便携式设备或网络共享上，且该共享并非始终挂载，请将其锁定以防止其管理文件被自动修剪 move # 将工作树移到新位置 prune # 修剪$ GIT_DIR &#x2F; worktrees中的修剪树信息 remove # 删除一棵工作树。只有干净的工作树（没有未跟踪的文件，并且没有修改跟踪的文件）可以被删除 unlock # 解锁一个工作树，允许它被修剪，移动或删除 -f, --force # 默认情况下，add拒绝创建一个新的工作树，当它 &lt;commit-ish&gt;是一个分支名称并且已经被另一个工作树签出并remove拒绝删除不干净的工作树时 -b &lt;new-branch&gt;, -B &lt;new-branch&gt; # 用add，创建一个名为&lt;new-branch&gt;起始处 的新分支&lt;commit-ish&gt;，并检查&lt;new-branch&gt;新的工作树 --detach # 随着add，在新的工作树中分离HEAD --[no-]checkout # 默认情况下，add检查出来&lt;commit-ish&gt;，但--no-checkout可以用来抑制，以进行自定义，如配置稀疏结帐结帐 --[no-]guess-remote # 与worktree add &lt;path&gt;没有，&lt;commit-ish&gt;而不是创建从HEAD一个新的分支，如果存在在恰好一个远程匹配的 基本名称的跟踪分支&lt;path&gt;，立足于远程跟踪分支的新分支，并标记远程跟踪分支为“上游”来自新的分支 --[no-]track # 创建新分支时，如果&lt;commit-ish&gt;是分支，则将其标记为新分支中的“上游” --lock # 创建后保持工作树锁定 -n, --dry-run # 随着prune，不要删除任何东西; 只是报告它会删除什么 --porcelain # 使用list，输出脚本的易于解析的格式 -v, --verbose # 随着prune，报告所有清除 --expire &lt;time&gt; # 使用时prune，只会使&lt;age&gt;以前的未使用的工作树过期 --reason &lt;string&gt; # 随着lock，为什么工作树被锁定的解释 &lt;worktree&gt; # 工作树可以通过相对路径或绝对路径来标识fetch 命令12345678910111213141516171819202122232425262728293031323334353637383940语法： git fetch [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…​]] git fetch [&lt;options&gt;] &lt;group&gt; git fetch --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)…​] git fetch --all [&lt;options&gt;]选项： --all # 取回所有遥控器 -a, --append # 追加refs的ref名称和对象名称到现有的内容.git&#x2F;FETCH_HEAD。 --depth&#x3D;&lt;depth&gt; # 将提取限制为从每个远程分支历史记录的提示中指定的提交数量 --deepen&#x3D;&lt;depth&gt; # 与--depth相似，只是它指定了来自当前浅边界而不是每个远程分支历史记录的提示的提交数 --shallow-since&#x3D;&lt;date&gt; # 加深或缩短浅储存库的历史记录，以便在&lt;date&gt;之后包含所有可访问的提交 --shallow-exclude&#x3D;&lt;revision&gt; # 加深或缩短浅储存库的历史记录，以排除可从指定的远程分支或标记访问的提交 --unshallow # 如果源存储库已完成，请将浅层存储库转换为完整存储库，以消除浅存储库施加的所有限制 --update-shallow # 默认情况下，从浅仓库中获取时， git fetch拒绝需要更新.git&#x2F;shallow的引用 --dry-run # 显示将做什么，不做任何改变 -f, --force # 当git fetch与&lt;rbranch&gt;:&lt;lbranch&gt; refspec一起使用时，它拒绝更新本地分支， &lt;lbranch&gt;除非&lt;rbranch&gt;它获取的远程分支是子孙的后代&lt;lbranch&gt; -k, --keep # 保持下载的包 --multiple # 允许指定多个&lt;repository&gt;和&lt;group&gt;参数 -p, --prune # 在提取之前，请删除远程不再存在的所有远程跟踪参考 -P, --prune-tags # 在获取之前，删除--prune已启用的远程不再存在的所有本地标记 -n, --no-tags # 默认情况下，指向从远程存储库下载的对象的标签将在本地​​获取并存储 --refmap&#x3D;&lt;refspec&gt; # 在获取命令行中列出的ref时，使用指定的refspec（可以多次提供）将ref映射到远程跟踪分支，而不是remote.*.fetch远程存储库的配置变量的值 -t, --tags # 从远程获取所有标签（即，将远程标签获取 refs&#x2F;tags&#x2F;*到具有相同名称的本地标签中），除此之外的任何其他内容都将被提取 --recurse-submodules[&#x3D;yes|on-demand|no] # 此选项控制是否以及在什么条件下也应提取填充的子模块的新提交 -j, --jobs&#x3D;&lt;n&gt; # 用于提取子模块的并行子项的数量 --no-recurse-submodules # 禁用递归获取子模块（这与使用该--recurse-submodules&#x3D;no选项具有相同的效果） --submodule-prefix&#x3D;&lt;path&gt; # 在信息消息（如“获取子模块foo”）中打印路径前加上&lt;path&gt; --recurse-submodules-default&#x3D;[yes|on-demand] # 此选项在内部用于为--recurse-submodules选项临时提供非负的默认值 -u, --update-head-ok # 默认情况下，git fetch拒绝更新与当前分支对应的头部 --upload-pack &lt;upload-pack&gt; # 当给定时，并且从git fetch-pack处理要从中获取的存储库，--exec&#x3D;&lt;upload-pack&gt;将传递给该命令以指定在另一端运行的命令的非默认路径 -q, --quiet # 通过 - 安静的git-fetch-pack和沉默任何其他内部使用的git命令 -v, --verbose # 详细 --progress # 当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定-q -4, --ipv4 # 仅使用IPv4地址，忽略IPv6地址 -6, --ipv6 # 仅使用IPv6地址，忽略IPv4地址 &lt;repository&gt; # 作为提取或拉取操作源的“远程”存储库 &lt;group&gt; # 名称指的是存储库列表，作为配置文件中的远程数据&lt;group&gt;的值 &lt;refspec&gt; # 指定要获取哪些引用以及哪些本地引用要更新pull 命令123456789101112131415161718192021222324252627282930313233343536373839404142434445语法： git pull [options] [&lt;repository&gt; [&lt;refspec&gt;…​]]选项： -q, --quiet # 这被传递给底层的git-fetch，以便在传输过程中压制报告，并在合并过程中将潜在的git-merge压制成静噪输出 -v, --verbose # 通过--verbose git-fetch和git-merge --[no-]recurse-submodules[&#x3D;yes|on-demand|no] # 该选项控制是否应该提取和更新所有已填充子模块的新提交与合并有关的选项： --commit， --no-commit # 执行合并并提交结果 -e, --edit, --no-edit # 在提交成功的机械合并之前调用编辑器来进一步编辑自动生成的合并消息，以便用户可以解释并验证合并 --ff # 当合并解析为快进时，只更新分支指针，而不创建合并提交。这是默认行为 --no-ff # 即使合并解析为快进，也可以创建合并提交 --ff-only # 拒绝合并并以非零状态退出，除非电流HEAD已经是最新的或合并可以解决为快进 --log[&#x3D;&lt;n&gt;], --no-log # 除了分支名称之外，还可以用来自至多&lt;n&gt;实际提交的单行描述来填充日志消息 --stat, -n, --no-stat # 在合并结束时显示diffstat。diffstat也由配置选项merge.stat控制 --squash, --no-squash # 生成工作树和索引状态，就像发生真正的合并（合并信息除外）一样，但实际上并未进行提交， 移动HEAD或记录$GIT_DIR&#x2F;MERGE_HEAD （以导致下一个git commit命令创建合并提交） -s &lt;strategy&gt;, --strategy&#x3D;&lt;strategy&gt; # 使用给定的合并策略; 可以多次提供，以按照他们应该尝试的顺序指定它们 -X &lt;option&gt;, --strategy-option&#x3D;&lt;option&gt; # 将合并策略特定选项传递给合并策略 --verify-signatures, --no-verify-signatures # 验证被合并的分支的提示提交是否使用有效密钥进行签名，即具有有效uid的密钥：在默认信任模型中，这意味着签名密钥已由可信密钥签名 --allow-unrelated-histories # 默认情况下，git merge命令拒绝合并不共享祖先的历史记录 -r, --rebase[&#x3D;false|true|preserve|interactive] # 如果为true，则在获取后重新绑定上游分支顶部的当前分支 --no-rebase # 早先覆盖--rebase --autostash, --no-autostash # 在开始rebase之前，如果需要，将局部修改隐藏起来，并在完成时应用存储条目与抓取相关的选项: --all # 取回所有遥控器 -a, --append # 追加refs的ref名称和对象名称到现有的内容.git&#x2F;FETCH_HEAD --depth&#x3D;&lt;depth&gt; # 将提取限制为从每个远程分支历史记录的提示中指定的提交数量 --deepen&#x3D;&lt;depth&gt; # 与--depth相似，只是它指定了来自当前浅边界而不是每个远程分支历史记录的提示的提交数 --shallow-since&#x3D;&lt;date&gt; # 加深或缩短浅储存库的历史记录，以便在&lt;date&gt;之后包含所有可访问的提交 --shallow-exclude&#x3D;&lt;revision&gt; # 加深或缩短浅储存库的历史记录，以排除可从指定的远程分支或标记访问的提交 --unshallow # 如果源存储库已完成，请将浅层存储库转换为完整存储库，以消除浅存储库施加的所有限制 --update-shallow # 默认情况下，从浅仓库中获取时， git fetch拒绝需要更新.git&#x2F;shallow的引用 -f, --force # 当git fetch与&lt;rbranch&gt;:&lt;lbranch&gt; refspec一起使用时，它拒绝更新本地分支，&lt;lbranch&gt;除非&lt;rbranch&gt;它获取的远程分支是子孙的后代&lt;lbranch&gt; -k, --keep # 保持下载的包 --no-tags # 默认情况下，指向从远程存储库下载的对象的标签将在本地​​获取并存储 -u, --update-head-ok # 默认情况下，git fetch拒绝更新与当前分支对应的头部 --upload-pack &lt;upload-pack&gt; # 当给定时，并且从git fetch-pack处理要从中获取的存储库，--exec&#x3D;&lt;upload-pack&gt;将传递给该命令以指定在另一端运行的命令的非默认路径 --progress # 当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定-q -4, --ipv4 # 仅使用IPv4地址，忽略IPv6地址 -6, --ipv6 # 仅使用IPv6地址，忽略IPv4地址 &lt;repository&gt; # 作为提取或拉取操作源的“远程”存储库 &lt;refspec&gt; # 指定要获取哪些引用以及哪些本地引用要更新push 命令123456789101112131415161718192021222324252627282930313233343536语法： git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack&#x3D;&lt;git-receive-pack&gt;] [--repo&#x3D;&lt;repository&gt;] [-f | --force] [-d | --delete] [--prune] [-v | --verbose] [-u | --set-upstream] [--push-option&#x3D;&lt;string&gt;] [--[no-]signed|--signed&#x3D;(true|false|if-asked)] [--force-with-lease[&#x3D;&lt;refname&gt;[:&lt;expect&gt;]]] [--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…​]]选项： &lt;repository&gt; # 作为推送操作目标的“远程”存储库 &lt;refspec&gt;…​ # 用什么源对象指定要更新的目标引用 --all # 推送所有分支（即参考下refs&#x2F;heads&#x2F;）; 不能与其他&lt;refspec&gt;一起使用 --prune # 删除没有本地副本的远程分支 --mirror # 代替命名每个裁判推的，指定了下的所有参考文献refs&#x2F;（包括但不限于refs&#x2F;heads&#x2F;，refs&#x2F;remotes&#x2F;和refs&#x2F;tags&#x2F;）被镜像到远程存储库 -n, --dry-run # 除了实际发送更新之外，请做其他事 --porcelain # 生成机器可读的输出 --delete # 所有列出的ref都从远程存储库中删除 --tags # refs&#x2F;tags除了在命令行中明确列出的refspecs之外，所有refs 都将被推送 --follow-tags # 推送所有没有此选项时将被推送的引用，并且推送refs&#x2F;tags远程引用中缺少的带注释的标签，但指向可从所推送的引用访问的提交标识 --[no-]signed, --signed&#x3D;(true|false|if-asked) # GPG-签署推送请求以更新接收端的refs，以便通过钩子检查和&#x2F;或记录 --[no-]atomic # 如果可用，请在远程端使用原子事务 -o &lt;option&gt;, --push-option&#x3D;&lt;option&gt; # 将给定的字符串传送给服务器，服务器将它们传递给预接收以及接收后挂接 --receive-pack&#x3D;&lt;git-receive-pack&gt;, --exec&#x3D;&lt;git-receive-pack&gt; # 远程端上git-receive-pack程序的路径 --[no-]force-with-lease, --force-with-lease&#x3D;&lt;refname&gt;, --force-with-lease&#x3D;&lt;refname&gt;:&lt;expect&gt; # 如果远程ref的当前值是期望值，则此选项将覆盖此限制 -f, --force # 通常，该命令拒绝更新远程ref，该远程ref不是用于覆盖它的本地ref的祖先 --repo&#x3D;&lt;repository&gt; # 该选项等同于&lt;repository&gt;参数。如果两者都指定，则命令行参数优先 -u, --set-upstream # 对于最新或成功推送的每个分支，添加无参数git-pull [1]和其他命令使用的上游（跟踪）引用 --[no-]thin # 这些选项被传递给git-send-pack [1] -q, --quiet # 抑制所有输出，包括更新的引用列表，除非发生错误 -v, --verbose # 运行详细 --progress # 当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定-q --no-recurse-submodules, --recurse-submodules&#x3D;check|on-demand|only|no # 可用于所有子模块提交的修改被推到远程跟踪分支上 --[no-]verify # 切换预推钩。默认值：验证，使钩子有机会阻止推送 -4, --ipv4 # 仅使用IPv4地址，忽略IPv6地址 -6, --ipv6 # 仅使用IPv6地址，忽略IPv4地址remote 命令123456789101112131415161718192021222324252627语法： git remote [-v | --verbose] git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror&#x3D;&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt; git remote rename &lt;old&gt; &lt;new&gt; git remote remove &lt;name&gt; git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;) git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…​ git remote get-url [--push] [--all] &lt;name&gt; git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;] git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt; git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt; git remote [-v | --verbose] show [-n] &lt;name&gt;…​ git remote prune [-n | --dry-run] &lt;name&gt;…​ git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]选项： -v, --verbose # 稍微详细一点，并在名称后显示远程URL add # 在&lt;url&gt;处添加一个名为&lt;名称&gt;的存储库 rename # 将名为&lt;old&gt;的远程重命名为&lt;new&gt;。远程的所有远程跟踪分支和配置设置都会更新 rm, remove # 删除名为&lt;名称&gt;的远程。远程的所有远程跟踪分支和配置设置均被删除 set-head # 设置或删除refs&#x2F;remotes&#x2F;&lt;name&gt;&#x2F;HEAD指定远程的默认分支（即symbolic-ref的目标） set-branches # 更改已命名远程所跟踪分支的列表 get-url # 检索远程的URL set-url # 更改远程的URL show # 给出关于远程&lt;名称&gt;的一些信息 prune # 删除与&lt;名称&gt;关联的陈旧引用 update # 按遥控器&lt;group&gt;的定义，获取存储库中一组指定遥控器的更新submodule 命令1234567891011121314151617181920212223242526272829303132语法： git submodule [--quiet] add [&lt;options&gt;] [--] &lt;repository&gt; [&lt;path&gt;] git submodule [--quiet] status [--cached] [--recursive] [--] [&lt;path&gt;…​] git submodule [--quiet] init [--] [&lt;path&gt;…​] git submodule [--quiet] deinit [-f|--force] (--all|[--] &lt;path&gt;…​) git submodule [--quiet] update [&lt;options&gt;] [--] [&lt;path&gt;…​] git submodule [--quiet] summary [&lt;options&gt;] [--] [&lt;path&gt;…​] git submodule [--quiet] foreach [--recursive] &lt;command&gt; git submodule [--quiet] sync [--recursive] [--] [&lt;path&gt;…​] git submodule [--quiet] absorbgitdirs [--] [&lt;path&gt;…​]选项： -q, --quiet # 只打印错误消息 --all # 该选项仅对deinit命令有效。取消注册工作树中的所有子模块 -b, --branch # 将存储库的分支添加为子模块 -f, --force # 该选项仅适用于添加，删除和更新命令。在运行add时，允许添加一个否则忽略的子模块路径。 --cached # 该选项仅对状态和汇总命令有效。些命令通常使用在子模块HEAD中找到的提交，但使用此选项时，将使用存储在索引中的提交。 --files # 该选项仅对汇总命令有效。当使用此选项时，此命令会将索引中的提交与子模块HEAD中的提交进行比较。 -n, --summary-limit # 该选项仅对汇总命令有效。限制摘要大小（总共显示的提交数量） --remote # 该选项仅对更新命令有效。使用子模块的远程跟踪分支的状态，而不是使用超级项目的已记录的SHA-1来更新子模块 -N, --no-fetch # 该选项仅对更新命令有效。不要从远程站点获取新的对象。 --checkout # 该选项仅对更新命令有效。检查子模块中分离的HEAD上超级项目中记录的提交。 --merge # 该选项仅对更新命令有效。将超级项目中记录的提交合并到子模块的当前分支中。 --rebase # 该选项仅对更新命令有效。将当前分支重新映射到超级项目中记录的提交。 --init # 该选项仅对更新命令有效。在更新之前，初始化尚未调用“git子模块初始化”的所有子模块。 --name # 该选项仅对add命令有效。它将子模块的名称设置为给定字符串，而不是默认其路径。 --reference &lt;repository&gt; # 该选项仅适用于添加和更新命令。这些命令有时需要克隆远程存储库。 --recursive # 此选项仅适用于foreach，更新，状态和同步命令。递归地遍历子模块。 --depth # 该选项对添加和更新命令有效。创建一个 历史记录截断为指定修订版数的浅表副本。 --[no-]recommend-shallow # 该选项仅对更新命令有效。默认情况下，子模块的初始克隆将使用submodule.&lt;name&gt;.shallow由.gitmodules文件提供的建议 。 -j &lt;n&gt;, --jobs &lt;n&gt; # 该选项仅对更新命令有效。与多个作业并行克隆新子模块。默认为submodule.fetchJobs选项。 &lt;path&gt;…​ # 子模块的路径。指定时，将限制该命令仅对在指定路径中找到的子模块进行操作。show 命令1234567891011121314语法： git show [options] [&lt;object&gt;…​]选项： &lt;object&gt;…​ # 要显示的对象的名称（默认为HEAD） --pretty[&#x3D;&lt;format&gt;], --format&#x3D;&lt;format&gt; # 漂亮地打印在提交日志的内容在给定的格式 --abbrev-commit # 不显示完整的40字节十六进制提交对象名称，只显示部分前缀 --no-abbrev-commit # 显示完整的40字节十六进制提交对象名称 --oneline # 这是一起使用的“--pretty &#x3D; oneline --abbrev-commit”的缩写 --encoding&#x3D;&lt;encoding&gt; # 提交对象在其编码头中记录用于日志消息的编码; 这个选项可以用来告诉命令在用户首选的编码中重新编写提交日志消息 --expand-tabs&#x3D;&lt;n&gt;, --expand-tabs, --no-expand-tabs # 在输出中显示日志消息之前，执行一个选项卡扩展（将每个选项卡用足够的空格替换，以填充日志消息中的倍数为&lt;n&gt;的下一个显示列） --notes[&#x3D;&lt;treeish&gt;] # 在显示提交日志消息时，显示注释提交的注释（请参阅git-notes [1]） --no-notes # 不要显示笔记 --show-signature # 通过签名传递gpg --verify并显示输出来检查签名提交对象的有效性shortlog 命令12345678910111213语法： git log --pretty&#x3D;short | git shortlog [&lt;options&gt;] git shortlog [&lt;options&gt;] [&lt;revision range&gt;] [[\\--] &lt;path&gt;…​]选项： -n, --numbered # 根据每个作者的提交数量而不是作者字母顺序对输出进行排序 -s, --summary # 禁止提交描述并仅提供提交计数摘要 -e, --email # 显示每位作者的电子邮件地址 --format[&#x3D;&lt;format&gt;] # 使用一些其他信息来描述每个提交，而不是提交主题 -c, --committer # 收集并显示提交者身份而不是作者 -w[&lt;width&gt;[,&lt;indent1&gt;[,&lt;indent2&gt;]]] # 通过包装每行的输入线来包装输出width &lt;revision range&gt; # 仅显示指定修订范围内的提交 [\\--] &lt;path&gt;…​ # 只考虑足以解释如何匹配指定路径的文件的提交describe 命令1234567891011121314151617181920语法： git describe [--all] [--tags] [--contains] [--abbrev&#x3D;&lt;n&gt;] [&lt;commit-ish&gt;…​] git describe [--all] [--tags] [--contains] [--abbrev&#x3D;&lt;n&gt;] --dirty[&#x3D;&lt;mark&gt;] git describe &lt;blob&gt;选项： &lt;commit-ish&gt;…​ # 提交对象名称来描述。如果省略，则默认为HEAD --dirty[&#x3D;&lt;mark&gt;], --broken[&#x3D;&lt;mark&gt;] # 描述工作树的状态。当工作树与HEAD匹配时，输出与“git describe HEAD”相同 --all # 不要只使用带注释的标签，而应使用refs&#x2F;名称空间中的任何参考 --tags # 不要只使用带注释的标签，而要使用refs&#x2F;tags名称空间中的任何标签 --contains # 不是找到提交之前的标签，而是找到提交之后的标签，因此包含它。自动暗示 - 标签 --abbrev&#x3D;&lt;n&gt; # 使用默认的7位十六进制数字作为缩写对象名称，而不是使用&lt;n&gt;数字或根据需要的数字来组成一个唯一的对象名称 --candidates&#x3D;&lt;n&gt; # 而不是只考虑最近的10个标签作为描述输入提交的候选者，而是考虑到候选者 --exact-match # 只输出完全匹配（一个标签直接引用提供的提交）。这是--candidates &#x3D; 0的同义词。 --debug # 精确地显示正在使用的搜索策略的信息以标准错误。标签名称仍将打印到标准输出。 --long # 即使与标签匹配，始终输出长格式（标签，提交数量和缩写提交名称） --match &lt;pattern&gt; # 只考虑与给定glob(7)模式匹配的标签，不包括“refs&#x2F;tags&#x2F;”前缀 --exclude &lt;pattern&gt; # 不要考虑与给定glob(7)模式匹配的标签，不包括“refs&#x2F;tags&#x2F;”前缀 --always # 显示唯一缩写的提交对象作为后备 --first-parent # 在查看合并提交后，只跟踪第一个父提交apply 命令123456789101112131415161718192021222324252627282930313233343536373839语法： git apply [--stat] [--numstat] [--summary] [--check] [--index] [--3way] [--apply] [--no-add] [--build-fake-ancestor&#x3D;&lt;file&gt;] [-R | --reverse] [--allow-binary-replacement | --binary] [--reject] [-z] [-p&lt;n&gt;] [-C&lt;n&gt;] [--inaccurate-eof] [--recount] [--cached] [--ignore-space-change | --ignore-whitespace] [--whitespace&#x3D;(nowarn|warn|fix|error|error-all)] [--exclude&#x3D;&lt;path&gt;] [--include&#x3D;&lt;path&gt;] [--directory&#x3D;&lt;root&gt;] [--verbose] [--unsafe-paths] [&lt;patch&gt;…​]选项： &lt;patch&gt;…​ # 从中读取补丁的文件。 -可用于从标准输入读取 --stat # 输出diffstat代替输入补丁。关闭“适用”。 --numstat # --stat与之类似，但显示十进制表示法中添加和删除的行数以及不带缩写的路径名，以使其更加机器友好 --summary # 输出从git diff扩展头获取的信息的精简摘要，而不是应用该修补程序。关闭“适用”。 --check # 而不是应用修补程序，查看修补程序是否适用于当前工作树和&#x2F;或索引文件并检测错误。关闭“适用”。 --index # 何时--check生效或应用修补程序，请确保修补程序适用于当前索引文件记录的内容 --cached # 在不接触工作树的情况下应用补丁 -3, --3way # 如果修补程序不能干净地应用，如果修补程序记录它应该应用的斑点的标识，则回退到3路合并， 并且我们在本地可以使用这些斑点，可能会在工作树中的文件中留下冲突标记供用户解决 --build-fake-ancestor&#x3D;&lt;file&gt; # 较新的git diff输出已经 为每个blob 嵌入了索引信息，以帮助识别修补程序适用的原始版本 -R, --reverse # 反向应用补丁 --reject # 对于原子性，git默认应用会失败整个修补程序，并且在某些不适用的情况下不会触及工作树 -z # 何时--numstat给出，请勿使用路径名，但使用NUL终止的机器可读格式 -p&lt;n&gt; # 从传统差异路径中删除&lt;n&gt;引导斜杠。默认值是1。 -C&lt;n&gt; # 确保每次更改之前和之后至少有&lt;n&gt;行周围环境匹配 --unidiff-zero # 默认情况下，git apply期望所应用的修补程序是一个至少包含一行上下文的统一差异 --apply # 如果您使用上面标记为“关闭应用 ”的任何选项 ，则git应用读取并输出所请求的信息，而不实际应用修补程序 --no-add # 应用修补程序时，忽略修补程序添加的内容 --allow-binary-replacement, --binary # 从历史上看，我们不允许在未经用户明确许可的情况下应用二进制补丁，并且此标志是实现此目的的方式 --exclude&#x3D;&lt;path-pattern&gt; # 不要将更改应用于与给定路径模式匹配的文件 --include&#x3D;&lt;path-pattern&gt; # 将更改应用于与给定路径模式匹配的文件 --ignore-space-change, --ignore-whitespace # 应用修补程序时，如果需要，请忽略上下文行中空白的更改 --whitespace&#x3D;&lt;action&gt; # 应用修补程序时，检测具有空白错误的新行或修改过的行 --inaccurate-eof # 在某些情况下，diff的某些版本不能在文件末尾正确检测到缺失的新行 -v, --verbose # 将进展报告给stderr。默认情况下，只会打印有关当前正在应用的修补程序的消息 --recount # 不要相信大块头中的行数，但通过检查补丁来推断它们 --directory&#x3D;&lt;root&gt; # 将&lt;root&gt;加入所有文件名。如果还传递了“-p”参数，则在应用新根之前应用该参数 --unsafe-paths # 默认情况下，影响工作区域以外的补丁被拒绝为错误cherry-pick 命令12345678910111213141516171819202122232425语法： git cherry-pick [--edit] [-n] [-m parent-number] [-s] [-x] [--ff] [-S[&lt;keyid&gt;]] &lt;commit&gt;…​ git cherry-pick --continue git cherry-pick --quit git cherry-pick --abort选项： &lt;commit&gt;…​ # 要获得一个更完整的拼写方法列表 -e, --edit # 使用这个选项，git cherry-pick会让你在提交之前编辑提交信息 -x # 在记录提交时，附加一条线，该行表示“(cherry从提交…)”到原始的提交消息，以指示该更改是从哪个提交的 -r # 它曾经是命令默认做-x 了上面描述，并且-r是禁用它 -m parent-number, --mainline parent-number # 通常你不能选择合并，因为你不知道合并的哪一边应该被认为是主线 -n, --no-commit # 通常，该命令会自动创建一系列提交 -s, --signoff # 在提交消息的末尾添加Signed-off-by行 -S[&lt;keyid&gt;], --gpg-sign[&#x3D;&lt;keyid&gt;] # GPG标志提交 --ff # 如果当前的HEAD与樱桃挑选的提交的父对象相同，则将执行快速转发此提交 --allow-empty # 默认情况下，樱桃选择一个空的提交将失败，表明需要显式调用git commit --allow-empty --allow-empty-message # 默认情况下，用空信息挑选提交将失败 --keep-redundant-commits # 如果在当前的历史中，如果提交的是cherry选择了重复提交，那么它将变为空的 --strategy&#x3D;&lt;strategy&gt; # 使用给定的合并策略。只能使用一次 -X&lt;option&gt;, --strategy-option&#x3D;&lt;option&gt; # 将合并策略特定选项传递给合并策略 --continue # 继续使用.git&#x2F;sequencer中的信息进行操作 --quit # 忘记当前正在进行的操作 --abort # 取消操作并返回到预序列状态rebase 命令12345678910111213141516171819202122232425262728293031323334353637383940414243语法： git rebase [-i | --interactive] [options] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;] [&lt;upstream&gt; [&lt;branch&gt;]] git rebase [-i | --interactive] [options] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;] --root [&lt;branch&gt;] git rebase --continue | --skip | --abort | --quit | --edit-todo | --show-current-patch 选项： --onto &lt;newbase&gt; # 创建新提交的起点 &lt;upstream&gt; # 上游分支进行比较。可以是任何有效的提交，而不仅仅是现有的分支名称。默认为当前分支的配置上游 &lt;branch&gt; # 工作分部; 默认为HEAD --continue # 解决了合并冲突后重新启动重新绑定过程 --abort # 中止rebase操作并将HEAD重置为原始分支 --quit # 放弃rebase操作，但HEAD不会重置回原始分支。索引和工作树也因此保持不变 --keep-empty # 在结果中保留不改变父项的任何提交 --allow-empty-message # 默认情况下，重新绑定提交空信息将失败 --skip # 通过跳过当前补丁重新启动重新绑定过程 --edit-todo # 在交互式重新绑定期间编辑待办事项列表 --show-current-patch # 在交互式底图中显示当前的补丁，或者由于冲突而停止底牌。这相当于 git show REBASE_HEAD -m, --merge # 使用合并策略来重新分配 -s &lt;strategy&gt;, --strategy&#x3D;&lt;strategy&gt; # 使用给定的合并策略 -X &lt;strategy-option&gt;, --strategy-option&#x3D;&lt;strategy-option&gt; # 将&lt;strategy-option&gt;传递给合并策略 -S[&lt;keyid&gt;], --gpg-sign[&#x3D;&lt;keyid&gt;] # GPG标志提交 -q, --quiet # 安静。意味着 - 无统计 -v, --verbose # 详细。意味着--stat -stat # 显示自上次rebase以来上游变化的差异。diffstat也由配置选项rebase.stat控制 -n, --no-stat # 不要将diffstat显示为rebase过程的一部分 --no-verify # 此选项绕过预先重新绑定钩子 --verify # 允许预重贴挂钩运行，这是默认设置 -C&lt;n&gt; # 确保每次更改之前和之后至少有&lt;n&gt;行周围环境匹配 -f, --force-rebase # 即使当前分支是最新的，并且--force没有做任何事情的命令也不会返回，强制重新分配 --fork-point, --no-fork-point # 计算&lt;branch&gt;引入的提交时，使用reflog可以在&lt;upstream&gt;和&lt;branch&gt;之间找到更好的共同祖先 --ignore-whitespace, --whitespace&#x3D;&lt;option&gt; # 这些标志被传递给应用该补丁的git apply程序。与--interactive选项不兼容 --committer-date-is-author-date, --ignore-date # 这些标志被传递给git am以轻松地改变重新发布的提交的日期。与--interactive选项不兼容。 --signoff # 这个标志被传递给git am签署所有重新提交的提交。与--interactive选项不兼容。 -i, --interactive # 列出将要重新分配的提交列表。让用户在重新绑定之前编辑该列表 -p, --preserve-merges # 重新创建合并提交，而不是通过重播合并提交引入的提交来平坦化历史 -x &lt;cmd&gt;, --exec &lt;cmd&gt; # 在每行在最终历史记录中创建提交后附加“exec &lt;cmd&gt;”。&lt;cmd&gt;将被解释为一个或多个shell命令 --root # 重新规划从&lt;branch&gt;可访问的所有提交，而不是用&lt;upstream&gt;限制它们 --autosquash, --no-autosquash # 当提交日志消息以“squash！...”（或“fixup！...”）开始时，并且在待办事项列表中已经有一个与之相匹配的提交时...， 会自动修改rebase -i的待办事项列表，以便被标记为压扁的提交在提交被修改后立即出现，并将被提交的提交的操作从（或）pick改为 --autostash, --no-autostash # 在操作开始之前自动创建临时存储条目，并在操作结束后应用它 --no-ff # 与-interactive，cherry-pick所有基于rebased的提交，而不是快速转发到未更改的revert 命令12345678910111213141516171819语法： git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&lt;keyid&gt;]] &lt;commit&gt;…​ git revert --continue git revert --quit git revert --abort选项： &lt;commit&gt;…​ # 承诺恢复。有关拼写提交名称的更完整列表 -e, --edit # 使用这个选项，git revert可以让你在提交恢复之前编辑提交信息 -m parent-number, --mainline parent-number # 通常您无法恢复合并，因为您不知道合并的哪一方应被视为主线 --no-edit # 使用这个选项，git revert不会启动提交消息编辑器 -n, --no-commit # 通常，该命令会自动创建一些提交日志消息，提交哪些提交已恢复 -S[&lt;keyid&gt;], --gpg-sign[&#x3D;&lt;keyid&gt;] # GPG标志提交。该keyid参数是可选的，并且默认为提交者身份; 如果指定，它必须粘贴到选项没有空格。 -s, --signoff # 在提交消息的末尾添加Signed-off-by行 --strategy&#x3D;&lt;strategy&gt; # 使用给定的合并策略 -X&lt;option&gt;, --strategy-option&#x3D;&lt;option&gt; # 将合并策略特定选项传递给合并策略 --continue # 继续使用.git&#x2F;sequencer中的信息进行操作 --quit # 忘记当前正在进行的操作。可用于在失败的cherry-pick或还原后清除排序器状态 --abort # 取消操作并返回到预序列状态bisect 命令1234567891011121314151617语法： git bisect &lt;subcommand&gt; &lt;options&gt; git bisect start [--term-&#123;old,good&#125;&#x3D;&lt;term&gt; --term-&#123;new,bad&#125;&#x3D;&lt;term&gt;] [--no-checkout] [&lt;bad&gt; [&lt;good&gt;...]] [--] [&lt;paths&gt;...] git bisect (bad|new|&lt;term-new&gt;) [&lt;rev&gt;] git bisect (good|old|&lt;term-old&gt;) [&lt;rev&gt;...] git bisect terms [--term-good | --term-bad] git bisect skip [(&lt;rev&gt;|&lt;range&gt;)...] git bisect reset [&lt;commit&gt;] git bisect (visualize|view) git bisect replay &lt;logfile&gt; git bisect log git bisect run &lt;cmd&gt;... git bisect help选项： --no-checkout # 在平分过程的每次迭代中，不要签出新的工作树blame 命令123456789101112131415161718192021222324252627282930313233语法： git blame [-c] [-b] [-l] [--root] [-t] [-f] [-n] [-s] [-e] [-p] [-w] [--incremental] [-L &lt;range&gt;] [-S &lt;revs-file&gt;] [-M] [-C] [-C] [-C] [--since&#x3D;&lt;date&gt;] [--progress] [--abbrev&#x3D;&lt;n&gt;] [&lt;rev&gt; | --contents &lt;file&gt; | --reverse &lt;rev&gt;..&lt;rev&gt;] [--] &lt;file&gt;选项： -b # 显示边界提交的空白SHA-1。这也可以通过blame.blankboundary配置选项来控制 --root # 不要将根提交视为边界。这也可以通过blame.showRoot配置选项来控制 --show-stats # 在责备输出结尾包含更多统计数据 -L &lt;start&gt;, &lt;end&gt;, -L :&lt;funcname&gt; # 仅注释给定的线范围。可以多次指定。重叠范围是允许的 -l # 显示长时间（默认：关闭） -t # 显示原始时间戳（默认值：关闭） -S &lt;revs-file&gt; # 使用revs-file中的修订版而不是调用git-rev-list [1] --reverse &lt;rev&gt;..&lt;rev&gt; # 前进而不是后退。它不是显示一行出现的修订，而是显示一行存在的最后修订 -p, --porcelain # 以设计用于机器消耗的格式显示 --line-porcelain # 显示porcelain格式，但输出每行的提交信息，而不仅仅是第一次引用提交 --incremental # 以设计用于机器消耗的格式逐步显示结果 --encoding&#x3D;&lt;encoding&gt; # 指定用于输出作者姓名和提交摘要的编码。将其设置为none使责备输出未转换的数据 --contents &lt;file&gt; # 当未指定&lt;rev&gt;时，该命令注释从工作树副本向后开始的更改 --date &lt;format&gt; # 指定用于输出日期的格式 --[no-]progress # 当连接到终端时，默认情况下标准错误流会报告进度状态 -M[&lt;num&gt;] # 检测文件中移动或复制的行 -C[&lt;num&gt;] # 除了-M检测从同一提交中修改的其他文件移动或复制的行之外 -h # 显示帮助信息 -c # 使用与git-annotate [1]相同的输出模式（默认值：关闭） --score-debug # 包含与文件之间的行移动有关的调试信息和文件中移动的行 -f, --show-name # 在原始提交中显示文件名 -n, --show-number # 在原始提交中显示行号（默认值：关闭） -s # 从输出中抑制作者姓名和时间戳 -e, --show-email # 显示作者电子邮件而不是作者姓名（默认：关闭） -w # 在比较父版本和子版本时，忽略空白，并找出这些行来自哪里 --abbrev&#x3D;&lt;n&gt; # 使用默认的7 + 1十六进制数字作为缩写对象名称，而不是使用&lt;n&gt; +1个数字grep 命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465语法： git grep [-a | --text] [-I] [--textconv] [-i | --ignore-case] [-w | --word-regexp] [-v | --invert-match] [-h|-H] [--full-name] [-E | --extended-regexp] [-G | --basic-regexp] [-P | --perl-regexp] [-F | --fixed-strings] [-n | --line-number] [-l | --files-with-matches] [-L | --files-without-match] [(-O | --open-files-in-pager) [&lt;pager&gt;]] [-z | --null] [-c | --count] [--all-match] [-q | --quiet] [--max-depth &lt;depth&gt;] [--color[&#x3D;&lt;when&gt;] | --no-color] [--break] [--heading] [-p | --show-function] [-A &lt;post-context&gt;] [-B &lt;pre-context&gt;] [-C &lt;context&gt;] [-W | --function-context] [--threads &lt;num&gt;] [-f &lt;file&gt;] [-e] &lt;pattern&gt; [--and|--or|--not|(|)|-e &lt;pattern&gt;…​] [--recurse-submodules] [--parent-basename &lt;basename&gt;] [ [--[no-]exclude-standard] [--cached | --no-index | --untracked] | &lt;tree&gt;…​] [--] [&lt;pathspec&gt;…​]选项： --cached # 在平分过程的每次迭代中，不要签出新的工作树 --no-index # 搜索当前目录中不受Git管理的文件 --untracked # 除了在工作树中跟踪文件中搜索外，还可以在未跟踪文件中搜索 --no-exclude-standard # 通过不尊重.gitignore 机制来搜索被忽略的文件。只用于--untracked --exclude-standard # 不要关注通过.gitignore 机制指定的忽略文件，仅在使用当前目录搜索文件时有用--no-index --recurse-submodules # 递归搜索已在存储库中初始化并检出的每个子模块 -a, --text # 像处理文本一样处理二进制文件 --textconv # 尊重textconv过滤器设置 --no-textconv # 不要兑现textconv过滤器设置。这是默认设置 -i, --ignore-case # 忽略模式和文件之间的大小写区别 -I # 不匹配二进制文件中的模式 --max-depth &lt;depth&gt; # 对于命令行中给出的每个&lt;pathspec&gt;，最多下降&lt;depth&gt;级别的目录 -w, --word-regexp # 仅在字边界处匹配模式 -v, --invert-match # 选择不匹配的行 -h, -H # 默认情况下，该命令显示每个匹配的文件名 --full-name # 从子目录运行时，该命令通常会输出相对于当前目录的路径 -E, --extended-regexp, -G, --basic-regexp # 对于模式使用POSIX扩展&#x2F;基本正则表达式。默认是使用基本的正则表达式 -P, --perl-regexp # 为模式使用Perl兼容的正则表达式 -F, --fixed-strings # 使用固定字符串模式 -n, --line-number # 在行号前加上匹配的行 -l, --files-with-matches, --name-only, -L, --files-without-match # 不显示每条匹配的行，只显示包含（或不包含）匹配的文件的名称 -O[&lt;pager&gt;], --open-files-in-pager[&#x3D;&lt;pager&gt;] # 打开寻呼机中的匹配文件（不是grep的输出） -z, --null # 输出\\ 0而不是通常跟在文件名后的字符 -c, --count # 显示匹配的行数，而不是显示每条匹配的行 --color[&#x3D;&lt;when&gt;] # 显示彩色的比赛。该值必须始终（默认），永不，或自动 --no-color # 关闭匹配突出显示，即使配置文件将默认设置为彩色输出。和...一样--color&#x3D;never --break # 在不同文件的匹配之间打印空行 --heading # 在文件的上方显示文件名，而不是在每个显示的行的开头 -p, --show-function # 显示包含匹配函数名称的上一行，除非匹配行是函数名称本身 -&lt;num&gt;, -C &lt;num&gt;, --context &lt;num&gt; # 显示&lt;num&gt;前导和尾部线条，并放置包含--连续的匹配组之间的线条 -A &lt;num&gt;, --after-context &lt;num&gt; # 显示&lt;num&gt;尾随线，并--在连续的匹配组之间放置一行 -B &lt;num&gt;, --before-context &lt;num&gt; # 显示&lt;num&gt;引出线，并--在相邻的匹配组之间放置一行 -W, --function-context # 显示前一行中包含函数名称的周围文本，直到下一个函数名称之前的文本，从而有效地显示找到匹配的整个函数 --threads &lt;num&gt; # 要使用的grep工作线程数 -f &lt;file&gt; # 从&lt;file&gt;中读取模式，每行一个 -e # 下一个参数是模式 --and, --or, --not, ( …​ ) # 指定如何使用布尔表达式组合多个模式 --all-match # 将多个模式表达式结合使用时--or，会指定此标志以将匹配限制为具有与其匹配的所有行的文件 -q, --quiet # 不输出匹配的行 &lt;tree&gt;…​ # 而不是在工作树中搜索跟踪文件，搜索给定树中的斑点 -- # 表示选项结束; 其余的参数是&lt;pathspec&gt;限制器 &lt;pathspec&gt;…​ # 如果给定，则将搜索限制为至少匹配一个模式的路径","categories":[{"name":"git","slug":"git","permalink":"https://hengxincheung.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hengxincheung.github.io/tags/git/"}]},{"title":"有状态和无状态登录","slug":"web/有状态和无状态登录","date":"2020-05-26T05:23:34.000Z","updated":"2020-05-29T11:28:23.458Z","comments":true,"path":"web/有状态和无状态登录/","link":"","permalink":"https://hengxincheung.github.io/web/%E6%9C%89%E7%8A%B6%E6%80%81%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95/","excerpt":"","text":"在一个系统中，用户的登录状态的维护是不可跨越的重要问题。根据登录状态保存在服务器端抑或客户端可以将其区分为:有状态登录无状态登录有状态登录有状态登录指登录状态存储在服务器端，其一般通过session机制保持会话，是一种用空间换时间的策略。流程如下：第一次请求时，服务器产生session对象，并将该session-id写入http协议的header中，回发给客户端；客户端接收到session-id，将其保存在cookie中，每次向服务器发送请求时都将携带着标识其身份的session-id；服务器接收到客户端的请求时，根据其携带的session-id检索对应的session对象中是否含有用户信息，若存在则判断已登录；否则判断未登录。说明：一般在客户端向服务器第一次请求时，服务器会自动生成session-id并将其添加到请求头部(request-header)。缺点及解决方案有状态登录会导致如下问题：服务器端保存大量数据，会占用服务器大量内存，在高并发时格外突出影响性能；服务器端保存用户状态，无法进行水平扩展；客户端请求依赖服务端，多次请求必须访问同一台机器（针对集群或分布式），需要在多个服务器中共享用户登录信息(可以理解为session)。针对以上问题，我们可以将session存储到redis数据库中（这只是一种解决方式，也可以将session同步复制到每一个服务器上），可以有效减少服务器的内存压力。分布式或集群的时候，先通过查询redis数据库来得到对应的session对象，进而查询用户状态。无状态登录无状态登录指服务器不保存用户的登录信息，客户端的每次请求必须具备自描述信息，服务器通过这些信息识别客户端身份。与有状态登录对比，是一种用时间换空间的策略。微服务集群中的每个服务，对外提供的都是rest风格的接口。而rest风格的一个最重要的规范就是：服务的无状态性。优点客户端请求不依赖服务端的信息，任何多次的请求不需要必须访问到同一台服务器；服务端的集群和状态对客户端是透明的 （p.s.计算机中的透明一词高深莫测）；服务端可以任意的迁移和伸缩；减小服务端的存储压力。实现无状态登录无状态登录的流程如下：当客户端第一次请求服务时，服务端对用户进行信息认证（登录）；认证通过，使用密钥将用户身份信息（不含密码，一般就是用户名）进行加密形成token（令牌），返回给客户端，作为登录凭证；客户端以后的每次请求都携带认证的token，一般为用户名+用户名的密文；服务端使用密钥对token的用户名部分进行加密（也可以反过来对密文进行解密），若加密或解密出来的部分与携带来的信息一致则判断已登录；否则判断未登录。在这种模式中，token是识别客户端身份的唯一标识，其安全性的保障是至关重要的。一般来说，推荐使用RSA非对称加密。因为客户端已知明文及其对应的密文，若使用对称加密的方式，容易被推导出密钥。那么现在可以解答为什么说无状态登录是一种用时间换空间的策略：因为无状态服务每次都需要对用户身份信息进行加密或解密操作，需要花费时间去计算，但无需将身份信息存储。思考能否将验证通过的用户信息及其密文存储到redis数据库中，那么在之后的验证就不需要进行加密解密运算了，只是在数据库中去寻找是否存在一致的用户信息，若存在则判断已登录。但好像这样是多此一举的，如果使用redis服务器，直接保存session-id和session对象就好。貌似使用RSA产生的token（令牌）并不会比使用session-id的方式安全很多。","categories":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/tags/web/"},{"name":"登录","slug":"登录","permalink":"https://hengxincheung.github.io/tags/%E7%99%BB%E5%BD%95/"}]},{"title":"RESTful简介","slug":"web/RESTful简介","date":"2020-05-26T05:22:00.000Z","updated":"2020-05-27T07:28:01.304Z","comments":true,"path":"web/RESTful简介/","link":"","permalink":"https://hengxincheung.github.io/web/RESTful%E7%AE%80%E4%BB%8B/","excerpt":"","text":"什么是RESTful?REST(Representational State Transfer, 表达性状态传递)。首先我们先了解一下涉及的一些概念:Resources(资源): 这里的资源指的是网络上的每一个实体，而每一个实体都有着d对应的URI(统一资源标识符),如果要访问这个资源，需要通过访问它的URI。Representation(表现层): 简单来说就是资源的表现形式，比如图片、HTML、文本等。State Transfer(状态转换): 客户端可以通过GET, POST, PUT, DELETE这些HTTP动词来操作资源。REST是从资源的角度来审视整个网络，将分布在网络中的某个节点（或资源）通过URI进行标识。而客户端和服务器传递的是资源的某种表现形式，并且客户端可以通过HTTP动词对服务器上的资源进行操作，实现“表达性状态转换”。满足以上约束条件和原则的应用程序或设计就是RESTful。换言之，RESTful就是一种架构的约束和规范。RESTful API对于API的设计，RESTful是如今最常见的设计规范，通常用于Web数据接口的设计。URI设计原则1：动词+宾语客户端通过“动词+宾语”的形式来操作服务器资源，动词指的是HTTP动词，宾语指的是资源。HTTP动词对应了服务器资源的一种操作：GET: 相当于数据库操作的SELECT，从服务器取出一项或多项资源。POST: 相当于数据库操作的CREATE，在服务器新建一个资源。PUT: 相当于数据操作的UPDATE，更新服务器资源（由客户端提供改变后的全部资源）。PATCH: 相当于数据库操作的UPDATE，更新服务器资源（由客户端提供改变的属性）。DELETE: 相当于数据库操作的DELETE，删除服务器资源。原则2：宾语必须是名词由于宾语是API中的URI，是HTTP动词作用的对象，所以宾语应该使用名词，而不是动词。原则3：复数URI对于URI建议使用复数。原则4：避免多级的URIHTTP状态码客户端的每一次请求，服务器都会给出响应，而响应包括HTTP状态码和数据两部分。下面给出HTTP状态码的含义：1xx: 相关信息2xx: 操作成功3xx: 重定向4xx: 客户端(请求)错误5xx: 服务器错误服务器响应原则原则1：不要返回纯文本API返回的数据格式，不应该是一个纯文本，应该是一个JSON对象，这样才符合结构化流程。同样，服务器响应的HTTP头部信息中的Content-Type属性也应该设置为application/json。原则2：发生错误时，不要返回200状态码在发生错误时，不应该返回一个200状态码，然后把错误信息放在数据体里，因为这样会导致需要解析完数据才能知道操作失败。","categories":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/tags/web/"},{"name":"RESTful","slug":"RESTful","permalink":"https://hengxincheung.github.io/tags/RESTful/"}]},{"title":"08-其他命令","slug":"linux快速入门/08-其他命令","date":"2020-05-25T17:38:28.000Z","updated":"2020-05-27T07:26:10.657Z","comments":true,"path":"linux快速入门/08-其他命令/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/08-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查找文件：find软链接：ln打包和压缩：tar软件安装：apt-get查找文件find命令十分强大，通常用来在特定目录下搜索符合条件的文件。1234find [路径] -name filename# 如果省略路径，表示在当前文件夹下查找# find命令可以搭配通配符使用，如find -name \"*.py\"# find命令的其他选项请自行用man或help查阅学习软链接12# 建立文件的软链接，类似于windos下的快捷方式ln -s 被链接的源文件 链接文件注意：若没有-s选项建立的是硬链接文件。源文件要使用绝对路径，不能使用相对路径。这样方便移动链接文件后仍能正常使用。使用ls -l查看软链接文件会看到后面又-&gt;link_resource_src在Linux中，文件名和文件的数据是分开存储的。硬链接相当于文件数据的另一个文件名，故在Linux中只有文件的硬链接数==0才是真正被删除。在现实工作中几乎不会建立文件的硬链接。打包压缩在不同的操作系统，常用的打包压缩方式是不同的：windows常用rarMac常用zipLinux常用tar.gz打包/解包tar 是linux中最常用的备份工具，此命令可以把一系列文件打包到一个大文件中，也可以把一个打包的大文件恢复成一系列文件。tar命令只负责打包，而不负责压缩。12345# 打包文件tar -cvf 打包文件.rar 被打包文件/路径# 解包文件tar -xvf 打包文件.rar选项说明c生成档案文件，创建打包文件x解开档案文件v列出归档接档文件的详细过程，显示进度f指定档案文件名称，f后面一定是.tar文件，所以此须在最后注意：-f必须在最后，其他顺序随意压缩/解压缩1)gziptat和gzip命令结合可以实现文件的打包和压缩，其扩展名一般用xxx.tar.gz在tar命令中有一个选项-z可以调用gzip,从而更方便实现压缩和解压缩的功能。12345678# 压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件/路径# 解压缩文件tar -zxvf 打包文件.tar.gz# 解压缩到指定路径tar -zxvf 打包文件.tar.gz -C 指定的路径-C选项解压缩到指定目录，要注意的是指定的路径必须存在2）bzip2tat和bzip2命令结合可以实现文件的打包和压缩，其扩展名一般用xxx.tar.bz2在tar命令中有一个选项-j可以调用bzip2,从而更方便实现压缩和解压缩的功能。12345# 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩的文件/路径# 解压缩文件tar -jxvf 打包文件.tar.bz2软件安装通过apt安装/卸载软件apt是Advanced Packaging Tool，是linux下一款安装包管理工具。通过apt可以在终端方便的安装/卸载/更新软件包。1234567891011121314# 安装软件$ sudo apt install 软件包# 卸载软件$ sudo apt remove 软件包# 更新已安装的软件$ sudo apt upgrate# 示例# 一个小火车提示 sl$ sudo apt install sl# 一个比较漂亮的查看当前进程排名的软件 htop$ sudo apt install htopsl示意图htop示例图设置软件源可以通过设置镜像源，选择一个访问网速更快的服务器，使得下载/安装服务更加快速。所谓镜像源，就是所有服务器的内容是相同的（镜像），但是根据你所处的地理位置不同，不同的服务器对你的响应和下载速度不一样，国内的服务器速度会更快一些。要修改的文件/etc/apt/sources.list查看原资源文件cat /etc/apt/sources.list备份原来的源：1$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup使用脚本更改为aliyun的镜像源：123456789101112Codename&#x3D;$( (lsb_release -a)|awk &#39;&#123;print $2&#125;&#39;|tail -n 1 )echo &quot;\\deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename main multiverse restricted universedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-backports main multiverse restricted universedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-proposed main multiverse restricted universedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-security main multiverse restricted universedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-updates main multiverse restricted universedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename main multiverse restricted universedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-backports main multiverse restricted universedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-proposed main multiverse restricted universedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-security main multiverse restricted universedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; $Codename-updates main multiverse restricted universe &quot;&gt;sources.list记得修改完镜像源之后要更新软件源：1234# 更新软件源sudo apt-get update# 更新软件sudo apt-get upgrade","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"07-系统信息","slug":"linux快速入门/07-系统信息","date":"2020-05-25T17:37:35.000Z","updated":"2020-05-27T07:25:01.493Z","comments":true,"path":"linux快速入门/07-系统信息/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/07-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/","excerpt":"","text":"系统信息的相关命令为了方便通过终端维护服务器时，查看服务器当前的系统日期和时间/磁盘空间占用情况/程序执行情况目标时间和日期datecal磁盘和目录空间dfdu进程信息pstopkill时间和日期命令作用date查看系统时间calcalendar 查看日历，-y选项可以查看一年的日历磁盘信息命令作用df -hdisk free显示磁盘剩余空间du -h [目录名]disk usage 显示目录下文件的大小-h以人性化的方式显示文件大小，如4096将会被显示会4K进程信息所谓进程，通俗地讲就是当前正在执行的一个程序命令作用ps auxprocess status 查看进程的详细信息top动态显示运行中的进程并排序kill [-9] 进程代号终止指定代号的进程，-9代表强制终止ps默认只会显示当前用户通过终端启动的应用程序ps选项说明：选项含义a显示终端上所有进程，包括其他用户的进程u显示进程的详细信息x显示没有控制终端的信息使用kill命令尽可能只杀死自己开启的进程，而不要杀死属于root的进程，以防止系统崩溃。要退出top可以直接输入q","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"06-用户权限","slug":"linux快速入门/06-用户权限","date":"2020-05-25T17:35:27.000Z","updated":"2020-05-27T07:24:58.489Z","comments":true,"path":"linux快速入门/06-用户权限/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/06-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/","excerpt":"","text":"用户和权限的基本概念基本概念用户是Linux系统工作中重要的一环，用户管理包括用户和组管理不同的用户对于不同的系统资源都有着不同的使用权限在Linux中，可以指定每一个用户针对不同的文件或目录的不同权限对文件/目录的权限包括权限英文缩写数字代号读readr4写writew2执行excutex1组在实际应用中，可以预先针对组设置好权限，然后将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限。ls -l扩展ls -l可以查看文件的详细信息，从左到右依次是：权限：如果第一个字符是d表示目录，拥有者权限、组权限、其他人权限硬链参数：由多少种方式可以访问当当前的目录文件拥有者：文件的拥有人组大小时间名称chmod简单使用chmod可以修改用户/组对文件/目录的权限。命令格式如chmod +/-rwx 文件名|目录名注：上述方式会一次性修改拥有者/组的权限超级用户Linux系统中的root账户通常用于系统的维护和管理，对操作系统所有资源具有所有权限。不推荐直接使用root账号登陆，以保证系统的安全在Linux安装过程中，系统会自动创建一个用户账号，而这个默认用户就称为标准用户sudosu是substitute user的缩写，表示使用另一个用户身份sudo命令表示以其他身份来执行命令，预设的身份是root用户使用sudo时，必须先输入密码，之后有5分钟的有效期，超过期限需重新输入密码若未经授权用户企图使用sudo，则会发出警告邮件给管理员组管理 终端命令提示：创建/删除组的终端命令都需要通过sudo执行命令作用groupadd 组名添加组groupdel 组名删除组cat /etc/group确认组信息chgrp 组名 文件/目录名修改文件/目录的所属组，选项-R递归修改提示：组信息保存在/etc/group文件中/etc目录是专门用来保存系统配置信息的目录用户管理 终端命令命令作用说明useradd -m -g 组 新建用户名添加新用户- m:创建家目录;-g 指定用户所在组，默认同名passwd 用户名设置用户密码如果是普通用户，直接用passwd修改密码userdel -r 用户名删除用户-r 会自动删除用户家目录cat /etc/passwd\\grep 用户名确认用户信息新建用户后，信息保存在/etc/passwd文件中创建用户时，如果忘记添加-m选项，需要手动为该用户创建家目录。最好的方法是删除该用户再新建。创建用户时，默认会创建一个和用户名同名的组名用户信息保存在/etc/passwd/文件中查看用户信息命令作用id [用户名]查看用户uid和gid信息who查看当前所有登陆的用户列表whoami查看当前登陆用户的账户名passwd文件/etc/passwd文件存放的是用户信息，由6个分号组成7个信息：1.用户名2.密码（x表示加密的密码）3.uid（用户标识）4.gid（组标识）5.用户全名或本地账号6.家目录7.登陆使用的shell，就是登陆之后使用的终端命令，ubuntu默认是dash1234# 示例$ cat -n /etc/passwd | grep zhangsan# 49 zhangsan:x:1001:1001::/home/zhangsan:# x表示密码加密无法查看，第一个1001表示用户id，第二个1001表示所在组id，最后是该用户名的家目录绝对路径usermod 设置用户主组/附加组usermod可以用于设置用户的主组/附加组和登陆shell。主组：通常在新建用户时指定，在etc/passwd的第4列gid对用的组附加组：在etc/passwd中最后一列表示该组的用户列表，用于指定用户的附加权限。添加附加组后，需要重新登陆才能生效。12345678# 修改用户的主组usermod -g 组 用户名# 修改用户的附加组usermod -G 组 用户名# 修改用户登陆shellusermod -s &#x2F;bin&#x2F;bash默认使用useradd添加的用户没有权限使用sudo和以root身份执行命令，可以使用以下命令添加用户到sudo附加组中usermod -G sudo 用户名which 查看执行命令位置/etc/passwd用于保存用户信息的文件/usr/bin/passwd是用于修改密码的程序which命令可以查看执行命令的所在位置，例如12345$ which ls# 输出：/bin/ls$ which useradd# 输出：/usr/sbin/useraddbin和sbin在Linux中，绝大多数的可执行文件都是保存在/bin、/sbin、/usr/bin、usr/sbin/bin(binary)是二进制执行文件目录，主要用于具体应用/sbin(system binary)是系统管理员专用的二进制代码存放目录，主要用于系统管理/usr/bin(user command for applications)后期安装的软件/usr/sbin(super user command for applications)超级用户的一些管理程序注：cd是内置在linux内核中的终端命令，因此使用which无法找到切换用户命令作用说明su - 用户名切换用户，并切换目录- 可以切换到用户家目录，否则保持位置不变exit退出当前登陆用户su不写用户名，可以切换到root，不推荐使用修改文件权限命令作用chown修改拥有者chgrp修改组chmod修改权限命令格式如下：12345678# 修改文件\\目录的拥有者$ chown 用户名 文件名|目录名# 递归修改文件|目录的组$ chgrp -R 组名 文件名|目录名# 递归修改文件权限，读是4，写是2，执行是1$ chmod -R 755 文件名|目录名chmod在设置权限时，可以简单地使用三个数字分别对应拥有者、组和其他用户的权限，12# 直接修改文件|目录的读|写|执行权限，不能精确到拥有者|组|其他用户$ chmmod +/-rwx 文件名|目录名常见的数字组合：777—-&gt;u=rwx,g=rwx,o=rwx755—-&gt;u=rwx,g=-rx,o=-rx644—-&gt;u=rw-,g=r—,o=r—","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"05-远程管理命令","slug":"linux快速入门/05-远程管理命令","date":"2020-05-25T17:33:36.000Z","updated":"2020-05-30T13:20:26.027Z","comments":true,"path":"linux快速入门/05-远程管理命令/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/05-%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/","excerpt":"","text":"关机/重启shutdownshutdown命令可以安全关闭或者重启操作系统选项含义-r重新启动-c取消计划不指定选项和参数，默认表示一分钟之后关闭电脑远程维护服务器时，最好不要关闭系统，而应该重启系统常用命令示例：12345678910# 马上重启系统$ shutdown -r now# 立即关机$ shutdown now# 在今天20：30关机$ shutdown 20:30# 系统再过十分钟关闭系统$ shutdown +10# 取消关机/重启任务$ shutdown -c查看或配置网卡信息命令英文作用ifconfigconfigure a network interface查看/配置计算机当前的网卡信息ping ipping检测目标ip地址连接是否正常网卡和ip地址网卡网卡是一个负责网络通讯的硬件设备ip地址是设置在网卡上的地址信息（相当于门牌，别人根据这个ip在网路上找到你），ip地址是以网络号和主机号来标示网络上的主机ip地址每台联网的电脑上都有ip地址，是保证电脑之间正常通讯的重要设置。ip地址不能相同（这里指的是公网，许多计算机的本地ip相同这是由于子网等措施，详细查看《计算机网络》）ifconfigifconfig可以查看/配置计算机当前的网卡信息12345# 查看网卡配置信息$ ifconfig# 查看网卡对应的ip地址ifconfig | grep inet一台计算机有可能有一个物理地址和多个虚拟网卡，Linux中物理网卡的名字通常以ensXX表示。127.0.0.1被称为本地回环/环回地址，一般用来测试本机网卡是否正常。ping1234# 检测目标主机是否连接正常$ ping 地址# 检测本地网卡是否正常$ ping 127.0.0.1在Linux中，想要终止一个终端程序的执行，绝大多数都可以使用CTRL + C远程登陆和复制文件命令英文作用ssh 用户名@ipsecure shell远程管理scp 用户名@ip:文件名或路径secure copy远程复制文件ssh基础在Linux中SSH是非常常用的工具，通过SSH客户端我们就可以连接到运行了SSH服务器的机器上。ssh是目前较可靠，专为远程登陆会话和其他网络服务提供安全性的协议。数据传输是加密的、压缩的，防止了信息泄露和提高了传输速度，有效抵抗了DNS欺骗和IP欺骗1)域名和端口号域名是ip地址的别名，方便用户记忆，由一串用点分隔的名字组成，如www.baidu.com通过ip地址可以找到网路上的计算机，而通过端口号则可以找到计算机上运行的应用程序。SSH服务器的默认端口号是22，如果是默认端口号，连接的时候，可以忽略。常见的服务器端口号列表：端口号服务22ssh服务器80web服务器443HTTPS21FTP服务器3306mysql程序8080tomcat容器2)ssh客户端的简单使用123ssh [-p port] user@remote# 例子ssh -p 22 root@127.0.0.1user是远程机器上的用户名，如果不指定默认为当前用户remote是远程机器上的地址，可以是ip/域名port是SSH Server监听的端口，如果不指定默认为22提示：使用exit退出当前用户的登陆注意：如果在windows系统中，可以安装PuTTY或者XShell客户端软件即可。scpscp是一个Linux下用于进行远程拷贝文件的命令。它的地址格式与ssh基本相同，需要注意的是，在指定端口时用的是大写的-P，而不是小写的。12345678910111213# 把本地目录下的1.txt文件复制到远程的家目录下的Desktop/1.txt# 注意：':'后面的路径如果不是绝对路径，则以用户的家目录作为参考路径scp -P port 1.txt user@remote:Desktop/1.txt# 把远程的家目录下的Desktop/1.txt复制到本地当前目录的2.txtscp -P port user@remote:Desktop/1.txt 2.txt# 加上-r选项可以传递文件夹# 把当前目录下的demo文件夹复制到远程的家目录下Desktopscp -r demo user@remote:Desktop# 把远程家目录下的demo文件夹复制到当前目录下scp -r user@remote:Desktop/demo .选项含义-r若给出的源文件是目录文件，则scp将递归复制该目录下的所有子目录和文件，目标文件必须是一个目录名-P指定端口号SSH高级有关的sshp配置信息都保存在家目录下.ssh目录下免密码登陆配置公钥执行ssh-keygen即可生成ssh钥匙，一路回车即可。上传公钥到服务器执行ssh-copy-id -p port user@remote,可以让远程服务器记住我们的公钥。配置别名每次都输入ssh -p port user@remote，时间长了就觉得麻烦，特别是经常访问同一主机时。而配置别名可以让我们进一步偷懒，可以用ssh linux来替代上面的一长串。在~/.ssh/config（若原先不存在，请用touch命令创建）里面追加以下内容：1234Host linux HostName ip地址 User root Port 22保存之后，即可用ssh linux实现远程登陆了，scp也同样可以。","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"04-文件与目录","slug":"linux快速入门/04-文件与目录","date":"2020-05-25T17:30:58.000Z","updated":"2020-05-27T07:24:48.458Z","comments":true,"path":"linux快速入门/04-文件与目录/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/04-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/","excerpt":"","text":"文件和目录常用命令查看目录内容:ls切换目录:cd创建和删除操作:touch、rm、mkdir拷贝和移动文件:cp、mv查看文件内容:cat、more、grep其他echo重定向&gt;和&gt;&gt;管道|ls命令说明ls是单词list的缩写，其功能是列出目录的内容，是用户最常见的命令之一。Linux下文件和目录的特点文件和目录名称最长可以有256个字符以.开头的文件为隐藏文件，需要使用-a参数才能显示.代表当前目录..代表上一级目录ls常用选项参数命令-aall，显示指定目录的所有文件，包括隐藏文件-llong，以列表方式显示文件的详细信息-h需要配合-l使用(ls -lh或ls -l -h)，以人性化的方式显示文件大小ls与通配符配合如果目录中的文件十分之多，可以借助通配符快速定位所需的文件或目录。注：其实通配符可以运用到大多数的command，如rm等。通配符含义*代表任意个数个字符?代表任意一个字符，至少一个[]表示可以匹配字符组中的任一个[abc]、[a~z]匹配a、b、c中任意一个；匹配从a到f范围内的任意一个字符切换目录cd是change diretory的简写，其功能是更改当前的工作目录，也是用户最常用的命令之一。注意：Linux下的所有目录和文件的都是大小写敏感的。命令含义cd切换回当前用户的家目录cd ~切换回当前用户的家目录cd .切换回当前目录cd ..切换回上一级目录cd -在最近两次的目录间切换相对路径和绝对路径相对路径：直接输入目录，表示相对当前目录所在的目录位置绝对路径：输入路径时，最前面是/或~，表示从根目录或家目录开始的具体目录位置创建和删除目录touch创建文件或修改文件时间如果文件不存在，可以创建一个空白文件如果文件已经存在，可以修改文件的末次修改时间mkdir创建一个新的目录选项含义-p递归创建目录新建的目录的名称不能与当前目录中已有的目录或文件同名rm删除文件或目录使用rm命令要小心，文件删除后不能恢复|选项|含义||—-|—-||-f|强制删除，忽略不存在的文件，无需提示||-r|递归删除目录下的内容，删除文件夹必须加此参数|拷贝和移动文件命令对应英文功能tree [目录名]tree以树状图列出文件目录结构cp 源文件 目标文件copy复制文件或目录mv 源文件 目标文件move移动文件或目录/文件或目录重命名treetree命令可以以树状图列出文件的目录结构。选项含义-d只显示目录cpcp命令可以将给出的文件或目录复制到另一个文件或目录中。选项含义-f已经存在的目标文件直接覆盖，不会提示-i覆盖文件前提示-r若源文件是目录，将递归复制该目录下所有的子目录和文件，目标必须是一个目录mvmv移动文件或目录或为文件或目录重命名。选项含义-i覆盖文件前提示重命名时候建议添加-i的选项以防止覆盖已存在的文件。查看文件内容命令对应英文作用cat 文件名concatenate查看文件内容、创建文件、文件合并、追加文件内容等more 文件名more分屏显示文件内容grep 搜索文本 文件名grep搜索文本文件内容catcat会一次性显示所有内容，适合查看内容较少的文本文件选项含义-b对非空输出行编号-n对输出的所有行编号Linux中的 nl 命令和 cat -b 等价moremore会分屏显示文本内容，每次只显示一页，适合查看内容较多的文本文件grepgrep允许对文本文件进行模式查找，即正则表达式。选项含义-v显示不包含匹配文本的所有行，相当于求反-n显示匹配及行号-i忽略大小写参数含义^a行首，搜索以a开头的行ke$行尾，搜索以ke结束的行其他echo 文字内容echo会在终端中显示参数指定的文字，通常会和重定向联合使用重定向&gt;和&gt;&gt;Linux允许将命令执行结果重定向到一个文件将本应显示在终端上的内容输出/追加到指定文件中其中&gt;表示输出，会覆盖文件原有的内容&gt;&gt; 表示追加，会将内容追加到已有文件的末尾管道 |Linux允许将一个命令的输出通过管道作为另一个命令的输入这里的|就是管道（从一头塞进去另一头拿出来），|分为左右两部分，左端写，右端读常用的管道命令有：more：分屏显示内容grep：在命令执行结果的基础上查询指定的文本","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"03-linux命令与小技巧","slug":"linux快速入门/03-linux命令与小技巧","date":"2020-05-25T17:29:18.000Z","updated":"2020-05-27T07:24:40.979Z","comments":true,"path":"linux快速入门/03-linux命令与小技巧/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03-linux%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"Linux终端命令格式1command [-options] [parameter][]代表可选说明:command:命令名，相应功能的英语单词或单词缩写[-options]:选项，可用于对命令进行控制，也可以忽略[parameter]:传给命令的参数，可以是零个、一个或多个常用的Linux命令的基本使用命令英文功能lslist查看当前文件夹下的内容pwdprint work directory查看当前所在文件夹cd[目录名]change directorychange directorytouch[文件名]touch如果文件不存在则创建文件mkdir[目录名]make directory创建目录rm[文件名]remove删除指定的文件名clearclear清屏使用终端时的小技巧ctrl + shift + =放大终端窗口字体显示ctrl + -缩小终端窗口字体显示自动补全在敲出文件/目录/命令的前几个字母，按下Tab，如果输入没有歧义，系统会自动补全。如果存在多个同前缀的命令，再按一次Tab会提示存在的命令使用曾经用过的命令按住上或下可以在曾经使用过的命令间切换如果想要退出选择，并且不想执行当前选中的命令，可以按Ctrl + c查询命令帮助信息help命令1command --help说明：显示command命令的帮助信息man命令1man command说明：查询command的使用手册。man是mannual的缩写，是Linux提供的手册，包含了绝大多数命令、函数的详细使用说明。使用man时候的操作键：操作键功能空格键显示手册的下一屏Enter键一次滚动手册页的一行b回滚一屏f前滚一屏q退出/word搜索word字符串","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"02-文件系统简介","slug":"linux快速入门/02-文件系统简介","date":"2020-05-25T17:27:34.000Z","updated":"2020-05-27T07:24:35.154Z","comments":true,"path":"linux快速入门/02-文件系统简介/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/","excerpt":"","text":"文件和目录单用户和多用户操作系统单用户操作系统：一台计算机同一时间只能由一个用户使用，一个用户独享计算机的全部硬件和软件资源。多用户操作系统：一台计算机同一时间可以由多个用户使用，所有用户共享计算机的硬件和软件资源。文件系统Windows下的文件系统是一个个的驱动器盘符，每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形：而linux没有盘符的概念，只有一个根目录/，所有的文件都在它的下面。每个用户在/home目录下都有其自己（用户名）的目录，一般来说用户只能操作属于自己的目录。linux主要目录速查表/：根目录，在linux只有一个根目录，所有的东西都从这里开始。输入/home，其实是告诉电脑先从/目录开始，在进入到home目录/bin、/usr/bin：可执行二进制文件的目录，如常用的命令ls 、tar、mv、cat等/boot：放置linux系统启动时用到的一些文件，如linux的内核文件：/boot/vmlinux，系统引导管理器：/boot/grub/dev：存放linux系统下的设备文件，访问该目录下的某个文件，相当于访问某个设备，常用的是挂载光驱：mount /dev/cdrom/mnt/etc：系统配置文件的存放的目录，不建议在此目录存放可执行文件，重要的配置文件有：/etc/inittab/etc/fstab/etc/init.d/etc/sysconfig/home:系统默认的用户目录/lib、usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助/lost+fount：系统异常产生错误时，会将一些遗失的片段放置到该目录下/mnt、/media：光盘默认挂载点，通常光盘挂载到/mnt/cdrom下/opt：给主机额外安装软件所摆放的目录/proc：此目录的数据都在内存中，如系统核心、外部设备、网络状态等，不占用空间/root：系统管理员root的家目录","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"01-操作系统","slug":"linux快速入门/01-操作系统","date":"2020-05-25T17:25:58.000Z","updated":"2020-05-27T07:24:28.086Z","comments":true,"path":"linux快速入门/01-操作系统/","link":"","permalink":"https://hengxincheung.github.io/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"操作系统（Operation System, OS）操作系统的概念操作系统是一套特定的软件，是用户和硬件的接口和桥梁。没有安装操作系统的计算机，通常被称为裸机如果想在裸机上运行程序，必须使用机器语言书写程序如果计算机上安装了操作系统，就可以在操作系统上安装支持的高级语言环境，使用高级语言开发程序不同应用领域的主流操作系统桌面操作系统：Windows、macOS、linux服务器操作系统：linux（安全免费，占有率高）、windows server（收费，占有率低）嵌入式操作系统：linux移动设备操作系统：ios、Android、塞班虚拟机虚拟机（Virtual Machine）指通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统虚拟系统通过生成现有操作系统的全新虚拟镜像，具有真实操作系统完全一样的功能虚拟系统不会对真正的系统产生任何影响，且能随意切换操作系统的发展历史Unix1969年Ken Thompson用一个月的时间，使用汇编语言写出了Unix原型。1970年以BCPL语言为基础，设计出很简单且很接近硬件的B语言，并用B语言写出了第一个unix操作系统。1972年，Dennis M.Ritchie 改造B语言（跨平台性较差）设计出了C语言。1973年，C语言主体完成，两人使用C语言完全重写了现在大名鼎鼎的unix操作系统。Unix操作系统是多用户的，允许多用户在同一时间登陆到同一个电脑上。Minix因为unix操作系统源码的私有化，Andrew教授为了能在课堂上教授学生操作系统的运行细节，自行开发了与unix兼容的操作系统，以小型unix之意，取名minix。linux1991年Linus对unix产生浓厚兴趣，尝试在minix上做开发，编写了磁盘驱动程序和文件系统。这些成为了linux第一个内核的雏形。linus将其开源，得到全世界程序员的贡献，linux操作系统愈加完善。Linux内核及发行版内核(Kernel)是系统的心脏，是运行程序和管理硬件设备的核心程序。它提供了一个裸设备与应用程序间的抽象层。发行版是基于内核包装了各种各样的应用程序。常见发行版有：UbuntuRedhatDebianCentOSDeepin","categories":[{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"}]},{"title":"15-IO","slug":"numpy教程/15-IO","date":"2020-05-25T16:37:46.000Z","updated":"2020-05-27T07:27:52.563Z","comments":true,"path":"numpy教程/15-IO/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/15-IO/","excerpt":"","text":"Numpy 可以读写磁盘上的文本数据或二进制数据。NumPy 为ndarray对象引入了一个简单的文件格式：npy。npy文件用于存储重建ndarray所需的数据、图形、dtype 和其他信息。常用的 IO 函数有：load()和save()函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中。savze()函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npz的文件中。loadtxt()和savetxt()函数处理正常的文本文件(.txt等)numpy.save()和numpy.load()numpy.save()函数将数组保存到以.npy为扩展名的文件中。在这里我们可以使用load()函数来读取数据。1234567891011numpy.save(file, arr, allow_pickle=True, fix_imports=True)# file：要保存的文件，扩展名为.npy，如果文件路径末尾没有扩展名.npy，该扩展名会被自动加上# arr: 要保存的数组# allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python中的pickle用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化# fix_imports: 可选，为了方便Pyhton2中读取Python3保存的数据a = np.array([1,2,3,4,5]) # 保存到 outfile.npy 文件上np.save('outfile.npy',a)b = np.load('outfile.npy')np.savez()numpy.savez()函数将多个数组保存到以npz为扩展名的文件中。123456789101112131415161718numpy.savez(file, *args, **kwds)# file：要保存的文件，扩展名为.npz，如果文件路径末尾没有扩展名.npz，该扩展名会被自动加上# args: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为arr_0, arr_1, …。# kwds: 要保存的数组使用关键字名称import numpy as np a = np.array([[1,2,3],[4,5,6]])b = np.arange(0, 1.0, 0.1)c = np.sin(b)# c 使用了关键字参数 sin_arraynp.savez(\"out.npz\", a, b, sin_array = c)r = np.load(\"out.npz\") print(r.files) # 查看各个数组名称print(r[\"arr_0\"]) # 数组 aprint(r[\"arr_1\"]) # 数组 bprint(r[\"sin_array\"]) # 数组 csavetxt()和loadtxt()savetxt()函数是以简单的文本文件格式存储数据，对应的使用loadtxt()函数来获取数据。123456789np.loadtxt(FILENAME, dtype=int, delimiter=' ')np.savetxt(FILENAME, a, fmt=\"%d\", delimiter=\",\")# 参数delimiter可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等import numpy as np a=np.arange(0,10,0.5).reshape(4,-1)np.savetxt(\"out.txt\", a, fmt=\"%d\", delimiter=\",\") # 改为保存为整数，以逗号分隔b = np.loadtxt(\"out.txt\", dtype=int, delimiter=\",\") # load时也要指定为逗号分隔","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"14-线性代数","slug":"numpy教程/14-线性代数","date":"2020-05-25T16:37:14.000Z","updated":"2020-05-27T07:27:48.692Z","comments":true,"path":"numpy教程/14-线性代数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/14-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","excerpt":"","text":"NumPy 提供了线性代数函数库linalg，该库包含了线性代数所需的所有功能，可以看看下面的说明：函数描述dot两个数组的点积，即元素对应相乘vdot两个向量的点积inner两个数组的内积matmul两个数组的矩阵积determinant数组的行列式solve求解线性矩阵方程inv计算矩阵的乘法逆矩阵","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"13-矩阵库","slug":"numpy教程/13-矩阵库","date":"2020-05-25T16:36:15.000Z","updated":"2020-05-27T07:27:45.310Z","comments":true,"path":"numpy教程/13-矩阵库/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/13-%E7%9F%A9%E9%98%B5%E5%BA%93/","excerpt":"","text":"NumPy 中包含了一个矩阵库numpy.matlib，该模块中的函数返回的是一个矩阵，而不是ndarray对象。一个$m*n$的矩阵是一个由$m$行（row）$n$列（column）元素排列成的矩形阵列。矩阵里的元素可以是数字、符号或数学式。\\left\\{ \\begin{matrix} 1&2&3\\\\ 4&5&6\\\\ 7&8&9 \\end{matrix} \\right\\}matlib.empty()matlib.empty()函数返回一个新的矩阵，语法格式为：12345678910numpy.matlib.empty(shape, dtype, order)# shape: 定义新矩阵形状的整数或整数元组# Dtype: 可选，数据类型# order: C（行序优先） 或者 F（列序优先）import numpy.matlib import numpy as np print (np.matlib.empty((2,2)))# 填充为随机数据numpy.matlib.zeros()numpy.matlib.zeros()函数创建一个以 0 填充的矩阵。1print (np.matlib.ones((2,2)))numpy.matlib.eye()numpy.matlib.eye()函数返回一个矩阵，对角线元素为 1，其他位置为零。123456numpy.matlib.eye(n, M,k, dtype)# n: 返回矩阵的行数# M: 返回矩阵的列数，默认为 n# k: 对角线的索引# dtype: 数据类型print (np.matlib.eye(n = 3, M = 4, k = 0, dtype = float))numpy.matlib.identity()numpy.matlib.identity()函数返回给定大小的单位矩阵。单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。12# 大小为 5，类型位浮点型print (np.matlib.identity(5, dtype = float))numpy.matlib.rand()numpy.matlib.rand()函数创建一个给定大小的矩阵，数据是随机填充的。1print (np.matlib.rand(3,3))matrix与ndarray转换矩阵总是二维的，而ndarray是一个 n 维数组。两个对象都是可互换的。123i = np.matrix('1,2;3,4') j = np.asarray(i) k = np.asmatrix (j)","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"12-副本和视图","slug":"numpy教程/12-副本和视图","date":"2020-05-25T16:35:03.000Z","updated":"2020-05-27T07:27:42.471Z","comments":true,"path":"numpy教程/12-副本和视图/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/12-%E5%89%AF%E6%9C%AC%E5%92%8C%E8%A7%86%E5%9B%BE/","excerpt":"","text":"副本是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。视图是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。视图一般发生在：numpy 的切片操作返回原数据的视图。调用 ndarray 的 view() 函数产生一个视图。副本一般发生在：Python 序列的切片操作，调用deepCopy()函数。调用 ndarray 的 copy() 函数产生一个副本。无复制简单的赋值不会创建数组对象的副本。相反，它使用原始数组的相同id()来访问它。id()返回 Python 对象的通用标识符，类似于 C 中的指针。此外，一个数组的任何变化都反映在另一个数组上。例如，一个数组的形状改变也会改变另一个数组的形状。视图或浅拷贝ndarray.view()方会创建一个新的数组对象，该方法创建的新数组的维数更改不会更改原始数据的维数。副本或深拷贝ndarray.copy()函数创建一个副本。对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"11-排序、条件刷选函数","slug":"numpy教程/11-排序、条件刷选函数","date":"2020-05-25T16:33:52.000Z","updated":"2020-05-27T07:27:38.269Z","comments":true,"path":"numpy教程/11-排序、条件刷选函数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/11-%E6%8E%92%E5%BA%8F%E3%80%81%E6%9D%A1%E4%BB%B6%E5%88%B7%E9%80%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"NumPy 提供了多种排序的方法。这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。种类速度最坏情况工作空间稳定性quicksort 快速排序1O(n^2)0否mergesort 归并排序2O(n*log(n))~n/2是heapsort 堆排序3O(n*log(n))0否numpy.sort()numpy.sort()函数返回输入数组的排序副本。函数格式如下：12345678910111213141516171819# a: 要排序的数组# axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=0 按列排序，axis=1 按行排序# kind: 默认为'quicksort'（快速排序）# order: 如果数组包含字段，则是要排序的字段numpy.sort(a, axis, kind, order)# 实例import numpy as np a = np.array([[3,7],[9,1]]) print ('调用 sort() 函数：')print (np.sort(a))print ('按列排序：')print (np.sort(a, axis = 0))# 在 sort 函数中排序字段 dt = np.dtype([('name', 'S10'),('age', int)]) a = np.array([(\"raju\",21),(\"anil\",25),(\"ravi\", 17), (\"amar\",27)], dtype = dt) print ('按 name 排序：')print (np.sort(a, order = 'name'))numpy.argsort()numpy.argsort()函数返回的是数组值从小到大的索引值。1234567891011import numpy as np x = np.array([3, 1, 2]) print ('对 x 调用 argsort() 函数：')y = np.argsort(x) print (y)print ('以排序后的顺序重构原数组（从小到大排序）：')print (x[y])print ('使用循环重构原数组（从小到大排序）：')for i in y: print (x[i], end=\" \")numpy.lexsort()numpy.lexsort()用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取……这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。12345678910import numpy as np nm = ('raju','anil','ravi','amar') dv = ('f.y.', 's.y.', 's.y.', 'f.y.') ind = np.lexsort((dv,nm)) print ('调用 lexsort() 函数：') print (ind) print ('\\n') print ('使用这个索引来获取排序后的数据：') print ([nm[i] + \", \" + dv[i] for i in ind])其他函数函数描述msort(a)数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相等于 np.sort(a, axis=0)。sort_complex(a)对复数按照先实部后虚部的顺序进行排序。partition(a, kth[, axis, kind, order])指定一个数，对数组进行分区argpartition(a, kth[, axis, kind, order])可以通过关键字 kind 指定算法沿着指定轴对数组进行分区numpy.argmax()和 numpy.argmin()分别沿给定轴返回最大和最小元素的索引。numpy.nonzero()返回输入数组中非零元素的索引numpy.where()返回输入数组中满足给定条件的元素的索引numpy.extract()根据某个条件从数组中抽取元素，返回满条件的元素","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"10-统计函数","slug":"numpy教程/10-统计函数","date":"2020-05-25T16:31:45.000Z","updated":"2020-05-27T07:27:35.579Z","comments":true,"path":"numpy教程/10-统计函数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/10-%E7%BB%9F%E8%AE%A1%E5%87%BD%E6%95%B0/","excerpt":"","text":"NumPy 提供了很多统计函数，用于从数组中查找最小元素，最大元素，百分位标准差和方差等。计算最小值和最大值numpy.amin()用于计算数组中的元素沿指定轴的最小值。numpy.amax()用于计算数组中的元素沿指定轴的最大值。12345678910111213import numpy as np a = np.array([[3,7,5],[8,4,3],[2,4,9]]) print (np.amin(a,1))# 结果：[3 3 2]print (np.amin(a,0))# 结果：[2 4 3]print (np.amax(a))# 结果：9print (np.amax(a, axis = 0))# 结果：[8 7 9]numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。12345678910import numpy as np a = np.array([[3,7,5],[8,4,3],[2,4,9]]) print (np.ptp(a))# 结果：7print (np.ptp(a, axis = 1))# 结果：[4 5 7]print (np.ptp(a, axis = 0))# 结果：[6 3 6]百分位数百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数numpy.percentile()接受以下参数。1234numpy.percentile(a, q, axis)# a: 输入数组# q: 要计算的百分位数，在 0 ~ 100 之间# axis: 沿着它计算百分位数的轴首先明确百分位数：第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。1234567891011import numpy as np a = np.array([[10, 7, 4], [3, 2, 1]])# 50% 的分位数，就是 a 里排序之后的中位数print (np.percentile(a, 50)) # axis 为 0，在纵列上求print (np.percentile(a, 50, axis=0)) # axis 为 1，在横行上求print (np.percentile(a, 50, axis=1)) # 保持维度不变print (np.percentile(a, 50, axis=1, keepdims=True))中位数numpy.median()函数用于计算数组a中元素的中位数（中值）。12345678import numpy as np a = np.array([[30,65,70],[80,95,10],[50,90,60]]) print (np.median(a))# 沿轴 0 调用 median() 函数print (np.median(a, axis = 0))# 沿轴 1 调用 median() 函数print (np.median(a, axis = 1))算术平均值numpy.mean()函数返回数组中元素的算术平均值。如果提供了轴，则沿其计算。算术平均值是沿轴的元素的总和除以元素的数量。123456789import numpy as np a = np.array([[1,2,3],[3,4,5],[4,5,6]]) print ('调用 mean() 函数：')print (np.mean(a))print ('沿轴 0 调用 mean() 函数：')print (np.mean(a, axis = 0))print ('沿轴 1 调用 mean() 函数：')print (np.mean(a, axis = 1))加权平均值numpy.average()函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。该函数可以接受一个轴参数。如果没有指定轴，则数组会被展开。加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。即通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。123456789101112import numpy as np a = np.array([1,2,3,4]) print ('调用 average() 函数：')# 不指定权重时相当于 mean 函数print (np.average(a))# 权重数组wts = np.array([4,3,2,1]) print (np.average(a,weights = wts))# 如果 returned 参数设为 true，则返回权重的和 print ('权重的和：')print (np.average([1,2,3, 4],weights = [4,3,2,1], returned = True))标准差标准差是一组数据平均值分散程度的一种度量。标准差是方差的算术平方根。标准差公式如下：std=\\sqrt{mean((x-\\bar{x})^2)}123import numpy as np print (np.std([1,2,3,4]))方差统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即$mean((x-\\bar{x})^2)$。换句话说，标准差是方差的平方根。123import numpy as np print (np.var([1,2,3,4]))","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"09-算术函数","slug":"numpy教程/09-算数函数","date":"2020-05-25T16:31:01.000Z","updated":"2020-05-27T07:27:32.683Z","comments":true,"path":"numpy教程/09-算数函数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/09-%E7%AE%97%E6%95%B0%E5%87%BD%E6%95%B0/","excerpt":"","text":"简单的加减乘除NumPy 算术函数包含简单的加减乘除:add()，subtract()，multiply()和divide()。需要注意的是数组必须具有相同的形状或符合数组广播规则。12345678910111213141516import numpy as np a = np.arange(9, dtype = np.float_).reshape(3,3) b = np.array([10,10,10]) print ('两个数组相加：')print (np.add(a,b))print ('两个数组相减：')print (np.subtract(a,b))print ('两个数组相乘：')print (np.multiply(a,b))print ('两个数组相除：')print (np.divide(a,b)计算数组元素的倒数numpy.reciprocal()函数返回参数逐元素的倒数。如 1/4 倒数为 4/1。1234import numpy as np a = np.array([0.25, 1.33, 1, 100]) print (np.reciprocal(a))计算数组的幂numpy.power()函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。12345678910import numpy as np a = np.array([10,100,1000]) print (np.power(a,2))# 结果：[ 100 10000 1000000]b = np.array([1,2,3]) print (np.power(a,b))# 结果：[ 10 10000 1000000000]计算数组的余数numpy.mod()计算输入数组中相应元素的相除后的余数。 函数 numpy.remainder()也产生相同的结果。1234567import numpy as np a = np.array([10,20,30]) b = np.array([3,5,7]) print (np.mod(a,b))print (np.remainder(a,b))# 结果：[1 0 2]","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"08-数学函数","slug":"numpy教程/08-数学函数","date":"2020-05-25T16:23:55.000Z","updated":"2020-05-27T07:27:30.144Z","comments":true,"path":"numpy教程/08-数学函数/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/08-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/","excerpt":"","text":"NumPy 包含大量的各种数学运算的函数，包括三角函数，算术运算的函数，复数处理函数等。三角函数NumPy 提供了标准的三角函数：sin()、cos()、tan()。arcsin，arccos，和arctan函数返回给定角度的sin，cos和tan的反三角函数。这些函数的结果可以通过numpy.degrees()函数将弧度转换为角度。1234567891011121314151617181920212223242526272829303132333435import numpy as np a = np.array([0,30,45,60,90]) print ('含有正弦值的数组：')sin = np.sin(a*np.pi/180) print (sin)print ('\\n')print ('计算角度的反正弦，返回值以弧度为单位：')inv = np.arcsin(sin) print (inv)print ('\\n')print ('通过转化为角度制来检查结果：')print (np.degrees(inv))print ('\\n')print ('arccos 和 arctan 函数行为类似：')cos = np.cos(a*np.pi/180) print (cos)print ('\\n')print ('反余弦：')inv = np.arccos(cos) print (inv)print ('\\n')print ('角度制单位：')print (np.degrees(inv))print ('\\n')print ('tan 函数：')tan = np.tan(a*np.pi/180) print (tan)print ('\\n')print ('反正切：')inv = np.arctan(tan) print (inv)print ('\\n')print ('角度制单位：')print (np.degrees(inv))舍入函数numpy.around()函数返回指定数字的四舍五入值。12345678910# 格式# a:数组；decimals:舍入的小数位数，默认值为0。如果为负，整数将四舍五入到小数点左侧位置numpy.around(a,decimals)# 实例import numpy as npa = np.array([1.0,5.55, 123, 0.567, 25.532])print (np.around(a))print (np.around(a, decimals = 1))print (np.around(a, decimals = -1))numpy.floor()返回数字的下舍整数。12345import numpy as np a = np.array([-1.7, 1.5, -0.2, 0.6, 10])print (np.floor(a))# 修改后的数组：[-2. 1. -1. 0. 10.]numpy.ceil()返回数字的上入整数。12345import numpy as np a = np.array([-1.7, 1.5, -0.2, 0.6, 10]) print (np.ceil(a))# 修改后的数组：[-1. 2. -0. 1. 10.]","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"07-位运算","slug":"numpy教程/07-位运算","date":"2020-05-25T16:23:12.000Z","updated":"2020-05-27T07:27:26.723Z","comments":true,"path":"numpy教程/07-位运算/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/07-%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"NumPy 位运算bitwise_开头的函数就是位运算函数。NumPy 位运算包括以下几个函数：函数描述bitwise_and对数组元素执行位与操作bitwise_or对数组元素执行位或操作invert按位取反left_shift向左移动二进制标志的位right_shift向右移动二进制表示的位注：也可以使用&amp;、~、|和^等操作符进行计算bitwise_andbitwise_and()函数对数组中整数的二进制形式执行位与运算。与运算只要有一个0结果就为0,只有两个1的情况下结果才是1。123456789import numpy as np print ('13 和 17 的二进制形式：')a,b = 13,17print (bin(a), bin(b))print ('\\n') print ('13 和 17 的位与：')print (np.bitwise_and(13, 17))bitwise_orbitwise_or()函数对数组中整数的二进制形式执行位或运算。或运算只要有一个1结果就为1,只有两个0的情况下结果才是0。12345678import numpy as np a,b = 13,17 print ('13 和 17 的二进制形式：')print (bin(a), bin(b)) print ('13 和 17 的位或：')print (np.bitwise_or(13, 17))invertinvert()函数对数组中整数进行位取反运算，即0变成1，1变成0。对于有符号整数，取该二进制数的补码，然后+1。二进制数，最高位为0表示正数，最高位为1表示负数。看看~1的计算步骤：将1(这里叫：原码)转二进制 ＝ 00000001按位取反 ＝ 11111110发现符号位(即最高位)为1(表示负数)，将除符号位之外的其他数字取反 ＝ 10000001末位加1取其补码 ＝ 10000010转换回十进制 ＝ -212345678910111213import numpy as np print ('13 的位反转，其中 ndarray 的 dtype 是 uint8：')print (np.invert(np.array([13], dtype = np.uint8)))print ('\\n')# 比较 13 和 242 的二进制表示，我们发现了位的反转 print ('13 的二进制表示：')print (np.binary_repr(13, width = 8))print ('\\n') print ('242 的二进制表示：')print (np.binary_repr(242, width = 8))left_shift 和 right_shiftleft_shift()函数将数组元素的二进制形式向左移动到指定位置，右侧附加相等数量的0。right_shift()函数将数组元素的二进制形式向右移动到指定位置，左侧附加相等数量的0。123456# 左移一位相当于乘2，右移一位相当于除以2print ('将 10 左移两位：')print (np.left_shift(10,2))print ('将 4 右移两位：')print (np.right_shift(4,2))","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"06-数组操作","slug":"numpy教程/06-数组操作","date":"2020-05-25T16:21:58.000Z","updated":"2020-05-27T07:27:22.815Z","comments":true,"path":"numpy教程/06-数组操作/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/06-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"NumPy 数组操作修改数组形状函数描述reshape不改变数据的条件下修改形状flat数组元素迭代器flatten返回一份数组拷贝，对拷贝所作的修改不会影响原始数组ravel返回展开数组12345678910111213141516171819202122# numpy.reshape函数可以在不改变数据的条件下修改形状,，格式如下：# arr:要修改形状的数组；newshape:整数或者整数数组，新形状应该兼容原有形状；order:C-按行，F-按列，A-原顺序，k-在内存中的顺序numpy.reshape(arr, newshape,order='C')a = np.arange(8)b = a.reshape(4,2)# numpy.ndarray.flat 是一个数组元素迭代器a = np.arange(9).reshape(3,3)#对数组中每个元素都进行处理，可以使用flat属性，该属性是一个数组元素迭代器：for element in a.flat: print (element)# numpy.ndarray.flatten返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，格式如下：ndarray.flatten(order='C')a = np.arange(8).reshape(2,4)b = a.flatten(order='F')# numpy.ravel()展平的数组元素，顺序通常是\"C风格\"，返回的是数组视图（view，有点类似C/C++引用reference的意味），修改会影响原始数组。# 该函数接收两个参数：numpy.ravel(a, order='C')a = np.arange(8).reshape(2,4)a.ravel(order = 'F')翻转数组函数描述transpose转置，对换数组的维度ndarray.T转置rollaxis向后滚动指定的轴swapaxes对换数组的两个轴1234567891011121314151617181920# numpy.transpose 函数用于对换数组的维度，格式如下：# arr：要操作的数组；axes：整数列表，对应维度，通常所有维度都会对换numpy.transpose(arr, axes)a = np.arange(12).reshape(3,4)# 下面两条语句效果一样np.transpose(a)a.T# numpy.rollaxis函数向后滚动特定的轴到一个特定位置，格式如下：# arr：数组;axis：要向后滚动的轴，其它轴的相对位置不会改变;start：默认为零，表示完整的滚动。会滚动到特定位置。numpy.rollaxis(arr, axis, start)# 创建三维的ndarraya = np.arange(8).reshape(2,2,2)np.rollaxis(a,2,1)# numpy.swapaxes函数用于交换数组的两个轴，格式如下：numpy.swapaxes(arr, axis1, axis2)a = np.arange(8).reshape(2,2,2)# 现在交换轴 0（深度方向）到轴 2（宽度方向）np.swapaxes(a, 2, 0)修改数组维度维度描述broadcast产生模仿广播的对象broadcast_to将数组广播到新形状expand_dims扩展数组的形状squeeze从数组的形状删除一维条目1234567891011121314151617181920# numpy.broadcast用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。x = np.array([[1], [2], [3]])y = np.array([4, 5, 6])# 对 y 广播 xb = np.broadcast(x,y) # numpy.broadcast_to函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。numpy.broadcast_to(array, shape, subok)a = np.arange(4).reshape(1,4)np.broadcast_to(a,(4,4))# numpy.expand_dims函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下:numpy.expand_dims(arr, axis)x = np.array(([1,2],[3,4]))y = np.expand_dims(x, axis = 0)# numpy.squeeze函数从给定数组的形状中删除一维的条目，函数格式如下：numpy.squeeze(arr, axis)x = np.arange(9).reshape(1,3,3)y = np.squeeze(x)连接数组函数描述concatenate连接沿现有轴的数组序列stack沿着新的轴加入一系列数组hstack水平堆叠序列中的数组（列方向）vstack竖直堆叠序列中的数组（行方向）12345678910111213141516# numpy.concatenate函数用于沿指定轴连接相同形状的两个或多个数组，格式如下：numpy.concatenate((a1, a2, ...), axis)a = np.array([[1,2],[3,4]])b = np.array([[5,6],[7,8]])np.concatenate((a,b),axis = 1)# numpy.stack 函数用于沿新轴连接数组序列，格式如下：numpy.stack(arrays, axis)a = np.array([[1,2],[3,4]])b = np.array([[5,6],[7,8]])np.stack((a,b),1)# numpy.hstack是numpy.stack函数的变体，它通过水平堆叠来生成数组# numpy.vstack是numpy.stack函数的变体，它通过垂直堆叠来生成数组np.hstack((a,b))np.vstack((a,b))分隔数组函数数组及操作split将一个数组分割为多个子数组hsplit将一个数组水平分割为多个子数组（按列）vsplit将一个数组垂直分割为多个子数组（按行）12345678910111213141516171819# numpy.split函数沿特定的轴将数组分割为子数组，格式如下：# ary：被分割的数组# indices_or_sections：果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭# axis：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分numpy.split(ary, indices_or_sections, axis)a = np.arange(9)# 将数组分为三个大小相等的子数组b = np.split(a,3)# 将数组在一维数组中表明的位置分割b = np.split(a,[4,7])# numpy.hsplit函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组harr = np.floor(10 * np.random.random((2, 6)))np.hsplit(harr, 3)# numpy.vsplit沿着垂直轴分割，其分割方式与hsplit用法相同a = np.arange(16).reshape(4,4)b = np.vsplit(a,2)数组元素的添加与删除函数元素及描述resize返回指定形状的数组append将值添加到数组末尾insert沿指定轴将值添加到指定下标之前delete删除某个轴的子数组，并返回删除后的新数组unique查找数组内的唯一元素123456789101112131415161718192021222324252627282930313233343536373839404142# numpy.resize 函数返回指定大小的新数组# 如果新数组大小大于原始大小，则包含原始数组中的元素的副本# arr：要修改大小的数组;shape：返回数组的新形状numpy.resize(arr, shape)a = np.array([[1,2,3],[4,5,6]])b = np.resize(a, (3,2))# numpy.append函数在数组的末尾添加值# 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError# append 函数返回的始终是一个一维数组# arr：输入数组;values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）# axis：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）numpy.append(arr, values, axis=None)a = np.array([[1,2,3],[4,5,6]])b = np.append(a, [7,8,9])# numpy.insert函数在给定索引之前，沿给定轴在输入数组中插入值# 如果值的类型转换为要插入，则它与输入数组不同。插入没有原地的，函数会返回一个新数组。此外，如果未提供轴，则输入数组会被展开。numpy.insert(arr, obj, values, axis)a = np.array([[1,2],[3,4],[5,6]])# 未传递 Axis 参数。 在插入之前输入数组会被展开np.insert(a,3,[11,12])# 传递了 Axis 参数。 会广播值数组来配输入数组np.insert(a,1,[11],axis = 0)# numpy.delete函数返回从输入数组中删除指定子数组的新数组。与 insert()函数的情况一样，如果未提供轴参数，则输入数组将展开。Numpy.delete(arr, obj, axis)a = np.arange(12).reshape(3,4)# 删除第二列np.delete(a,1,axis = 1)# numpy.unique函数用于去除数组中的重复元素# arr：输入数组，如果不是一维数组则会展开# return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储# return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储# return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数numpy.unique(arr, return_index, return_inverse, return_counts)a = np.array([5,2,6,2,7,5,6,8,2,9])# 去重值和去重数组的索引数组u,indices = np.unique(a, return_index = True)# 返回去重元素的重复数量u,indices = np.unique(a,return_counts = True)","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"05-广播与迭代","slug":"numpy教程/05-广播与迭代","date":"2020-05-25T16:04:37.000Z","updated":"2020-05-27T07:27:19.762Z","comments":true,"path":"numpy教程/05-广播与迭代/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/05-%E5%B9%BF%E6%92%AD%E4%B8%8E%E8%BF%AD%E4%BB%A3/","excerpt":"","text":"NumPy 广播（Broadcast）广播(Broadcast)是numpy对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。如果两个数组 a 和 b 形状相同，即满足a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。广播的规则：让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。输出数组的形状是输入数组形状的各个维度上的最大值。如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足数组拥有相同形状。当前维度的值相等。当前维度的值有一个是 1。若条件不满足，抛出ValueError: frames are not aligned异常。12345678import numpy as np # 4x3 的二维数组与长为 3 的一维数组相加，等效于把数组 b 在二维上重复 4 次再运算a = np.array([[ 0, 0, 0], [10,10,10], [20,20,20], [30,30,30]])b = np.array([1,2,3])print(a + b)NumPy 迭代数组NumPy迭代器对象numpy.nditer提供了一种灵活访问一个或者多个数组元素的方式。迭代器最基本的任务的可以完成对数组元素的访问。12345678910# 用 arange() 函数创建一个 2X3 数组，并使用 nditer 对它进行迭代。import numpy as npa = np.arange(6).reshape(2,3)print ('原始数组是：')print (a)print ('\\n')print ('迭代输出元素：')for x in np.nditer(a): print (x, end=\", \" )print ('\\n')以上实例不是使用标准C或者Fortran顺序，选择的顺序是和数组内存布局一致的，这样做是为了提升访问的效率，默认是行序优先（row-major order，或者说是C-order）。这反映了默认情况下只需访问每个元素，而无需考虑其特定顺序。控制遍历顺序for x in np.nditer(a, order=&#39;F&#39;):Fortran order，即是列序优先；for x in np.nditer(a.T, order=&#39;C&#39;):C order，即是行序优先；修改数组中元素的值nditer对象有另一个可选参数op_flags。 默认情况下，nditer将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。12345678910import numpy as npa = np.arange(0,60,5) a = a.reshape(3,4) print ('原始数组是：')print (a)print ('\\n')for x in np.nditer(a, op_flags=['readwrite']): x[...]=2*x print ('修改后的数组是：')print (a)使用外部循环nditer类的构造器拥有flags参数，它可以接受下列值：参数描述c_index可以跟踪C顺序的索引f_index可以跟踪Fortran顺序的索引multi-index每次迭代可以跟踪一种索引类型external_loop给出的值是具有多个值的一维数组，而不是零维数组123456789import numpy as np a = np.arange(0,60,5) a = a.reshape(3,4) print ('原始数组是：')print (a)print ('\\n')print ('修改后的数组是：')for x in np.nditer(a, flags = ['external_loop'], order = 'F'): print (x, end=\", \" )广播迭代如果两个数组是可广播的，nditer组合对象能够同时迭代它们。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。1234567891011121314import numpy as np a = np.arange(0,60,5) a = a.reshape(3,4) print ('第一个数组为：')print (a)print ('\\n')print ('第二个数组为：')b = np.array([1, 2, 3, 4], dtype = int) print (b)print ('\\n')print ('修改后的数组为：')for x,y in np.nditer([a,b]): print (\"%d:%d\" % (x,y), end=\", \" )","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"04-切片与索引","slug":"numpy教程/04-切片与索引","date":"2020-05-25T16:03:19.000Z","updated":"2020-05-27T07:27:14.782Z","comments":true,"path":"numpy教程/04-切片与索引/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/04-%E5%88%87%E7%89%87%E4%B8%8E%E7%B4%A2%E5%BC%95/","excerpt":"","text":"NumPy 切片和索引ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中list的切片操作一样。ndarray数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的slice函数，并设置start, stop及step参数进行，从原数组中切割出一个新数组。我们可以通过冒号分隔切片参数start:stop:step来进行切片操作：12345678import numpy as np a = np.arange(10)# 从索引 2 开始到索引 7 停止，间隔为2s = slice(2,7,2) print (a[s])# 从索引 2 开始到索引 7 停止，间隔为 2b = a[2:7:2]冒号:的解释(重点)如果只放置一个参数，如[2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如[2:7]，那么则提取两个索引(不包括停止索引)之间的项。1234567import numpy as npa = np.arange(10) # [0 1 2 3 4 5 6 7 8 9]b = a[5] # 5a[2:] # [2 3 4 5 6 7 8 9]a[2:5] # [2 3 4]a = np.array([[1,2,3],[3,4,5],[4,5,6]])a[1:] # [[3 4 5] [4 5 6]]切片还可以包括省略号…，来使选择元组的长度与数组的维度相同。如果在行位置使用省略号，它将返回包含行中元素的ndarray。1234a = np.array([[1,2,3],[3,4,5],[4,5,6]])print (a[...,1]) # 第2列元素print (a[1,...]) # 第2行元素print (a[...,1:]) # 第2列及剩下的所有元素NumPy 高级索引NumPy比一般的 Python 序列提供更多的索引方式。除了之前看到的用整数和切片的索引外，数组可以由整数数组索引、布尔索引及花式索引。整数数组索引以下实例获取数组中(0,0)，(1,1)和(2,0)位置处的元素。1234567import numpy as np x = np.array([[1, 2], [3, 4], [5, 6]]) y = x[[0,1,2], [0,1,0]] print (y)# 输出结果# [1 4 5]以下实例获取了 4X3 数组中的四个角的元素。 行索引是 [0,0] 和 [3,3]，而列索引是 [0,2] 和 [0,2]。12345678910111213141516import numpy as np x = np.array([[ 0, 1, 2],[ 3, 4, 5],[ 6, 7, 8],[ 9, 10, 11]]) print ('我们的数组是：' )print (x)print ('\\n')rows = np.array([[0,0],[3,3]]) cols = np.array([[0,2],[0,2]]) y = x[rows,cols] print ('这个数组的四个角元素是：')print (y)''' 结果如下：[[ 0, 2], [ 9, 11]]'''可以借助切片:或…与索引数组组合。如下面例子：1234567import numpy as np a = np.array([[1,2,3], [4,5,6],[7,8,9]])b = a[1:3, 1:3] # 取2、3行的第2、3列c = a[1:3,[1,2]] # 取2、3行的第2和3个元素d = a[...,1:] # 取第2列和后面的所有列布尔索引我们可以通过一个布尔数组来索引目标数组。布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。123456789101112131415import numpy as np # 获取大于 5 的元素x = np.array([[ 0, 1, 2],[ 3, 4, 5],[ 6, 7, 8],[ 9, 10, 11]]) print ('我们的数组是：')print (x)print ('\\n')# 现在我们会打印出大于 5 的元素 print ('大于 5 的元素是：')print (x[x &gt; 5])# 使用了 ~（取补运算符）来过滤 NaNa = np.array([np.nan, 1,2,np.nan,3,4,5]) print (a[~np.isnan(a)])# 从数组中过滤掉非复数元素a = np.array([1, 2+6j, 5, 3.5+5j])a[np.iscomplex(a)]花式索引花式索引指的是利用整数数组进行索引。花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。花式索引跟切片不一样，它总是将数据复制到新数组中。1234567891011import numpy as np # 传入顺序索引数组x=np.arange(32).reshape((8,4))print (x[[4,2,1,7]])# 传入倒序索引数组x=np.arange(32).reshape((8,4))print (x[[-4,-2,-1,-7]])# 传入多个索引数组（要使用np.ix_）x=np.arange(32).reshape((8,4))print (x[np.ix_([1,5,7,2],[0,3,1,2])])","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"03-数组","slug":"numpy教程/03-数组","date":"2020-05-25T16:01:51.000Z","updated":"2020-05-27T07:27:11.193Z","comments":true,"path":"numpy教程/03-数组/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/03-%E6%95%B0%E7%BB%84/","excerpt":"","text":"NumPy数组属性NumPy 数组的维数称为秩（rank），一维数组的秩为 1，二维数组的秩为 2，以此类推。在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作。NumPy 的数组中比较重要ndarray对象属性有：|属性|说明||—-|—-||ndarray.ndim|秩，即轴的数量或维度的数量||ndarray.shape|数组的维度，对于矩阵，n行m列||ndarray.size|数组元素的总个数,n*m||ndarray.dtype|ndarray对象的元素类型||ndarray.itemsize|ndarray对象中每个元素的大小，以字节为单位||ndarray.flags|ndarray对象的内部信息||ndarray.real|ndarray元素的实部||ndarray.imag|ndarray元素的虚部||ndarray.data|包含实际数组元素的缓冲区，一般通过数组索引获取元素，所以不需要使用这个属性|NumPy创建数组ndarray数组除了可以使用底层ndarray构造器来创建外，也可以通过以下几种方式来创建。numpy.emptynumpy.empty方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：123456789# 格式numpy.empty(shape, dtype=float, order='C')# 实例x = numpy.empty([3,2],dtype=int)''' 结果如下：里面的数据将会随机生成[[ 5.11798224e-307 3.44897992e-307] [ 1.24610383e-306 1.37961709e-306] [ 1.29057883e-306 1.24610927e-306]]'''参数说明：|参数|说明||—-|—-||shape|数组形状||dtype|数据类型，可选||order|有’C’和’F’两个选项，分别代表行优先和列优先，在计算机内存中存储元素的顺序|注意 数组元素为随机值，因为它们未初始化numpy.zeros创建指定大小的数组，数组元素以 0 来填充：1234567891011# 格式numpy.zeros(shape, dtype=float, order='C')# 实例# 默认为浮点数x = numpy.zeros(5) # 1*5的矩阵y = numpy.zeros([2,3],dtype=np.int) # 2*3的矩阵''' 结果如下:[ 0. 0. 0. 0. 0.][[ 0. 0. 0.] [ 0. 0. 0.]]'''numpy.ones创建指定形状的数组，数组元素以 1 来填充：12345678# 格式numpy.ones(shape, dtype = None, order = 'C')# 实例x = np.ones([2,2], dtype = int)''' 结果如下：[[1 1] [1 1]]'''NumPy从已有的数组创建数组numpy.asarray12345# 格式numpy.asarray(a, dtype = None, order = None)# 实例x = [[1,2,3],[4,5,6]]a = numpy.asarray(x)参数说明参数描述a任意形式的输入参数，可以是列表、元组、多维数组等dtype数据类型，可选order可选，有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。numpy.frombuffernumpy.frombuffer用于实现动态数组。numpy.frombuffer接受buffer输入参数，以流的形式读入转化成ndarray 对象。123456# 格式numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)# 实例s = b'Hello World' a = numpy.frombuffer(s, dtype = 'S1') print (a)注意 buffer是字符串的时候，Python3 默认str是Unicode类型，所以要转成bytestring在原str前加上 b。参数说明参数说明buffer可以是任意对象，会以流的形式读入。dtype可选，数据类型count读取的数据数量，默认为-1，读取所有数据offset读取的起始位置，默认为0numpy.fromiternumpy.fromiter方法从可迭代对象中建立 ndarray`对象，返回一维数组。123456789# 格式numpy.fromiter(iterable, dtype, count=-1)# 实例# 使用 range 函数创建列表对象 list=range(5)it=iter(list) # 使用迭代器创建 ndarray x=numpy.fromiter(it, dtype=float)参数说明iterable可迭代对象dtype返回的数组的数据类型count读取的数据量，默认为-1，读取所有数据NumPy 从数值范围创建数组numpy.arangenumpy包中的使用arange函数创建数值范围并返回ndarray对象，函数格式如下：12345678numpy.arange(start, stop, step, dtype)# 实例：生成 0 到 5 的数组x = numpy.arange(5)# 指定数据类型x = numpy.arange(5, dtype=float)# 设置起始值、终止值和步长x = numpy.arange(10, 20, 2)根据start与stop指定的范围以及step 设定的步长，生成一个ndarray。参数说明：|参数|说明||—-|—-||start|起始值，默认为0||stop|终止值（不包含）||step|步长，默认为1||dtype|返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型|numpy.linspacenumpy.linspace函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下：12345678910numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)# 实例# 设置起始点为 1 ，终止点为 10，数列个数为 10a = numpy.linspace(1,10,10)''' 结果如下[ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10.]'''# 设置10个全是1的数列a = numpy.linspace(1,1,10)参数说明：参数说明start起始值，默认为0stop终止值，如果endpoint为true，该值包含在数列中num要生成的等步长的样本数量，默认为50endpoint是否包含终止值，默认为Trueretstep如果为True，生成的数组中会显示间距，反之不显示dtypendarray的数据类型numpy.logspacenumpy.logspace函数用于创建一个于等比数列$d_i=base^i$。格式如下：1234567numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)# 实例# 默认底数是 10a = numpy.logspace(1.0,2.0,num=10)# 设置底数是2a = numpy.logspace(0,9,10,base=2)参数描述start序列的起始值为：base**startstop序列终止值为：base**stop。如果endpoint为true，该值包含在序列中num要生成的等步长的样本数量，默认为50endpoint是否包含终止值，默认为Truebase对数log的底数dtypendarray的数据类型","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"02-数据对象","slug":"numpy教程/02-数据对象","date":"2020-05-25T16:01:10.000Z","updated":"2020-05-27T07:26:32.491Z","comments":true,"path":"numpy教程/02-数据对象/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/02-%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"Numpy数据类型numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型。名称描述bool_布尔型数据类型（True或者False）int8/16/32/64整数unit8/16/32/64无符号整数float16/32/64半/单/双精度浮点数complex64/128复数numpy 的数值类型实际上是dtype对象的实例，并对应唯一的字符，包括np.bool_，np.int32，np.float32等等。数据类型对象(dtype)数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：数据的类型（整数，浮点数或者Python对象）数据的大小（例如整数用多少字节存储）数据的字节顺序（小端法或大端法）在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分如果数据类型是子数组，它的形状和数据类型字节顺序是通过对数据类型预先设定&lt;或&gt;来决定的。&lt;意味着小端法（最小值存储在最小的地址，即低位放前面）。&gt;意味着大端法（最重要的字节存储在最小的地址，即高位组放在最前面）。dtype对象是使用以下语法构造的：1numpy.dtype(object, align, copy)object-要转换为的数据类型对象align-如果为true,填充字段使其类似C的结构体copy-复制dtype对象，如果为false，则是内置数据类型对象的引用","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"01-numpy导论","slug":"numpy教程/01-numpy导论","date":"2020-05-25T15:24:43.000Z","updated":"2020-05-27T07:25:34.154Z","comments":true,"path":"numpy教程/01-numpy导论/","link":"","permalink":"https://hengxincheung.github.io/numpy%E6%95%99%E7%A8%8B/01-numpy%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"什么是 NumPyNumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。NumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含：一个强大的 $N$ 维数组对象ndarray广播功能函数整合 C/C++/Fortran 代码的工具线性代数、傅里叶变换、随机数生成等功能NumPy Ndarray对象NumPy 最重要的一个特点是其N维数组对象ndarray，它是一系列同类型数据的集合，以0下标为开始进行集合中元素的索引。ndarray对象是用于存放同类型元素的多维数组。ndarray中的每个元素在内存中都有相同存储大小的区域。ndarray内部由以下内容组成：一个指向数据（内存或内存映射文件中的一块数据）的指针。数据类型或dtype，描述在数组中的固定大小值的格子。一个表示数组形状（shape）的元组，表示各维度大小的元组。一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数。跨度可以是负数，这样会使数组在内存中后向移动，切片中obj[::-1]或obj[:,::-1]就是如此。创建ndarray对象1numpy.array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)参数说明:名称描述object数组或嵌套的数列dtype数据元素的数据类型，可选copy对象是否需要复制，可选order创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）subok默认返回一个与基本类型一致的数组ndmin指定生成数组的最小维度下面给出示例代码创建实例：123import numpy as npa = np.array([[1,2,3],[4,5,6]])b = np.array([1,2,3],dtype=complex,ndmin=2)ndarray对象由计算机内存的连续一维部分组成，并结合索引模式，将每个元素映射到内存块中的一个位置。内存块以行顺序(C样式)或列顺序(FORTRAN或MatLab风格，即前述的F样式)来保存元素。","categories":[{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"}]},{"title":"06-访问权限控制","slug":"Java编程思想/06-访问权限控制","date":"2020-05-25T15:15:28.000Z","updated":"2020-05-27T07:24:19.015Z","comments":true,"path":"Java编程思想/06-访问权限控制/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/06-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/","excerpt":"","text":"访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关。重构即重写代码，以使它更可读、更易理解、更高效，并因此而更具可维护性。但在这种修改和完善代码的愿景之下，也存在着巨大的压力。第一是资源（主要指时间、开发效率）浪费，二是客户端程序员需要你的代码在某些方面（即调用的接口方法）保持不变。因此你想改变代码，而他们却想让代码保持不变。这对于类库（library）而言尤其重要。为了解决这个问题，Java提供了访问权限修饰词，以供类库开发人员向客户端程序员指明哪些是可用的，哪些不可用。访问权限修饰词等级从权限最大到权限最小依次为：publicprotected包访问权限（默认不加访问权限关键词）private你会尽可能将一切方法都定为private，而仅向客户端程序员公开你愿意让他们使用的方法。对于如何将构件捆绑到一个内聚的类库单元的问题，Java用关键字package加以控制，而访问权限会因为类是否存在于相同的包中受到影响。包：库单元包内包含有一组类，它们在单一的名字空间之下被组织在了一起。例如，在Java标准发布中有一个工具库，它被组织在java.util名字空间之下。java.util中存在有一个叫ArrayList的类，那么使用ArrayList类的一种方式是使用其全限定名字:java.util.ArrayList。1java.util.ArrayList list = new java.util.ArrayList();这会使得程序变得十分冗长，因此Java提供了import关键字帮助我们去简化。使用import关键字的意思是将全限定名字与简单名字(simple-name)做一个绑定，因此可以下面的代码编写中使用简单名字去替代全限定名字。123456import java.util.ArrayList;public class Test&#123; public static main(String[] args)&#123; ArrayList list = new ArrayList(); &#125;&#125;但是这样做，java.util中的其他类仍旧是不可用简单名字的。要想导入其中所有的类，只需要使用*，如import java.util.*。但个人并不推荐这种方式，应该是使用一个类并导入其对应的全限定名字，这样会使程序更稳健快速（因为在不同的名字空间下有许多相同的类名）。我们之所以要导入，就是要提供一个管理名字空间的机制。所有类成员的名称都是彼此隔离的。当编写一个Java源文件时，此文件通常被称为编译单元（或转译单元）。每个编译单元都必须有一个后缀名.java，而在编译单元中最多可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，不包括后缀名.java）。每个编译单元只能有一个public类，否则编译器会提示出错。如果在编译单元之中还有其他额外的类的话，那么在包之外的世界是无法看见这些类的（因为不加关键字默认是包访问权限），它们主要是为主public类提供支持。代码组织当编译一个.java文件时，在.java文件中的每个类都会有一个输出文件，而该输出文件的名称与每个类的名称相同，只是多了一个后缀名.class。一般来说，编译型语言的编译流程如下：对于编译器根据编译单元产生一个中间文件（通常是obj文件），然后再将中间文件通过链接器（用以创建一个可执行文件）或类库产生器（librarian，用以创建一个类库）产生的其他同类文件捆绑起来。但这并不是Java的工作方式。Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR）的.class文件。Java解释器负责这些文件的查找、装载和解释。类库实际上是一组类文件。其中每个文件都有一个public类，一人任意数量的非public类。因此每个文件都有一个构件，如果希望这些构件从属于同一个群组，就可以使用关键字package。package语句必须是文件除注释以外的第一句程序代码。package和import关键字允许你做的是，将单一的全局名字空间分割开，使得无论多少人使用Internet和Java开始编写类，都不会出现名称冲突的情况。创建独一无二的包名一种合乎逻辑的做法就是将特定包的所有.class文件都置于一个目录下。也就是说，利用操作系统的层次化的文件结构来解决混乱问题。将所有的同一类文件收入一个子目录还可以解决另外两个问题：怎样创建独一无二的名称怎么查找有可能隐藏于目录结构中某处的类这些任务是通过将.class文件所在的路径位置编码成package的名称来实现的。Java解释器的运行过程如下：首先找到环境变量CLASSPATH；CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，以从CLASSPATH跟中产生一个目录名称。得到的路径会与CLASSPATH的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类名称相关的.class文件。定制工具库现在可以创建自己的工具库来减少或消除重复的程序代码，并可以使用一个更具可读性的静态import语句来导入：123456package cn.hengxin.utilpublic class Print&#123; public static void print(Object obj)&#123; System.out.println(obj); &#125;&#125;123456import cn.hengxin.util.Printpublic class PrintTest&#123; public static void main(String[] args)&#123; Print(\"Available from now on!\"); &#125;&#125;用import改变行为Java没有C的条件编译功能，该功能可以使你不必更改任何程序代码，就能切换开关并产生不同的行为。Java去掉功能的原因可能是因为C在绝大多数情况下是用此功能来解决跨平台问题，即程序代码的不同部分是根据不同的平台来编译。由于Java本身可以自动跨越不同的平台，因此这个功能对Java而言是没有必要的。Java访问权限修饰词包访问权限默认访问权限没有任何关键字，但通常是指包访问权限（或friendly），这意味着当前包的所有其他类对那个成员都有访问权限，但对于这个包之外的所有类，这个成员却是private。包访问权限允许将包内所有相关的类组合起来，以使它们彼此之间可以轻松地相互作用。public：接口访问权限使用关键字public就意味着之后紧跟的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。private：你无法访问关键字private的意思是，除了包含该成员的类之外，其他任何类都无法访问这个成员，等于说是自己隔离了自己。private的使用是十分重要的，在多线程环境下更是如此。任何可以肯定是该类的一个“助手”都可以把它指定为private，以确保不会在包内的其他地方误用它，于是也就防止了你会去改变或删除这个方法。protected：继承访问权限关键字protected处理的是继承的概念，通过继承可以利用一个现有类（称之为基类），然后将新成员添加到该现有类中而不必碰现有类，还可以改变该类的现有成员的行为。接口和实现访问权限的控制常被称为是具体实现的隐藏。封装常被认为是：把数据和方法包装进类中，以及具体实现的隐藏。其结果是一个同时带有特征和行为的数据类型。访问权限控制将边界划在了数据类型内部：设定客户端程序员可以使用和不可以使用的界限将接口和具体实现进行分离类的访问权限在Java中，访问权限修饰词也可以用于确定库中的哪些类对于该库的使用者是可用的。如果希望某个类可以为某个客户端程序员所用，就可以通过把关键字public作用在整个类的定义来达到目的。为了控制某个类的访问权限，**修饰词必须出现在关键字class之前。额外的限制：每个编译单元（文件）都只能有一个public类public类的名称必须完全与编译单元的文件名相匹配，包括大小写类即不可以是private也不可以是protected的。所以对于类的访问权限，仅有两个选择：包访问权限或者是public。如果不希望其他任何人对类拥有访问权限，可以将所有构造器都指定为private。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"05-初始化与清理","slug":"Java编程思想/05-初始化与清理","date":"2020-05-25T15:13:29.000Z","updated":"2020-05-27T07:24:10.247Z","comments":true,"path":"Java编程思想/05-初始化与清理/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/05-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/","excerpt":"","text":"随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。初始化（initialize）和清理（cleanup）正是涉及安全的两个问题。许多C程序的错误都源于程序员忘记初始化变量。清理也是一个特殊问题，当使用完一个元素时，容易把它忘掉，以至于这个元素占用的资源一直得不到释放，结果是计算机资源（特别是内存）用尽。C++引入了构造器（constructor）的概念，这是一个在创建对象时被自动调用的特殊方法。Java也采用了构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。用构造器确保初始化在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果类具有构造器，Java就会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。考虑到编译器会在初始化期间自动调用构造器，构造器采用与类相同的名称。假设我们拥有以下这样一个类：12345class Rock&#123; Rock()&#123; System.out.println(\"I'm Rock!\"); &#125;&#125;现在，在创建对象时new Rock()，将会为对象分配存储空间，并调用相应的构造器。这就确保了在你能操作对象之前，它已经被恰当地初始化了。注意：构造器也是一个方法，但是这个方法与其他方法不一样的地方在于，不需要为其声明任何返回类型。不接受任何参数的构造器叫做默认构造器，Java文档中通常使用术语无参构造器。和其他方法一样，构造器也能带有形式参数，以便指定如何创建对象。1234567891011class Speaker&#123; // 这是无参构造器 Speaker()&#123; System.out.println(\"Sorry, I don't know who you are!\"); &#125; // 这是有参构造器 Speaker(String name)&#123; System.out.println(\"Hello\" + name + \"!\"); &#125;&#125;从概念上讲，“初始化”与“创建”是彼此独立的。但在Java中，“初始化”与“创建”捆绑在一起，两者不能分离。构造器是一种特殊类型的方法，因为它没有返回值（不是指void，带有void的方法实际上返回的是一个void类型的变量）。需要注意的是，new表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值。正如上述所说，其实这里是两步：创建对象与调用该对象的构造器方法（初始化），只是Java在我们new一个对象时，会自动帮我们调用其构造器方法。方法重载任何程序设计语言都具备的一项重要特性就是名字的运用。当创建一个对象时，也就给此对象分配到的存储空间取了一个名字。所谓方法则是给某个动作取的名字。通过使用名字，你可以引用所有的对象和方法。在Java和C++里，构造器是强制重载方法名的一个重要原因。因为构造器必须与类同名，但我们又想为用户提供多种初始化的方式。为了让方法名相同而形式参数不同的构造器同时存在，必须用到方法重载，同时其亦可用于其他方法且用法相同。12345678910111213141516171819class Speaker&#123; // 这是无参构造器 Speaker()&#123; System.out.println(\"Sorry, I don't know who you are!\"); &#125; // 重载：这是有参构造器 Speaker(String name)&#123; System.out.println(\"Hello\" + name + \"!\"); &#125; // 方法sayHello() void sayHello()&#123; System.out.println(\"Hello world\"); &#125; // 重载方法sayHello(),向具体的人 void sayHello(String name)&#123; System.out.println(\"Hello\" + name + \"!\"); &#125;&#125;区分重载方法每个重载的方法都必须有一个有一个独一无二的参数类型列表。在Java中，编译器是通过方法名+参数列表作为唯一的方法签名去识别具体调用哪个方法。涉及基本类型的重载基本类型能从一个“较小”的类型自动提升至一个“较大”的类型，此类型一旦牵涉到重载，可能会造成一些混淆。1234567891011class PrimitiveOverloading&#123; // void f1(char x)&#123;System.out.println(\"char\");&#125; // void f1(byte x)&#123;System.out.println(\"byte\");&#125; void f1(int x)&#123;System.out.println(\"int\");&#125; void f1(float x)&#123;System.out.println(\"float\");&#125; // void f1(double x)&#123;System.out.println(\"double\");&#125;&#125;// 下面的输出是:intnew PrimitiveOverloading().f1('c');// 下面会编译器报错new PrimitiveOverloading().f1(5.0D);从上面的代码可以得出结论：如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际参数类型会被提升；如果传入的实际参数较大，就得手动通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。以返回值区分重载方法在Java中，根据方法的返回值来区分重载方法是行不通的。因为Java是通过方法签名（方法名+参数列表）来标识和区分不同的方法的。默认构造器默认构造器（又名“无参”构造器）是没有形式参数的—它的作用是创建一个“默认对象”。如果你的类中没有构造器，则编译器会自动帮你创建一个默认构造器。1class Bird&#123;&#125;上面的类中并未明确定义构造器，但你创建其对象时仍会触发默认构造器的方法，因为编译器会为你自动添加一个默认构造器。但是，如果你已经定义了一个构造器（无论有无参数），编译器就不会帮你自动创建默认构造器。因为编译器会认为你只允许用户由该“入口”创建并初始化该对象。this关键字为了能用简便、面向对象的语法来编写代码—即“发送消息给对象”。在你调用对象方法时候，编译器会做一些幕后的工作，它暗自把“所操作对象的引用”作为第一个参数传递给方法。12345Person person = new Person();// 你调用sayHello()方法person.sayHello();// 实际在内部的表达形式如下Person.sayHello(person);假设你希望在方法的内部获得对当前对象的引用，可以使用关键字this。因为这个引用是由编译器“偷偷”传入的，所以没有标识符可用。this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。一般来说，只有当需要明确指出对当前对象的引用时，才需要使用this关键字。例如，当需要返回对当前对象的引用时，就常常在return语句里这样写:1234567public class Leaf&#123; int i = 0; Leaf increament()&#123; i++; return this; &#125;&#125;在构造器中调用构造器可能为一个类写了多个构造器，有时可能想在一个构造器中调用另一个构造器，以避免重复代码。可以用this关键字做到这一点：123456789101112131415public class Person&#123; private String name; private String email; public Person(String name)&#123; // 如果传入参数与对象内部参数同名，需要使用this关键字加以区分 this.name = name; &#125; public Person(String name, String email)&#123; // 调用其他的构造器方法 this(name)； this.email = email; &#125;&#125;注意：构造器中调用构造器通过this(...)的方法，但该条语句必须是构造器的第一行代码。static的含义static（静态）方法是没有this的方法，在static方法内部不能调用非静态方法。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际正是static方法的主要用途。Java禁止全局方法，但你可以在类中置入static方法就可以访问其他static方法和static域（这句话我觉得有点问题）。1234567public class Person&#123; public static void sayHello()&#123; System.out.println(\"Hello world!\"); &#125;&#125;Person.sayHello();在上面的代码中，我们为Person类声明了一个sayHello()的静态方法。在外部，我们可以通过类名直接调用该方法，而不需要初始化该对象。清理：终结处理和垃圾回收程序员常常忘记十分重要的清理工作。在使用程序时，把一个对象用完就“弃之不理”的做法是不安全的。当然，Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：假定你的对象（并非使用new创建）获得了一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存。为了应对这种情况，Java允许在类中定义一个名为finalize()的方法。finalize()的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。换言之，只有当“垃圾回收”发生时（不能保证一定会发生），finalize()才会得到调用。finalize()用途何在不应该将finalize()作为通用的清理方法。请先记住下面这一点：垃圾回收只与内存有关：也就是说，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是finalize()方法），它们也必须同内存及其回收有关。之所以要有finalize()是由于分配内存时候可能采用了类似C语言的做法，而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式。本地方法目前只支持C和C++，但它们可以调用其他语言的代码，所以实际上可以调用任何代码。你必须实施清理要清理一个对象，用户必须在需要清理的时刻调用执行清理动作的方法。Java不允许创建局部对象，必须使用new创建对象。在Java中，也没有用于释放对象的delete，因为垃圾回收器会帮助你释放存储空间。但你现在需要知道垃圾回收器的存在并不能完全替代析折函数（而且绝对不能直接调用finalize（），这不是一种解决方案）。记住，无论是“垃圾回收”还是“终结”，都不一定保证会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存。终结条件通常不能指望finalize()，必须创建其他的”清理”方法，并且明确调用它们。不过，finalize()还有一个有趣的用法，它并不依赖于每次都要对finalize()进行调用，这就是对象终结条件的验证。12345678910111213141516171819202122class Book&#123; boolean checkedOut = true; void checkIn()&#123; checkedOut = false; &#125; protected void finalize()&#123; if(checkedOut)&#123; throw new Exception(\"Error!\"); &#125; &#125; public static void main(String[] args)&#123; Book novel = new Book(); novel.checkIn(); // 忘记清理 new Book(); // 强制发生垃圾回收 System.gc(); &#125;&#125;所有的Book对象在被当作垃圾回收器前都应该被签入(check in)，在上面代码中的第二个Book对象未被签入，在发生垃圾回收时会导致异常错误。注意：System.gc()用于强制进行终止动作。垃圾回收器如何工作在以前的程序语言中，在堆上分配对象的代价十分高昂。然而，垃圾回收器对于提高对象的创建速度，却具有明显的效果。这意味着，Java从堆分配空间的速度，可以和其他语言从堆栈上分配空间的速度相媲美。C++里面的堆可以想象成一个院子，里面每个对象都负责管理自己的地盘。一段时间以后，对象可能会被销毁，但地盘必须加以重用。在某些Java虚拟机中，堆的实现截然不同：它更像一个传送带，每分配一个对象，它就往前移动一格。这就意味着对象存储空间的分配速度非常快。Java的“堆指针”只是简单地移动到尚未分配的区域，其效率比得上C++在堆栈上分配空间的效率。但更重要的原因在于垃圾回收器的介入。当它工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样“堆指针”就可以很容易移动到更靠近传送带的开始处，也就尽量避免了页面错误。通过垃圾回收器对对象重新排列，实现了一种高速的、有无限空间可供分配的堆模型。如何寻找垃圾引用计数是一种简单但速度很慢的垃圾回收技术。每个对象都含有一个引用计数器，当有引用连接到对象时，引用计数加1。当引用离开作用域或者置为null时，引用计数减1。垃圾回收器会在含有全部对象的列表上遍历，当发现某个对象的引用计数为0时，就释放其占有的空间。这种方法有个缺陷，如果对象之间存在循环引用，可能会出现“对象应被回收，但引用计数却不为零”的情况。如下面的代码所示：123456789101112131415class Teacher&#123; Student student;&#125;class Student&#123; Teacher teacher;&#125;class Test&#123; public static void main(String[] args)&#123; // 两个对象循环引用 Teacher teacher = new Teacher(); Student student = new Student(); teacher.student = student; student.teacher = teacher; &#125;&#125;在一些更快的模式，垃圾回收器使用可达路径，依据的思想是：对任何“活”对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。这条引用链条可能会穿过数个对象层次。由此，如果从堆栈和静态存储区开始，遍历所有的引用，就能找到所有“或的对象”。对于发现的每个引用，必须追踪到它所引用的对象，然后是此对象包含的所有引用，如此反复进行，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。在这种方式下，Java虚拟机将采用一种自适应的垃圾回收技术。如何处理垃圾如何处理找到的存活的对象，取决于不同的Java虚拟机的实现。有一种做法叫做停止-复制（stop-and-copy）。显然这意味着，先暂停程序的运行（所以这不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有复制的全部都是垃圾。当对象复制到新堆时，它们是一个挨着一个的，所以新堆保持紧凑排列。当把对象从一处搬到一处时，所有指向它的那些引用都必须修正。位于堆或静态存储区的引用可以直接修正，但可能还有其他指向这些对象的引用，它们在遍历过程中才能被找到（可以想象有个表格，将旧地址映射到新地址）。对于这种“复制式回收器”而言，效率会降低。这有两个原因：首先，得有两个堆，然后得在这两个分离的堆上来回折腾，从而维护比实际需要多一倍的空间。某些Java虚拟机对此处理的方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块的内存之间。第二个问题在于复制。程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。此时复制回收器仍将会将所有内存自一处复制到另一处，这很浪费。为了避免上述情形，一些Java虚拟机会进行检查：要是没有新垃圾产生，就会自适应转换到另一种工作模式：标记-清扫（mark-and-sweep）（Sun公司早期版本的Java虚拟机使用该技术）。标记-清扫所依据的思路是：从堆栈和静态存储区出发，遍历所用引用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象设一个标记，这个过程不会发生任何回收对象。只有当所有标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将会被释放，不会发生复制动作。所以剩下的堆空间是不连续的。垃圾回收器如果希望得到连续空间的话，就得重新整理剩下的对象。自适应技术如前文所述，在这里所讨论的Java虚拟机中，内存分配以较大的“块”为单位。如果对象较大，它会占用单独的块。严格来说，“停止-复制”要求在释放旧有对象之前，必须先把所有存活对象从旧堆复制到新堆。有了块之后，垃圾回收器在回收的时候就可以往废弃的块里拷贝对象。每个块有相应的代数（generation count）来记录它是否还存活。通常，如果块在某处被引用，其代数会增加；垃圾回收器会定期进行完整的清理动作—大型对象仍然不会被复制（只是其代数会增加），内含小对象的那些快则被复制斌整理。自适应技术：Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低，就会切换到“标记-清扫”方式。同样，Java虚拟机会跟踪“标记-清扫”的效果，如果堆里面出现很多碎片，就会切换为“停止-复制”方式。可以给一个罗嗦的称呼：“自适应的、分代的、停止-复制、标记-清扫”式垃圾回收器。即时编译技术Java虚拟机有许多附加技术用以提升速度。尤其是与加载器操作有关的，被称为即时编译器技术（Just-In-Time，JIT）。这种技术可以把程序全部或部分翻译成本地机器码（这本来是Java虚拟机的工作），程序运行速度因此得到提升。当需要装载某个类（通常是在为该类创建第一个对象时），编译器为找到其.class文件，然后将该类的字节码装入内存。此时有两种方案可供选择：一是让即时编译器编译所有代码。但存在以下两种缺陷：加载动作散落在整个程序生命周期内，累加起来花更多时间；增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），将导致页面调度，从而降低程序速度二是惰性评估（lazy evaluation），意思是即时编译器只在必要的时候才编译代码。这样从不会被执行的代码也许就压根不会被JIT所编译。新版JDK中的Java HotSpot技术采用了类似方法，代码每次被执行都会做一些优化，所以执行次数越多速度就越快。成员初始化所有变量在使用前都应得到恰当的初始化。对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。唯一有点例外的是，类的每个基本类型数据成员保证都会得到一个初始值。数据类型初始值booleanfalsechar0byte0short0int0long0float0.0double0.0referencenull构造器初始化可以用构造器来进行初始化。在运行时刻，可以调用方法或执行某些动作来确定初值，这让编程变得更灵活。但需要注意：无法阻止自动初始化的进行，它将在构造器被调用前发生。123456class Test&#123; int i; test()&#123; i = 1; &#125;&#125;代码解读：变量i会先被初始化为0，再赋值为1。初始化顺序在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。静态数据的初始化无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准值；如果它是一个对象引用，那么它的默认初始值就是null。静态初始化只有在必要时刻才会进行，只有在第一个类对象被创建（或第一次访问静态数据）时候，它们才会被初始化。此后，静态对象不会再次被初始化，每次引用的都是同一个对象。初始化的顺序是先静态对象，而后是“非静态”对象。显式的静态初始化Java允许将多个静态初始化动作组织成一个特殊的“静态子块”（也可称为“静态代码块”）。如：123456class Teacher&#123; static Student student; static&#123; student = new Student(); &#125;&#125;非静态实例初始化Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量。例如：12345678public class Mugs&#123; Mug mug1; Mug mug2; &#123; mug1 = new Mug(); mug2 = new Mug(); &#125;&#125;这种语法对于支持“匿名内部类”的初始化时必须的，但是它也使得你可以保证无论调用哪个显式构造器，某些操作都会发生。这个代码块也是会在调用构造器执行。数组初始化数组是相同类型、用一个标识符名称封装到一起的一个对象序列或基本数据类型序列。数组是通过方括号下标操作符[]来定义和使用的。要定义一个数组，只需在类型名后加上一对空括号即可：1234int[] a1;// 实际上也可以将方括号放在变量名后int a2[];// 但是后面这种方式不利于识别是一个数组对于数组，你不能直接在引用上指定大小。为了给数组创建相应的存储空间，必须写初始化表达式。对于数组，初始化动作可以出现在代码的任何地方，但也可以用一种特殊的初始化表达式，它必须在创建数组的地方出现。这种特殊的初始化是由一对花括号{}括起来的值组成。在这种情况下，存储空间的分配（等价于使用new）将由编译器负责。例如：1234// 直接给数组赋int[] a1 = &#123;1,2,3,4,5&#125;;// 开辟一个大小为5的int数组int[] a2 = new int[5];所有数组（无论它们的元素是对象还是基本类型）都有一个固定成员—length，可以通过它获知数组内包含了多少元素，但不能对其修改。与C和C++类似，Java数组计数也是从第0个元素开始，所以能使用的最大下标数是length-1。一旦你访问下标越界，就会出现运行时错误（异常，indexOfBoundException）。可变参数列表JAVA SE5提供了一种方便的语法来创建对象并调用方法，以获得与C的可变参数列表（varages）一样的效果。这可以应用于参数个数或类型未知的场合。由于所有的类都直接或间接继承于Object类。123456789void printArray(Object... objects)&#123; for(Object object:objects)&#123; System.out.println(object); &#125;&#125;public static void main(String[] args)&#123; printArray(new Integer(47), new Float(3.4), new Double(11.11))&#125;打印一个类只会出现类的名称以及后面紧接着一个@符号以及多个十六进制数字，因为默认行为（没有定义toString()方法）就是打印类的名字和对象的地址。有了可变参数，就不用再显式地编写数组方法了，当你指定参数的时候，编译器实际上会为你去填充数组。获取的仍旧是一个数组。如果该参数列表中没有任何元素，那么转变成的数据的尺寸为0。枚举类型在Java SE5中添加了一个看似很小的特性，即enum关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便的处理。在此之前，你需要创建一个静态常量集，但是这些枚举值并不会必然地将其自身的取值限制在这个常量集的范围之内，因此显得更有风险，且难使用。枚举的出现正是为了解决这个问题。123public enum Spiciness&#123; NOT,MILD,MEDIUM,HOT,FLAMING;&#125;上述的代码创建了一个名为Spiciness的枚举类型，它具有5个具名值。由于枚举类型的实例是常量，因此按照命名惯例都用大写字母表示。当你创建enum时，编译器会自动添加一些有用的特性。例如，它会创建toString()方法，以便你可以很方便地显示某个enum实例的名字。编译器还会创建ordinal()方法，用来表示某个特定的enum常量的声明顺序；以及static values()方法，用来按照enum常量声明顺序，产生由这些常量值构成的数组。123456789101112131415public class EnumTest&#123; public static void main(String[] args)&#123; for(Spiciness s:Spiciness.values())&#123; System.out.println(s + \"：\" + s.ordinal()); &#125; &#125;&#125;/** output:* NOT:0* MILD:1* MEDIUM:2* HOT:3* FLAMING:4*/尽管enum看起来像是一种新的数据类型，但是这个关键字只是为enum生成对应类时，产生了某些编译器行为，因为你可以将enum当作一般的类来处理，只是具有某些特别的方法。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"04-控制执行流程","slug":"Java编程思想/04-控制执行流程","date":"2020-05-25T15:12:36.000Z","updated":"2020-05-27T07:24:00.646Z","comments":true,"path":"Java编程思想/04-控制执行流程/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/04-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/","excerpt":"","text":"程序必须在执行过程中控制它的世界，并做出选择。在Java中，涉及的关键字包括：if-else,while,do-while,for,return,break以及选择语句switch。goto不做介绍。true和false所有条件语句都利用条件表达式的真或假来决定执行路径。即若条件表达式为真时，执行该条件语句的代码块；若为假，则不执行。注意：Java不允许我们将一个数字作为布尔值使用，虽然这在C和C++里允许。if-elseif-else语句是控制程序流程的最基本形式。其中else是可选的，所以可按下述两种形式来使用if：123456789if(Boolean-expression)&#123; statement;&#125;if(Boolean-expression)&#123; statement;&#125;else&#123; statement;&#125;布尔表达式必须产生一个布尔结果，statement指用分号结尾的简单语句，或复合语句（封闭在花括号内的一组简单语句）。在中间可以看到一个或多个else if，那并非新的关键字，而仅仅只是一个else后面紧跟另一个新的if语句。1234567if(Boolean-expression)&#123; statement;&#125;else if(Boolean-expression)&#123; statement;&#125;else&#123; statement;&#125;迭代while、do-while和for用来控制循环，有时也将它们划分为迭代语句（iteration statement）。代码块会重复执行，直到起控制作用的布尔表达式（Boolean Expression）得到“假”的结果为止。while循环的格式如下：123while(Boolean-expression)&#123; statement;&#125;在循环刚开始时，会计算一次布尔表达式的值；而在代码块的下一次迭代开始前会在计算一次。do-whiledo-while的格式如下：123do&#123; statement;&#125;while(Boolean-expression);while和do-while唯一的区别是do-while中的语句至少会执行一次，即便布尔表达式第一次就被计算为false。但在实际应用中，while更常用一些。forfor循环可能是最经常使用的迭代形式，这种在第一次迭代之前要进行初始化。随后它会进行条件测试。而且在每一次迭代结束时，进行某种形式的“步进”。for循环的格式如下：123for(initialization;Boolean-expression;step)&#123; statement;&#125;初始化(initialization)、布尔表达式（BooleanExprssion）、步进（step）运算都可以为空。每次迭代前都会测试布尔表达式。若获得的结果是true就执行代码块内语句。每次循环结束，会执行一次步进。下面以在一个数组内遍历寻找一个数为例：12345678// 在数组中寻找到数字3,并返回其下标int[] arr = new int[]&#123;1,2,3,4,5&#125;;for(int i=0;i&lt;arr.length;i++)&#123; if(arr[i] == 3)&#123; return i; &#125;&#125;return -1;逗号操作符Java里唯一用到逗号操作符的地方就是for循环的控制表达式。在控制表达式的初始化和步进控制部分，可以使用一系列由逗号分隔的语句，而且那些语句均会被独立执行。通过使用逗号操作符，可以在for语句内定义多个变量，但是它们必须具有相同的类型。1234for(int i=1,j=j+10;i&lt;5;i++,j=i*2)&#123; System.out.println(\"i=\" + i); System.out.println(\"j=\" + j);&#125;在初始化部分可以拥有任意数量的具有相同类型的变量定义，这种能力只限于for循环，在其他任何选择或迭代语句中都不能使用这种方式。Foreach语句Java SE5引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。假如拥有一个float数组，我们要选取该数组中的每一个元素：1234float[] arr = new float[]&#123;1.0f, 1.1f, 1.2f, 1.5f&#125;;for(float f:arr)&#123; System.out.println(f);&#125;上面的语句定义了一个float类型的变量f，继而将每一个arr的元素赋值给f。return在Java中有多个关键词表示无条件分支，它们只是表示这个分支无需任何测试即可发生，这些关键词包括return、break、continue。return关键词有两方面的用途：一方面指定一个方法返回什么值，另一方面会导致当前的方法退出，并返回那个值。break和continue在任何迭代语句的主体部分，都可以用break和continue控制循环的流程。其中，break用于强行退出循环，不执行剩下的循环。而continue则停止执行当前的迭代，不再执行当前循环剩下的语句而马上开始下一次循环。无尽循环有两种方式：while(true)和for(;;)，对于这两者只有通过break语句才能退出循环。注意：break会中断for循环，而且在抵达for循环的末尾之前，递增表达式不会执行。其实Java中存在着带标签的continue和break，但并不提倡使用这种语法，故不在此记录。switchswitch有时也被划分为一种选择语句，选择使用其的原因一般是因为if-else if的结构十分复杂，这时我们选择使用switch来替代它，来使我们的程序结构更加清晰明了。switch语句可以从一系列的代码中选出一段去执行，它的格式如下：1234567891011121314switch(selector)&#123; case value1: statement; break; case value2: statement; break; case value3: statement; break; default: statement; break;&#125;在上面的代码中，会根据输入进来的selector去与我们定义的value比较，找到相等的case开始执行语句。一般来说，每个case均以一个break语句结尾，这样可使执行流程跳转至switch主体的末尾。但break是可选的，若省略break会继续执行后面的case语句，直到遇到一个break或走到switch的末尾为止。switch语句是实现多路选择的一种干净利落的方法，但它要求使用一个选择因子，并且必须是int或char那样的整数值（在Java SE7时String类型也被支持了）。臭名昭著的goto编程语言一开始就有goto关键词。事实上，goto起源于汇编语言的程序控制：“若条件A成立，则跳到这里；否则跳到哪里”。如果阅读由编译器最终生成的汇编代码，就会发现程序控制里包含了许多跳转。注：Java编译器生成自己的“汇编代码”，但是这个代码运行在Java虚拟机上的，而不是直接运行在CPU硬件上。goto语句是在源码级上的跳转，这使得很难识别程序的控制流程。尽管goto仍是Java中的一个保留字，但在语言中并未使用它，即Java没有goto。然而，Java也能完成一些类似于跳转的操作，这与break和continue这两个关键词有关。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"03-操作符","slug":"Java编程思想/03-操作符","date":"2020-05-25T15:10:54.000Z","updated":"2020-05-27T07:23:51.445Z","comments":true,"path":"Java编程思想/03-操作符/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/03-%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"在最底层，Java中的数据是通过使用操作符来操作的。使用Java操作符操作符接受一个或多个参数，并生成一个新值。参数的形式与普通的方法调用不同，但效果是相同的。加号和一元的正号（+）、减号和一元的负号（-）、乘号（*）、除号（/）以及赋值号（=）的用法与其他编程语言类似。几乎所有操作符都只能操作“基本类型”。例外的操作符是“=”、“==”、和“！=”，这些操作符能操作所有对象。除此之外，String类支持“+”和“+=”，这是通过重载操作符来实现的。需要说明的是，Java的底层C++语言支持由程序员重载操作符，但Java是不支持这一特性的，String是个唯一的特例。优先级当一个表达式中存在多个操作符时，操作符的优先级就决定了各部分的计算顺序。其中，最简单的规则就是先乘除和加减，也可以使用括号来明确规定计算顺序。赋值赋值使用操作符“=”，它的意思是“取右边的值复制给左边”。右值可以是任何常数、变量和表达式（只要它能生成一个值就行）。但左值必须是一个明确的、已命名的变量。也就是说，必须有一个物理空间可以存储等号右边的值。但是不能把任何东西赋给一个常数，即常数不能作为左值（4=a）。对于基本类型的赋值，是直接将一个地方的内容复制到了另一个地方。而为对象赋值时，实际是将引用从一个地方复制到了另一个地方。算数操作符Java的基本算术操作符与其他大多数程序设计语言是相同的。其中包括加号（+）、减号（-）、除号（/）、乘号（*）以及取模操作符（%，它从整数除法中产生余数）。整数除法会直接去掉结果的小数位（相当于向下取整），而不是四舍五入地圆整结果。一元加、减操作符一元减号（-）和一元（+）与二元减号和加号使用相同的符号。根据表达式的书写形式，编译器会自动判断出是哪一种。例如：1x = -a;一元减号用于转变数据的符号，而一元加号只是为了与一元减号相对应，但是它唯一的作用仅仅是将较小类型的操作数提升为int。自动递增和递减递增和递减运算是两种相当不错的快捷运算（吐槽一下python，并不支持此语法）。其中，递减操作符是--，意为减少一个单位；递增操作符是++，意为增加一个单位。这两个操作符各有两种使用方式，通常被称为“前缀式”和“后缀式”。对于前缀递增、减（如++a），会先改变值，再执行运算；而后缀递增、减（如a--），会先执行运算，再改变值。一些注释:在C++中前缀递增、减与后缀递增、减是有效率区别的，前缀会比后缀效率高20%（没记错的话，以前看过一篇博客分析）。但是在Java中，如果你是用的后缀与前缀是等价的，会自动帮你转化为前缀表达式以提高效率（这一点也忘了在哪里瞎看到的）。关系操作符关系操作符生成的是一个boolean布尔结果，它们计算的是操作数值之间的关系。如果关系是真，关系表达式会生成true；否则，则生成false。关系操作符包括小于(&lt;)、大于(&gt;)、小于等于(&lt;=)、大于等于(&gt;=)、等于(==)以及不等于(!=)。等于和不等于适用于所有数据类型，而其他比较符适用于除boolean类型之外的所有基本数据类型。==和equals的区别对于==运算符：基本类型：比较的是值是否相同引用类型：比较的是引用是否相同1234567String x = \"string\";String y = \"string\";String z = new String(\"string\");System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true代码解读：当你使用String s = &quot;a&quot;这种形式生成字符串时，会先检索方法区中的字符串常量池是否已经存在一个这样的对象，如果存在则返回该对象的引用；若不存在，则创建一个字符串对象并将其放入字符串常量池中。所以上述代码中的变量x和y实际上指向了同一个引用。而使用关键字new则会每次都申请内存空间创建一个新的对象。对于equals方法，其本质上就是==，只不过String和Integer等重写了该方法，把它变成了值比较。因为，equals是一个方法，只有对象具有方法，所以其默认情况是引用比较。但许多类都重写了equals方法，所以一般情况下其比较的是值是否相等。逻辑操作符逻辑操作符“与”（&amp;&amp;）、“或”（||）、“非”（！）能根据参数的逻辑关系，生成一个布尔值（true或false）。与、或、非操作只可应用于布尔值。 短路当使用逻辑操作符时，我们会遇到一种短路现象。即一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下的部分。因为，逻辑表达式靠后的部分有可能不会被运算。121. a||b2. a&amp;&amp;b代码解读：在式子1中，如果a为true，那么b就不会被计算，因为该表达式必定为真；在式子2中，如果a为false，那么b也不会被计算，因为该表达式必定为假。直接常量如果在程序里使用了直接常量，需要对编译器加以适当的指导，用与直接常量相关的某些字符来额外增加一些信息。直接常量的后缀字符标志了它的类型。若为大写（或小写）的L，代表Long（尽量使用大写，因为小写的l看起来像数字1，容易造成混淆）；大小（或小写）字母F，代表float；大写（或小写）字母D，则代表double。十六进制数适用于所有整数数据类型，以前缀0x或(0X)，后面跟随0-9或小写（大写）的a-f来表示。如果试图将一个变量初始化成超出自身范围的值，编译器都会向我们报告一条错误信息。八进制由前缀0以及后续的0-7的数字来表示。在C、C++和Java中，二进制数没有直接常量表示方法。但是在使用十六进制和八进制计数法时，以二进制形式显示结果将非常有用。通过使用Integer和Long类型的静态方法toBinaryString()可以很容易实现这一点。1234567int i1 = 0x2f; // Hexadecimalint i2 = 0177; // Octal(leading zero)char c = 0xffff; // max char hex valuebyte b = 0x7f; // max byte hex valuelong n1 = 200L;float f1 = 1F;double d1 = 1D;指数计数法Java采用了一种很不直观的计数法来表示指数，例如：1float f = 1.39e-43f;上面的变量f表示$1.39 \\times 10^{-43}$。编译器通常会把指数作为双精度（double）处理，所以上述代码如果没有这个尾随的f，就会收到一条出错信息。按位操作符按位操作符用来操作整数基本类型中的单个“比特”（bit），即二进制位。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。按位操作符来源于C语言面向底层的操作，在这种操作中经常需要直接操纵硬件，设置硬件寄存器内的二进制位。如果两个输入位都是1，则按位“与”操作（&amp;）生成一个输出位1；否则生成一个输出位0。如果两个输入位只要一个是1，则按位“或”操作（|）生成一个输出位1；只有在两个输入位都是0的情况下，“或”操作才会生成一个输出位0。如果输入位的某一个是1，但不全是1，那么按位“异或”操作（^）生成一个输出位1。按位“非”（~），也称取反操作符，它属于一元操作符，只对一个操作数进行操作。“非”操作生成与输入位相反的值—若输入0，则输出1；若输入1，则输出0。按位操作符可与等号（=）联合使用，以便合并运算和赋值：&amp;=、|=、^=都是合法的。由于~是一元操作符，故不能与“=”号联合使用。布尔类型作为一种单比特值对待，可以对其执行按位“与”（&amp;）、按位“或”（|）和按位“异或”（^）运算，但不能执行按位“非”。对于布尔值，按位操作符具有与逻辑操作符相同的效果，只是它们不会中途“短路”。移位操作符移位操作符操作的运算对象也是二进制的“位”，移位操作符只可以用来处理整数类型。左移位操作符（&lt;&lt;）能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）。左移1位相当于乘以2，所以说计算5*8，最快的方法应该是将5向左移动三位5&lt;&lt;3。“有符号”右移位操作符（&gt;&gt;）则按照操作符右侧指定的位数将操作符左边的操作数向右移动。“有符号”右移位操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1。Java中增加了一种“无符号”右移位操作符（&gt;&gt;&gt;），它使用“零扩展”：无论正负，都在高位插入0.注意：如果对char、byte或者short类型的数值进行移位处理，那么在移位进行之前，它们会被转换为int类型的值，并且得到的结果也是一个int类型的值。只有数值右端的低5位有用。这样防止移位超过int类型值所具有的位数（因为$2^5=32$，int类型只有32位）。若对一个long类型的数值进行处理，最后得到结果也是long此时只会用到数值右端的低6位。“移位”可与“等号”组合使用（&lt;&lt;=或&gt;&gt;=或&gt;&gt;&gt;=）。此时，操作符左边的值会移动由右边的值指定的位数，再将得到的结果赋给左边的变量。12345678int i = -1;i &gt;&gt;&gt;= 10;system.out.println(i);long l = -1;l &gt;&gt;= 3;system.out.println(l);l &lt;&lt;= 2;system.out.println(l);三元操作符 if-else三元操作符也称为条件操作符，因为它有三个操作数；但它确实属于操作符的一种，因为它最终也会生成一个值。1boolean-exp?value0:value1;如果boolean-exp的结果为true，就计算value0，而且这个计算结果也就是操作符最终产生的值；若为false，就计算value1，同样它的结果也就成为操作符最终产生的值。字符串操作符+和=这个操作符在Java中有一项特殊用途：连接不同的字符串。这项功能用在C++中似乎是个不错的主意，所以引入了操作符重载（operator overloading）机制，以便C++程序员可以为几乎所有操作符增加功能。但操作符重载是一种非常复杂的特性，程序员在设计自己的类时必须对此有周全的考虑。尽管操作符重载在Java这种更容易实现，但Java程序员不能像C++和C#程序员那样实现自己的重载操作符。如果表达式以一个字符串起头，那么后续所有操作数必须都是字符串型。请记住，编译器会把双引号内的字符序列自动转换为字符串。1234int x = 0, y = 1, z = 2;String s = \"x, y, z\";system.out.println(s);system.out.println(s + x + y +z);使用操作符时常犯的错误第一个常犯的错误是：即使对表达式如何计算有点不确定，也不愿意使用括号。此外，一个常犯的错误如下：123while(x = y)&#123; // ...&#125;程序员明显是想测试是否“相等”（==），而不是进行赋值操作。在Java中，这个表达式的结果并不是布尔值，而编译器期望的是一个布尔值。Java不会自动地将int数值转换成布尔值，所以在编译时抛出一个编译时错误，从而阻止进一步运行这个程序。而在C和C++中，编译器会将int数值转换成布尔值（非0为true，0为false）。类型转换操作符类型转换（cast）：Java会将一种数据类型自动转换成另一种。例如为某浮点数变量赋一个整数值，编译器为将int自动转换为float。类型转换运算允许显式地进行这种类型的转换，或者在不能自动进行转换的时候强制进行类型转换。要想执行类型转换，需要将希望得到的数据类型置于圆括号()内，并放在要进行类型转换的值左边。12int i = 100;long l = (int)i;在C和C++中，类型转换有时会让人头疼。但是在Java中，类型转换则是一种比较安全的操作。窄化转换（narrowing conversion）：将能容纳更多信息的数据类型转换为无法容纳那么多信息的类型，可能会导致信息丢失。扩展转换（widening conversion）：不必显式地进行类型转换，因为新类型肯定能容纳原来类型的信息，不会造成任何信息的丢失。Java允许把任何基本数据类型转换成其他的基本数据类型，但布尔型除外，后者不允许进行任何类型的转换处理。“类”数据类型不允许进行类型转换，为了将一种类转换成另一种，必须采用特殊的方法。截尾和舍入在执行窄化转换时，必须注意截尾和舍入问题。123float f = 29.7;int i = (int)f;system.out.println(i); // 29将float或double转型为整型值时，总是对该数字执行截尾。如果想要得到舍入结果，需要使用java.lang.Math.round()方法。提升如果对基本数据类型执行算术运算或按位运算，大家会发现，只要类型比int小（即char,byte,short），在运算前，这些值会自动转换为int。如果想要把结果赋值给较小的类型，就必须使用类型转换。通常，表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。Java没有sizeof在C和C++中，sizeof()操作符可以告诉你为数据项分配的字节数。sizeof()最大的用处是为了移植，因为不同的数据类型在不同的机器上可能有不同的大小。Java不需要sizeof()操作符，因为所有的数据类型在所有机器中的大小都是相同的，它已经被设计在语言中。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"02-一切都是对象","slug":"Java编程思想/02-一切都是对象","date":"2020-05-25T14:54:04.000Z","updated":"2020-05-27T11:27:08.322Z","comments":true,"path":"Java编程思想/02-一切都是对象/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/02-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"Java是基于C++的，但是相比之下，Java是一种更纯粹的面向对象程序设计语言。用引用操纵对象每种编程语言都有自己的操纵内存中元素的方式。在Java中，一切都被视为对象，因此可采用固定单一的语法。尽管一切都看作对象，但操纵的标识符实际是对象的一个“引用”（reference）。可以将这一情形想象成用遥控器（引用）来操纵电视机（对象）。引用可以独立存在，但在操纵时会返回错误，因为其没有与一个具体的对象绑定，如下面的代码所示：12String s; &#x2F;&#x2F; 这声明了一个字符串引用s.length(); &#x2F;&#x2F; 编译会错误必须由你创建所有对象一旦创建一个引用，就希望它能与一个新的对象相关联。通过用new操作符来实现这一目的。new关键字意思是“给我一个新对象”。1String s = new String(\"hello world!\");Java提供了大量过剩的现成类型。重要的是，你可以自行创建类型。存储到什么地方程序运行时，有五个不同的地方可以存储数据:寄存器：这是最快的存储区，因为它位于不同于其他存储区的地方—处理器内部。但寄存器数量极其有限，所以寄存器根据需求怎么分配。堆栈：位于通用RAM（随机访问存储器）中，通过堆栈指针可以从处理器那里直接获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方式，仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。某些Java数据存储在堆栈中—特别是对象引用，但是Java对象并不存储于其中。堆：一种通用的内存池（也位于RAM区），用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当需要一个对象时，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。灵活性的代价是：用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间。常量存储：常量值通常直接存放在程序代码内部。非RAM存储：如果数据完全存活在程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是流对象和持久化对象。这种存储方式的技巧在于：把对象转换成可以存放在其他媒介上的食物，在需要时可恢复成常规的、基于RAM的对象。Java提供了对轻量级持久化的支持。补充：Java的内存模型首先回顾一下Java程序的执行流程：如上图所示，首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件。加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area （运行时数据区），也就是我们常说的JVM内存。因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。根据JVM规范，JVM内存共分为五个部分：虚拟机栈堆方法区程序计数器本地方法栈特例：基本类型在程序设计中经常用到一系列类型，它们需要特殊对待。因为new将对象存储在堆里，对于小的、简单的变量，往往不是很有效。因此对于基本类型，Java采取与C和C++相同的方法。也就是不用new来创建变量，而是创建一个并非是引用的“自动”的变量。这个变量直接存储值，并置于堆栈中，因此更加高效。基本类型大小最小值最大值包装器类型boolean---Booleanchar16-bitUnicode oUnicode $2^{16}-1$Characterbyte8 bits$-128$$+127$Byteshort16 bits$-2^{15}$$+2^{15}-1$Shortint32 bits$-2^{31}$$+2^{31}-1$Integerlong64 bits$-2^{63}$$+2^{63}-1$Longfloat32 bitsIEEE 754IEEE 754Floatdouble64 bitsIEE 753IEEE 754Doublevoid---Void所有数值类型都有正负号，所以不要去寻找无符号的数值类型。boolean类型所占的存储空间大小没有明确规定，仅定义为能够取字面值true或false。Java SE5的自动包装功能将自动地将基本类型转换为包装器类型，并可以反向转换。高精度数字Java提供了两个用于高精度计算的类：BigInteger和BigDecimal。这两个类包含的方法，提供的操作与对基本类型所能执行的操作相似。也就是说，能作用于int和float的操作，也同样能应用在BigInteger和BigDecimal`，只不过必须以方法调用方式取代运算符来实现。BigInteger支持任意精度的整数。也就是说，在运算中，可以准确地表示任意大小的整数值，而不丢失任何信息。BigDecimal支持任意精度的定点数，例如，可以用它来进行精确的货币计算。永远不需要销毁对象在大多数程序设计语言中，变量生命周期的概念，占据了程序设计工作非常重要的部分。Java帮助我们大大简化了这个问题。作用域大多数过程语言都有作用域（Scope）的概念。作用域决定了其内定义的变量名的可见性和生命周期，作用域由花括号{}的位置决定。在作用域里定义的变量只可用于作用域结束之前。且在Java中，较大作用域的变量不会“隐藏”，故较小作用域中不能定义与较大作用域同名的变量。对象的作用域Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。假如你编写了下述代码：123&#123; String s = new String(\"hello world!\");&#125;引用s在作用域终点就消失了。然而s指向的String对象仍继续占据内存空间。事实证明，由new创建的对象，只要你需要，就会一直保留下来。同时，Java有一个垃圾回收器，用来监视new创建的对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以供新的对象使用。就是说，程序员不用关心内存回收的问题。Java从天然上隔绝了内存泄漏。创建新的数据类型：类如果一切都是对象，那么是什么决定了某一类对象的外观与行为呢？大多数面向对象的程序设计语言习惯用关键字class来表示“我准备告诉你一种新类型的对象看起来像什么样子”。1class ATypeName &#123;/* Class body goes here */&#125;这就引入了一种新的类型了，然后你已经可以用new来创建这种类型的对象。字段和方法一旦定义了一个类，就可以在类中设置两种类型的元素：字段（有时称为数据成员）和方法（有时称为成员函数）。字段可以是任何类型的对象，可以通过其引用与其进行通信；也可以是基本类型中的一种。每个字段都有用来存储其字段的空间；普通字段不能在对象中共享。基本成员默认值：基本类型默认值booleanfalsechar&#39;\\uooooo&#39;(null)byte(byte)oshort(short)ointolongoLfloato.ofdoubleo.od若类的某个成员是基本数据类型，即使没有初始化，Java也会确保它获得一个默认值，以确保那些是基本类型的成员变量得到初始化，防止产生程序错误。提醒：最好明确地对变量进行初始化。方法、参数和返回值Java的方法决定了一个对象能够接收什么样的消息。方法的基本组成部分包括：名称参数返回值方法体下面是它最基本的形式：123ReturnType methodName(/* Argument list */)&#123; /* Method Body */&#125;返回类型描述的是在调用方法之后从方法返回的值。参数列表给出了要传给方法的信息的类型和名称。方法名和参数列表（它们合起来被称为“方法签名”）唯一地标识出某个方法。Java中的方法只能作为类的一部分来创建，方法只有通过对象才能被调用，且这个对象必须能执行这个方法调用。通过这个对象调用方法时，需要先列出对象名，紧接着是句点，然后和方法名和参数列表。1objectName.methodName(arg1, arg2, arg3);参数列表方法的参数列表指定要传递给方法什么样的信息。这些信息如Java中的其他信息一样，采用都是对象的形式。因此，在参数列表必须指定每个所传递对象的类型及名字，这里的传递实际上也是引用。疑问：Java中的参数传递不是副本拷贝吗？正如你把一个对象A传递进方法f(A)，在方法中对A进行操作，并不会影响外部的A的值。在方法体中，可以使用return关键字进行值的返回。当然，如果你的方法返回类型为void的时候，可以不返回任何值，并且通过return;语句，在程序中随时退出方法。构建第一个Java程序名字可见性名字管理对任何程序设计语言来说，都是一个重要问题。如果在程序的某个模块使用了一个名字，而其他人的程序的另一个模块也使用了相同的名字，那么怎样区分这两个名字并防止二者相互冲突呢？Java采用了一种全新的方法来解决上述问题。为了给一个类库生成不会与其他名字混淆的名字，Java设计者希望程序员放过来使用自己Internet域名，因为这样可以保证它们肯定是独一无二的。例如：cn.hengxin，这个将域名进行了反转，句点就用来代表子目录的划分。一般来说，这被称为包，建议包名采用全小写的形式。这种机制意味着所有的文件都能自动存活在它们自己的名字空间中，而且同一个文件内每个类都有唯一的标识符—类名。运用其他构件如果想在自己程序里使用预先定义好的类，那么编译器就必须知道怎么定位它们。当然，这个类可能就在发出调用的源文件中；在这种情况下，就可以直接使用这个类—即使这个类在文件的后面才会被定义。Java消除了所谓的“向前引用”问题。例如，C语言在调用一个函数时，这个函数必须在调用语句前被定义。为了消除所有可能的混淆情况，可以使用关键字import来准确地告诉编译器你想要的类是什么。import指示编译器导入一个包，也就是一个类库。1import java.util.ArrayList;如果你想使用Java的util包下数量众多的类，又不想逐一声明，那么可以使用通配符*来达到这个目的：1import java.util.*;当然，现代的IDE一般都会存在提示或者自动导入包的机制，因此你并不需要记住这个类来自于那个包，仅需在IDE提示你的时候进行判断选择就可以了。在eclipse中，我们可以使用crtl+shift+O进行包的自动导入，如果存在混淆的情况，eclipse将会要求你进行选择导入那个包以匹配正确的类static关键字通常来说，除非用new创建类对象，否则实际上并未获得任何对象。执行new来创建对象时，数据存储空间才被分配，其方法才供外界调用。但是，当使用static关键字去修饰一个字段或者方法时，就意味着这个域不会与包含它的类的任何对象实例关联起来。所以，即使从未创建某个类的任何对象，也可调用其static方法或者访问其static域。1234567class ATest&#123; static int i=0; static void increment()&#123; ATest.i++; &#125;&#125;","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"01-对象导论","slug":"Java编程思想/01-对象导论","date":"2020-05-25T12:21:35.000Z","updated":"2020-05-27T07:23:26.150Z","comments":true,"path":"Java编程思想/01-对象导论/","link":"","permalink":"https://hengxincheung.github.io/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/01-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"计算机革命起源于机器，因此，编程语言的产生也始于对机器的模仿。但是计算机并非只是机器那么简单，计算机是头脑延伸的工具。面向对象程序设计（Object-oriented Programming，OOP）是以计算机作为表达媒体的大趋势中的组成部分。抽象过程所有的编程语言都提供抽象机制，人们所能够解决的问题的复杂性直接取决于抽象的类型与质量。汇编语言是对底层机器的轻微抽象。接着出现的许多所谓的“命令式”语言（如FORTRAN、BASIC、C等）都是对汇编语言的抽象。它们所作的主要抽象仍要求在解决问题时要基于计算机的结构，而不是基于所要解决的问题的结构来考虑。另一种对机器建模的方式就是只针对待解问题建模。早期的编程语言，如LISP和APL，都选择考虑世界的某些特定视图（分别对应于“所有问题最终都是列表”或者“所有问题都是算法形式的”）。这些方式对需要解决的特定类型的问题都是不错的解决方案，但一旦超出其特定领域，就会显得力不从心。面向对象方式通过向程序员提供表示问题空间中的元素的工具。这种表示方式非常通用，使程序员不会受限于任何特定类型的问题。我们将问题空间中的元素及其在解空间中的表示称为“对象”。OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。每个对象看起来都像一台微型计算机—具有状态和操作，用户可以要求对象执行这些操作。第一个成功的面向对象语言Smalltalk（Java语言的祖先之一）的五大特性：万物皆对象：将对象视为奇特的变量，它可以存储数据，还可以要求它在自身上执行操作；程序是对象的集合：对象通过发送消息来告诉彼此所要做的事。要想请求一个对象，就必须对该对象发送一条消息（即调用对象方法的请求）；每个对象都有自己的由其他对象所构成的存储：可以通过创建包含现有对象的新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后；每个对象都拥有类型：每个对象都是某个类(class)的一个实例(instance)；某一特定类型的所有对象都可以接收同样的消息:一个“圆形”类型的对象同时也是“几何形”类型的对象，所以一个“圆形”对象必定能够接受发送给“几何形”对象的消息。这种替代性（substitutability）是OOP中最强有力的概念之一。Booch对对象提出了一个更加简洁的描述：对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据（对象的状态）和方法（产生的行为），并且每一个对象都可以唯一地与其他对象区分开来（即在内存中都有一个唯一的地址）。每个对象都有一个接口创建抽象数据类型（类）是面向对象程序设计的基本概念之一。因为类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。程序员通过定义类来适应问题，通过添加新的数据类型来扩展编程语言。编程系统欣然接受新的类，并且像内置类型一样地照管它们和进行类型检查。每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。接口确定了对某一特定对象所能发出的请求。但是，在程序中必须有满足这些请求的代码。这些代码和隐藏的数据一起构成了实现。在类型中，每一个可能的请求都有一个方法与之相关联，当对对象发送请求时，与之相关联的方法就会被调用。每个对象都提供服务最好将对象想象为“服务提供者”。程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这一目的。当正在试图开发或理解一个程序设计时，首先去想一想需要那些“服务提供者”去帮助我们完成。例如，假设你正在创建一个簿记系统，那么可以想象，系统应该具有：完成簿记输入屏幕的服务提供者；执行簿记计算的服务提供者；处理在不同打印机上打印支票和开发票的服务提供者。上述的服务提供者，本质上就是一类对象，这是将问题分解为对象集合的一种合理方式。将对象看作是服务提供者还有一个附带的好处：它有助于提高对象的内聚性。高内聚是软件设计的基本质量要求之一。将对象看作服务提供者是一项伟大的简化工具，这不仅在设计过程中非常有用，而且当其他人试图理解你的代码或重用某个对象时，使用或调整的过程变得简单许多。被隐藏的具体实现将程序开发人员按照角色分为类创建者（那些创建新数据类型的程序员）和客户端程序员（那些在应用中使用数据类型的类消费者）。客户端程序员收集各种用来实现快速开发应用的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必须的部分，而隐藏其他部分。如果加以隐藏，那么客户端程序员将不能访问它，这就意味着类创建者可以任意修改被隐藏的部分，而不用担心对其他人造成影响。被隐藏的部分通常代表对象内部脆弱的部分，它们很容易被粗心的或不知内情的客户端程序员所毁坏。因此，将实现隐藏起来可以减少程序BUG。在任何相互关系中，具有关系所涉及的各方都遵守的边界是十分重要的事情。因此，我们需要引入访问控制：访问控制让客户端程序员无法触及他们不应该触及的部分—这些部分对数据类型的内部操作是必须的，但并不是用户解决特定问题所需的接口的一部分；访问控制允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。Java使用三个关键字（或叫访问指定词，access specifier ）在类的内部设定边界：public：表示紧随其后的元素对任何人都可以用；private：表示除类型创建者和类型内部方法之外的任何人都不能访问。如果有人试图访问private成员，就会在编译时得到错误信息；protected：protected关键字与private作用相当，差别仅在于继承的类可以访问protected成员，但是不能访问privae成员。Java还有一种默认的访问权限，当没有使用前面提到的任何访问指定词，它将发挥作用，这种权限通常被称为包访问权限。在这种权限下，类可以访问同一包（库构件）中的其他类的成员。但是在包之外，这些成员如同指定了private一样。复用具体实现一旦类被创建并被测试完，那么它就应该（在理想情况下）代表一个有用的代码单元。最简单地复用某个类的方式是直接使用该类的一个对象，此外也可以将那个类的一个对象置于新的类中。我们称其为“创建一个成员对象”。新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。这种概念被称为组合（composition）。如果组合式动态发生的，那么可以称为聚合（aggregation）。组合经常被视为“has-a”（拥有）关系。组合带来了极大的灵活性，设计会变得更加清晰。继承类型不仅仅只是描述了作用于一个对象集合上的约束条件，同时还有与其他类型之间的关系。两个类型可以有相同的特性和行为，但是其中一个类型可能比另一个含有更多特性，并且可以处理更多的消息（或以不同的方式来处理消息）。继承使用基类型和导出类型的概念表示这种类型之间的相似性。一个基类型包含其所有导出类型的所共享的特性和行为。可以创建一个基类型来表示系统中某些对象的核心概念，从基类型中导出其他类型，来表示此核心可以被实现的各种不同方式。以同样的术语将解决方案转换成问题是大有裨益的，因为不需要在问题描述和解决方案描述之间建立许多中间模型。使导出类与基类之前产生差异的方法之一是改变现有基类的方法的行为，这被称之为覆盖（overriding），即重写基类的方法。伴随多态的可互换对象在试图将导出类型的对象当作其泛化基类型对象看待时，存在着一个问题：让泛化的导出类工作时，编译器在编译时不可能知道应该执行哪一段代码。一个非面向对象编程的编译器产生的函数调用会引起所谓的前期绑定，即每个函数都会被绑定一个绝对地址。而在OOP中，程序直到运行时才能确定代码的地址。为了解决这个问题，面向对象程序设计语言使用了后期绑定的概念。为了执行后期绑定，Java使用了一小段特殊的代码来替代绝对地址调用。这段代码使用在对象存储的信息中来计算方法体的地址。在某些语言中，必须明确地声明希望某个方法具备后期绑定所带来的灵活性（C++通过使用virtual关键字来实现的）。而在Java中，动态绑定是默认行为，无需添加额外的关键字。将导出类看作是它的基类的过程称为向上转型（upcasting）。一个面向对象程序肯定会在某处包含向上转型，因为这正是将自己从必须知道确切类型中解放出来的关键。单根继承结构在Java中，所有的类最终都继承自单一的基类—Object。事实证明，单根继承结构带来了很多好处：在单根继承结构中所有对象都具有一个共用接口，所以它们归根到底都是相同的基本类型。单根继承结构保证了所有对象都具备某些功能。因此你知道，你可以对任何对象执行某些基本操作。所有的对象都可以很容易地在堆上创建，而参数的传递也得到了很大的简化。单根继承结构使垃圾回收器的实现变得容易了很多。由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局。这对于系统级操作（如异常处理）显得尤其重要，并给编程带来了更大的灵活性。容器容器：在任何需要时都可以扩充自己以容纳你置于其中的所有东西。因为程序员不需要知道将来把多少对象置于容器内，只需要创建一个容器对象，然后让它处理所有的细节。Java中具有满足不同需要的各种类型的容器：List：用于存储序列；Map：关联数组，用来建立对象之间的关联；Set：每种对象类型只持有一个的集合其他：如队列、树、堆栈等参数化类型在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型：Object。单根继承结构意味着所有东西都是Object类型，所以可以存储Object的容器可以存储任何东西。这使得容器很容易被复用。但是由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object。因此它会丢失其身份。当把它取回时，就获取了一个对Object对象的引用，而不是对置入的那个类型对象的引用。这个时候需要向下转型(downcasting)才能得到确切的类型对象。我们知道，向上转型是安全的，但是向下转型却很危险（除非确切知道所要处理的对象类型）。解决方案被称为：参数化类型机制。参数化类型就是一个编译器可以自动定制作用于特定类型上的类。在Java中它称为范型。一对尖括号，中间包含类型信息（26个大写字母），通过这些特征就可以识别对范型的使用。1ArrayList&lt;Shape&gt; shapeLst = new ArrayList&lt;Shape&gt;();对象的创建和生命期在使用对象时，最关键的问题之一便是生成和销毁方式。每个对象为了生存都需要资源，尤其是内存。当我们不再需要一个对象时，它必须被清理掉，使其占有的资源可以被释放和重用。Java完全采用动态内存分配方式，每当想要创建新对象时，就要使用new关键字，在堆（heap）的内存池中动态创建对象实例。对于允许在堆栈上创建对象的语言，编译器可以确定对象的存活时间，并可以自动销毁它，即对象生命周期由编译器确定。Java提供了被称为“垃圾回收器”的机制，它可以自动发现对象何时不再被使用，并继而销毁它。垃圾回收器减少了所必需考虑的议题和必须编写的代码，提供了更高层的保障，可以避免暗藏的内存泄漏问题。C++为了追求最大的执行速度，对象的存储空间和生命周期都必须在编写程序时确定。而Java必须花费更多的CPU时间去回收对象。但是C++必须手动分配和释放对象，灵活性差，且常发生内存泄漏问题。并发编程在计算机编程中有一个基本概念，就是在同一时刻处理多个任务的思想。我们想把问题切分成多个可独立运行的部分（任务），从而提高程序的响应能力。在程序中，这些彼此独立运行的部分称之为线程，上述概念称之为“并发”。多线程所带来的便利之一便是程序员不用再担心机器上是有多个处理器还是只有一个处理器，因为程序在逻辑上被分为线程，同时使程序执行更快。但并发存在一个隐患：共享资源。如果有多个并发任务都要访问同一项资源，那么就会出问题。解决的方案一般是：某个任务锁定某项资源，完成其任务，然后释放资源锁，使其他任务可以使用这项资源。并发：从时间上也是有先后顺序的，只是时间极短，故在人感受上是同时的。例如，线程A和线程B实际上是先后执行的，但对用户来看是一起发生的。那么为什么会发生争夺共享资源呢？因为CPU分配的时间片是长度是一定的，线程A在这个时间片上使用资源1，使用到一半时间片用完了。那么这时候轮到线程B，它要使用资源1。这个时候如果不加锁，就会发生数据不一致的问题之类的。并行：从时间上是一致，比如两匹马同时在跑。异常处理：处理错误异常处理将错误处理直接置于编程语言中，甚至于操作系统中。异常是一种对象，它从出错地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”。异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径。因为它是另一条完全分离的执行路径，所以它不会干扰正常的执行代码。异常不能被忽略，所以它保证一定会在某处得到处理。需要指出的是：异常提供了一种从错误状态进行可靠恢复的途径，这帮助编写更健壮的程序。","categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}]},{"title":"工厂模式","slug":"设计模式/工厂模式","date":"2020-05-25T11:57:00.000Z","updated":"2020-05-27T07:22:29.144Z","comments":true,"path":"设计模式/工厂模式/","link":"","permalink":"https://hengxincheung.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"引言工厂模式是一种创建型模式，它提供了了一种创建对象的最佳方式。使用工厂模式，创建对象时不会暴露客户端暴露创建逻辑（这个有点像接口的概念，客户端程序员不必关心内部的实现细节，并有效减少发生bug的概率），并且通过使用一个共同的接口来指向新创建的对象。针对的问题许多类对象的创建都需要一系列的步骤，可能需要计算或取得对象的初始设置，选择生成哪个子对象实例，或者在生成需要的对象之前必须先生成一些辅助对象的对象。这些情况下，对象的建立是一个过程，是一个操作。简而言之，工厂模式存在的意义是：高效地创建某一类对象。工厂模式的种类一般来说，工厂模式分为以下三种：简单工厂模式，又称静态工厂模式工厂方法模式，全程多个工厂方法模式抽象工厂模式角色组成概念工厂类角色：工厂模式的核心，含有一定的商业逻辑和判断逻辑，用以创建产品抽象产品角色：一类对象的抽象概念，即具体产品继承的父类或者实现的接口具体产品角色：工厂类所创建的对象就是此角色的实例，在Java中由一个具体类实现手机制造工厂本文以手机制造工厂生产各类手机为场景学习工厂模式。手机分为两类：苹果手机华为手机。注：随便举例，不存在任何话题。手机抽象父类123456public abstract class Phone&#123; // 手机的名字 private String name; // 打电话的方法 public abstract void call();&#125;苹果手机123456789public class IPhone extends Phone&#123; public IPhone()&#123; super(\"苹果手机\"); &#125; @Override public void call()&#123; System.out.println(super.getName() + \"正在打电话\"); &#125;&#125;华为手机123456789public class Huawei extends Phone&#123; public Huawei()&#123; super(\"华为手机\"); &#125; @Override public void call()&#123; System.out.println(super.getName() + \"正在打电话\"); &#125;&#125;简单（静态）工厂模式实现简单工厂模式的实现思想是：创建对象时候传入代表类型的参数type，然后再通过if-else或者switch语句根据type创建对应的对象返回。先看一下简单的代码实现：123456789101112131415161718public class PhoneFactory&#123; // 通过静态方法返回需要的手机实例 // type参数建议使用枚举，好处多多 public static Phone producePhone(String type)&#123; Phone phone; switch(type)&#123; case \"iphone\": phone = new IPhone(); break; case \"huawei\": phone = new Huawei(); break; default: throw new IllegalArgumentException(\"此型号手机暂不支持制造\"); &#125; return phone; &#125;&#125;简单工厂的机制很简单：根据传入的类型，创建对应的对象总结在简单工厂模式中，提供创建对象的方法一般是静态的，故也被称为静态工厂模式。优点实现简单：代码逻辑简单可复用高：所有对象的创建都通过同名的方法创建缺点容错率低：如果传入的类型参数因为粗心写错，则创建的产品会与预期不符耦合度高：所有对象的共用一个创建方法，每增减一种产品，都需要对这个唯一的方法进行修改扩展性差：每增减一种产品，都需要修改工厂类，违背了设计模式中的开放-封闭原则（OCP，对扩展开放，对修改关闭）（多个）工厂方法模式实现工厂方法模式的关键点在于：为每种对象提供相应的工厂方法。12345678910public class PhoneFactory&#123; // 制造苹果手机的方法 public static Phone produceIPhone()&#123; return new IPhone(); &#125; // 制造华为手机的方法 public static Phone produceHuawei()&#123; return new Huawei(); &#125;&#125;总结（多个）工厂方法模式，为每种对象分别编写专用的创建方法，根据调用的创建方法不同，产生不同对象。优点实现简单：代码逻辑容易理解容错率高：每种对象都有专用的创建方法，无需传入类型等参数，只要调用正确的创建方法就不会出错。（这一点有点异议，感觉跟简单工厂模式传参错误的概率是一样）耦合度低：每增减一种产品，只需要增减一个创建方法，不会影响其他对象的创建方法缺点扩展性差：每增减一种产品，都需要修改工厂类，违背了开闭原则可复用低：所有对象的创建方法都不同名抽象工厂模式实现抽象工厂模式的关键点在于：为每种对象提供单独的工厂和工厂方法。所以需要把工厂类抽象出来，形成抽象工厂，然后针对每种对象分别实现专用的工厂及工厂方法，这就是抽象工厂的命名由来。1.抽象工厂:AbstractPhoneFactory1234public abstract class AbstractPhoneFactory&#123; // 生成手机的抽象方法 public abstract Phone producePhone();&#125;2.苹果手机专用生产工厂：IPhoneFactory123456public class IPhoneFactory extends AbstractPhoneFactory&#123; @Override public Phone producePhone()&#123; return new IPhone(); &#125;&#125;3.华为手机专用生产工厂：HuaweiFactory123456public class HuaweiFactory extends AbstractPhoneFactory&#123; @Override public Phone producePhone()&#123; return new Huawei(); &#125;&#125;4.测试1234567// 苹果手机的工厂AbstractPhoneFactory factory = new IPhoneFactory();// 制造一台苹果手机Phone phone = factory.producePhone();// 调用苹果手机的打电话方法phone.call();// 输出：苹果手机正在打电话总结抽象工厂模式：定义一个抽象工厂和其抽象方法，每种对象都有专用的子工厂及对象创建方法。个人理解，就像富士康（抽象父工厂）有许多的车间（具体的工厂）生产不同的产品。优点容错率高：因为每种对象都有专用的工厂及创建方法，只要调用正确的工厂就不会出错耦合度低：每增减一种产品，只需要增减一个工厂及其方法，不会影响其他对象的创建方法扩展性好：每增减一种产品，只需要增减此对象的工厂及其创建方法，不会修改其他工厂，遵循开闭原则可复用高：所有对象的创建都通过同名的方法创建缺点实现复杂：代码逻辑相对复杂，$n$ 个对象需要定义 $n$ 个工厂类","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"Java编程思想","slug":"Java编程思想","permalink":"https://hengxincheung.github.io/categories/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/categories/web/"},{"name":"统计机器学习","slug":"统计机器学习","permalink":"https://hengxincheung.github.io/categories/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"git","slug":"git","permalink":"https://hengxincheung.github.io/categories/git/"},{"name":"linux快速入门","slug":"linux快速入门","permalink":"https://hengxincheung.github.io/categories/linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"numpy教程","slug":"numpy教程","permalink":"https://hengxincheung.github.io/categories/numpy%E6%95%99%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hengxincheung.github.io/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"https://hengxincheung.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"},{"name":"web","slug":"web","permalink":"https://hengxincheung.github.io/tags/web/"},{"name":"权限系统","slug":"权限系统","permalink":"https://hengxincheung.github.io/tags/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/"},{"name":"用户系统","slug":"用户系统","permalink":"https://hengxincheung.github.io/tags/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/"},{"name":"统计机器学习","slug":"统计机器学习","permalink":"https://hengxincheung.github.io/tags/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"随机森林","slug":"随机森林","permalink":"https://hengxincheung.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"},{"name":"git","slug":"git","permalink":"https://hengxincheung.github.io/tags/git/"},{"name":"登录","slug":"登录","permalink":"https://hengxincheung.github.io/tags/%E7%99%BB%E5%BD%95/"},{"name":"RESTful","slug":"RESTful","permalink":"https://hengxincheung.github.io/tags/RESTful/"},{"name":"linux","slug":"linux","permalink":"https://hengxincheung.github.io/tags/linux/"},{"name":"numpy","slug":"numpy","permalink":"https://hengxincheung.github.io/tags/numpy/"},{"name":"python","slug":"python","permalink":"https://hengxincheung.github.io/tags/python/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hengxincheung.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}